# 漏洞描述
在Linux内核版本4.9+中，攻击者通过构造恶意数据包，使得内核在执行 tcp_collapse_ofo_queue() 和 tcp_prune_ofo_queue() 函数时，让CPU使用率达到饱和状态，从而造成拒绝服务攻击。攻击者为了维持拒绝服务攻击需要连续的双向TCP会话到可达的开放端口，因此无法使用欺骗的IP地址执行攻击。

# 背景

TCP（sequence-preserving data stream service.）提供面向连接、可靠、基于字节流的传输层通信协议。

为了传输数据流，TCP将数据流分割成段然后通过互联网传输，并在接收端进行重组段。

在Linux内核中（4.9+），使用了效率较为低的重组算法，则导致花费的CPU时间随着要重组的段的增加呈线性增长。

# 解决方案

- 一个临时解决方案是限制每个TCP连接的重组队列大小。可以通过sysctl命令进行设置（net.inet.tcp.reass.maxqueuelen）.但是设置的太小的话会影响TCP连接的吞吐量。(注：我貌似没发现这个选项)

- 查看相应厂商是否发布相关补丁，如有则及时更新

- 自己手工进行修复

- 查看系统CPU使用率是否过高，且接受到大量异常数据，如有，则在防火墙上屏蔽相应IP。

# 漏洞分析环境

内核版本：Linux version 4.10.0

体系结构：x86_64

发行版: Ubuntu 14.04

# 漏洞分析

内核调用栈:

```c
tcp_v4_rcv -->

tcp_v4_do_rcv -->

tcp_rcv_established -->

tcp_data_queue -->

tcp_try_rmem_schedule -->

tcp_prune_queue -->

tcp_collapse_ofo_queue与 tcp_prune_ofo_queue

```

因为tcp_v4_rcv是内核ip层到tcp层的入口，而且该漏洞是TCP层的漏洞,所以我们追踪的函数起源是tcp_v4_rcv。

在处理TCP包时，会用到三个队列：receive、out_of_order、prequeue、backlog

我们来分析，看如何构造数据，才能调用到tcp_prune_queue函数（忽略掉连接建立，只考虑连接已经建立的情况）。首先第一步肯定是将out_of_order(乱序队列)填满,然后才调用tcp_prune_queue函数。

#### tcp_v4_rcv --> tcp_v4_do_rcv

```C
int tcp_v4_rcv(struct sk_buff *skb)
{
    ............................
    if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v4_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
    ............................
}
```
在没有进程使用这个套接字（或用户在tcp_recvmsg里，执行release_sock）才进入if.否则数据包进入backlog队列。

tcp_prequeue在用户指定不使用prequeue队列，或用户没有调用recv这样的函数并阻塞，就返回false。此时才调用我们的tcp_v4_do_rcv函数

#### tcp_v4_do_rcv --> tcp_rcv_established

```c
int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
{
    
    if (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */
		struct dst_entry *dst = sk->sk_rx_dst;

		sock_rps_save_rxhash(sk, skb);
		sk_mark_napi_id(sk, skb);
		if (dst) {
			if (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||
			    !dst->ops->check(dst, 0)) {
				dst_release(dst);
				sk->sk_rx_dst = NULL;
			}
		}
		tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);
		return 0;
	}

}
```
在连接建立的情况下直接调用tcp_rcv_established

#### tcp_rcv_established --> tcp_data_queue

参考资料6

#### tcp_data_queue --> tcp_try_rmem_schedule

这个数据包是进程待接收的，且在滑动窗口内,并且没有进程在读取该socket，则调用tcp_try_rmem_schedule

如果该数据包不是进程待接收的，但是在窗口内，则把他加入out_of_order队列

#### tcp_try_rmem_schedule --> tcp_prune_queue

```c
static int tcp_try_rmem_schedule(struct sock *sk, struct sk_buff *skb,
				 unsigned int size)
{
	if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||
	    !sk_rmem_schedule(sk, skb, size)) {

		if (tcp_prune_queue(sk) < 0)
			return -1;

		while (!sk_rmem_schedule(sk, skb, size)) {
			if (!tcp_prune_ofo_queue(sk))
				return -1;
		}
	}
	return 0;
}
```

接受缓冲队列已分配的字节 大于 每个sock最大buf值时 或 当前skb加入后超过buf的限制 就调用 tcp_prune_queue 释放 out_of_order 队列以便腾出内存空间。

#### tcp_prune_queue 分析
参考资料2

# 漏洞利用

# 资料

1.Linux 4.10.0内核在线源代码

https://elixir.bootlin.com/linux/v4.10/source


2.Linux 内核存在 TCP 安全漏洞:

https://paper.seebug.org/659/

3.Resource exhaustion in TCP reassembly:

https://www.freebsd.org/security/advisories/FreeBSD-SA-18:08.tcp.asc

4.内核协议栈tcp层的内存管理:

http://simohayha.iteye.com/blog/532450


5.高性能网络编程3----TCP消息的接收:

https://blog.csdn.net/russell_tao/article/details/9950615

6.Linux TCP数据包接收处理tcp_rcv_established

http://abcdxyzk.github.io/blog/2015/04/01/kernel-net-estab/

7.raw socket模拟TCP三次握手

https://blog.csdn.net/nice_wen/article/details/53428354

8.linux原始套接字(3)-构造IP_TCP发送与接收

https://www.bbsmax.com/A/LPdoY7vOJ3/

9.Linux网络编程——浅谈 TCP 三次握手和四次挥手

https://blog.csdn.net/lianghe_work/article/details/46458889