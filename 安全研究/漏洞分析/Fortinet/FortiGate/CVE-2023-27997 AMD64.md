# 环境

FGT: 7.2.0

# 关键代码分析

```c
__int64 __fastcall sub_164E180(__int64 a1, _QWORD *a2, const char *a3)
{
  int v4; // eax
  int v5; // er8
  int v6; // er9
  __int64 v7; // r13
  char v8; // bl
  int v9; // er8
  int v10; // er9
  signed int v11; // eax
  _BYTE *v12; // rdx
  int v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  int v16; // er8
  _BYTE *v17; // rdx
  __int64 v18; // r13
  __int64 v19; // r12
  int v20; // ebx
  __int64 v21; // r12
  __int64 result; // rax
  int v23; // [rsp+0h] [rbp-D0h]
  int v24; // [rsp+Ch] [rbp-C4h]
  int v25; // [rsp+Ch] [rbp-C4h]
  _BYTE *v26; // [rsp+10h] [rbp-C0h] BYREF
  __int64 v27; // [rsp+18h] [rbp-B8h] BYREF
  char v28[96]; // [rsp+20h] [rbp-B0h] BYREF
  char v29[24]; // [rsp+80h] [rbp-50h] BYREF
  unsigned __int64 v30; // [rsp+98h] [rbp-38h]

  v30 = __readfsqword(0x28u);
  v4 = strlen(a3);
  v23 = v4;
  v24 = v4;
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8, (unsigned int)"enc data length invalid (%d)\n", v4, v5, v6);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
    v26 = (_BYTE *)jmalloc(*a2, (v23 >> 1) + 1);
    if ( v26 )
    {
      v7 = 0LL;
      do
      {
        v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
        v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
        ++v7;
      }
      while ( v24 > 2 * (int)v7 );
      v11 = ((unsigned int)(v23 - 1) >> 1) + 1;
      if ( v23 <= 0 )
        v11 = 1;
      v26[v11] = 0;
      v12 = v26;
      v13 = (unsigned __int8)*v26;
      if ( (_BYTE)v13 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
        v12 = v26;
      }
      v26 = v12 + 4;
      v14 = *((_WORD *)v12 + 2);
      v15 = (unsigned __int8)(v14 ^ v29[0]);
      BYTE1(v15) = v29[1] ^ HIBYTE(v14);
      v16 = (unsigned __int8)(v14 ^ v29[0]);
      if ( v23 - 5 <= v16 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
        result = 1LL;
      }
      else
      {
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
        while ( *v26 )
        {
          v27 = sub_1613C90(*a2, &v26, 38LL);
          if ( !v27 )
            break;
          v21 = sub_1613C90(*a2, &v27, 61LL);
          sub_1614FD0(v21, 0LL);
          sub_1614FD0(v27, 0LL);
          sub_15F20A0(*(_QWORD *)(a1 + 744), v21, v27);
        }
        result = 0LL;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
```

### 分段分析

##### 0x00

```
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8LL, (__int64)"enc data length invalid (%d)\n", (unsigned int)v4);
    result = 0xFFFFFFFFLL;
  }
```

enc 参数的值的长度必须大于11，且长度为偶数

##### 0x01

```c
sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
```

利用salt的值（可以通过/remote/info获取salt的值），enc 参数的值的前8个字节，字符串"GCC is the GNU Compiler Collection."，计算一个md5值。保存到v29。

##### 0x02

```c
__int64 __fastcall sub_15F13D0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // r8
  unsigned __int64 v4; // rbx
  __int64 result; // rax
  unsigned __int64 v6; // r13
  _QWORD *v7; // rax
  __int64 v8; // r8

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[2];
  if ( !a2 )
    return 0LL;
  v4 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
  if ( *v2 < v3 + v4 )
  {
    v6 = dword_A782904 - 25;
    if ( v6 < v4 )
      v6 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
    v7 = (_QWORD *)je_malloc(v6 + 24);
    if ( !v7 )
      sub_15F3F90();
    v7[1] = 0LL;
    v7[2] = v7 + 3;
    *v7 = (char *)v7 + v6 + 24;
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
    v8 = v7[2];
    *(_QWORD *)(a1 + 8) = v7;
    v7[2] = v8 + v4;
    result = v8;
  }
  else
  {
    v2[2] = v3 + v4;
    result = v3;
  }
  return result;
}
 v26 = (_BYTE *)sub_15F13D0(*a2, (v23 >> 1) + 1);
```

分配一个 enc参数的值的长度，除以2 然后加1 还要加个24 ，的内存大小

##### 0x03

```c
do
{
	v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
	v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
	++v7;
}
```

将enc的值，每两个字节，转换为一个对应的值，如将“1A” 转换为 1a，相当于16进制的两个可打印字符转为，一个对应的一个字节值的,

如：enc="1234567890"  转换后

内存的值为:{18,52,86,120,144}

"12" ==> 18

"34" ==> 52

"56" ==> 86

.....................

##### 0x04

```c
v13 = (unsigned __int8)*v26;
if ( (_BYTE)v13 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
	v12 = v26;
}
```

enc 开头的前两个字节为"00" , 这样经过转换后v26[0]的值为0

##### 0x05 漏洞点位

```c
v26 = v12 + 4;
v14 = *((_WORD *)v12 + 2);
v15 = (unsigned __int8)(v14 ^ v29[0]);
BYTE1(v15) = v29[1] ^ HIBYTE(v14);
v16 = (unsigned __int8)(v14 ^ v29[0]);
if ( v23 - 5 <= v16 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
	result = 1LL;
}
```

v16变量为数据的长度，用户可控制，实际分配的内存大小为:((strlen(enc)>>1)+1)，但是这里判断时大于等于(strlen(enc) -5) 才退出



也就是说我们可以越界 ((strlen(enc)>>1)+1) 到 (strlen(enc) -5) 的内容



v16的计算方法为：将enc[8:12]的两个16进制可打印字符（e g:"1a2f" , 占用4个字节），转换为对应的两个字节后(eg:{0x1a,0x2f})，然后异或0x01分析哪里出来的md5值

##### 0x06

```c
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
```

首先将enc[12:]每两个字节的16进制字符转换为一个字节后（eg：”1a“--> {26}），与0x01分析哪里出来的md5值的offset 2---15 进行异或，后续用上一轮的md5值，计算一个新的md5值，然后在进行异或，直到 v16

# enc结构分析

```
|---8个字节用于进行第一次的md5值计算，前两个字节必须为“00”---|---4个字节表示后续数据大小---|---data---|
```

经过0x03代码片段，会将enc 每两个字节，转换为一个字节（16进制可打印字符转换，eg：“1a21” --》 {26,33}）

# poc





# 资料

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

https://blog.lexfo.fr/xortigate-cve-2023-27997.html

xortigate-cve-2023-27997

https://github.com/lexfo/xortigate-cve-2023-27997