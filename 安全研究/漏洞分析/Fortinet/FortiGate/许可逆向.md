# 环境

版本：FGT_VM64_KVM-v7.2.8.M-build1639-FORTINET.out.kvm.zip

```
FortiGate-VM64-KVM # diagnose debug vm-print-license 
SerialNumber: FGVMEVK_DHXR4W10
CreateDate: Mon Aug 12 19:41:35 2024
Model: EVAL (1)
CPU: 1 
MEM: 2048
VDOM license:
  permanent: 2
  subscription: 0
```

```
FortiGate-VM64-KVM # get sys stat
Version: FortiGate-VM64-KVM v7.2.8,build1639,240313 (GA.M)
Security Level: 1
Firmware Signature: certified
Virus-DB: 1.00000(2018-04-09 18:07)
Extended DB: 1.00000(2018-04-09 18:07)
Extreme DB: 1.00000(2018-04-09 18:07)
AV AI/ML Model: 0.00000(2001-01-01 00:00)
IPS-DB: 6.00741(2015-12-01 02:30)
IPS-ETDB: 6.00741(2015-12-01 02:30)
APP-DB: 6.00741(2015-12-01 02:30)
FMWP-DB: 0.00000(2001-01-01 00:00)
INDUSTRIAL-DB: 6.00741(2015-12-01 02:30)
IPS Malicious URL Database: 1.00001(2015-01-01 01:01)
IoT-Detect: 0.00000(2022-08-17 17:31)
Serial-Number: FGVMEVK_DHXR4W10
License Status: Invalid
VM Resources: 1 CPU/1 allowed, 1992 MB RAM/2048 MB allowed
Log hard disk: Available
Hostname: FortiGate-VM64-KVM
Operation Mode: NAT
Current virtual domain: root
Max number of virtual domains: 2
Virtual domains status: 1 in NAT mode, 0 in TP mode
Virtual domain configuration: disable
FIPS-CC mode: disable
Current HA mode: standalone
Branch point: 1639
Release Version Information: GA
FortiOS x86-64: Yes
System time: Wed Aug 14 00:55:37 2024
Last reboot reason: warm reboot
```

# 分析

根据get sys stat 命令，以及License Status:字符串  我们可以定位到函数sub_23B43D0：

```c
__int64 sub_23B8320()
{
  __int64 v0; // r12
  __int64 result; // rax
  int v2; // r9d
  __int64 v3[18]; // [rsp+0h] [rbp-90h] BYREF

  v3[15] = __readfsqword(0x28u);
  memset(v3, 0, 0x78uLL);
  v3[7] = (__int64)sub_23B43D0;
  puts("register system.status");
  v0 = add_sub_command("system", "status", &algn_2000801[9], 0LL);
  result = 0LL;
  if ( v0 )
  {
    sub_22E2CF0(v0, 16LL);
    add_command_desc(v0, 0, 4096LL, 0LL, (__int64)"System status.", v2);
    add_command_handler(v0, v3);
    return 1LL;
  }
  return result;
}
```

```c
__int64 __fastcall sub_23B43D0(__int64 a1, const char *a2)
{

  v82 = __readfsqword(0x28u);
  v3 = sub_2A84FD0();
  if ( nCfg_debug_zone )
  {
    setenv("TZ", nCfg_debug_zone + 17625152, 1);
    tzset();
  }
  sub_2A47650(v73, 128LL);
  sub_2731DC0(a2, "Version: %s\n", v73);
  v4 = sub_2A420D0();
  sub_2731DC0(a2, "Security Level: %d\n", v4);
  if ( (*(_BYTE *)(v3 + 1) & 2) == 0 && !(unsigned int)sub_2AA0750() )
  {
    v49 = (const char *)sub_2A44790();
    sub_2731DC0(a2, "Firmware Signature: %s\n", v49);
  }
  sub_2907A20(1LL, v72, 64LL);
  sub_2731DC0(a2, "Virus-DB: %s\n", v72);
  sub_2907A20(2LL, v72, 64LL);
  sub_2731DC0(a2, "Extended DB: %s\n", v72);
  sub_2907A20(3LL, v72, 64LL);
  sub_2731DC0(a2, "Extreme DB: %s\n", v72);
  sub_2907A20(32LL, v72, 64LL);
  sub_2731DC0(a2, "AV AI/ML Model: %s\n", v72);
  sub_2907A20(8LL, v72, 64LL);
  sub_2731DC0(a2, "IPS-DB: %s\n", v72);
  sub_2907A20(9LL, v72, 64LL);
  sub_2731DC0(a2, "IPS-ETDB: %s\n", v72);
  sub_2907A20(0LL, v72, 64LL);
  sub_2731DC0(a2, "APP-DB: %s\n", v72);
  sub_2907A20(36LL, v72, 64LL);
  sub_2731DC0(a2, "FMWP-DB: %s\n", v72);
  sub_2907A20(10LL, v72, 64LL);
  sub_2731DC0(a2, "INDUSTRIAL-DB: %s\n", v72);
  sub_2907A20(11LL, v72, 64LL);
  sub_2731DC0(a2, "IPS Malicious URL Database: %s\n", v72);
  sub_2907A20(33LL, v72, 64LL);
  sub_2731DC0(a2, "IoT-Detect: %s\n", v72);
  sub_2731DC0(a2, "Serial-Number: %s\n", nCfg_debug_zone + 4468);
  v5 = sub_2A9D900(a2);
  v6 = "No License";
  if ( v5 )
  {
    v6 = (const char *)*((unsigned int *)nCfg_debug_zone + 7123);
    switch ( *((_DWORD *)nCfg_debug_zone + 7123) )
    {
      case 0:
        sub_2905BD0();
        v6 = "Startup";
        break;
      case 1:
        v6 = "Cert Not Yet Valid" + 13;
        break;
      case 2:
        v6 = "Pending";
        if ( *((_DWORD *)nCfg_debug_zone + 7122) )
          v6 = "Warning";
        break;
      case 3:
        v64 = sub_2A9FFA0();
        v6 = "CRL Expired" + 4;
        if ( !v64 )
          goto LABEL_117;
        break;
      case 4:
        if ( *((_DWORD *)nCfg_debug_zone + 7122) )
        {
          v6 = "Cert Not Yet Valid" + 13;
          if ( *((_DWORD *)nCfg_debug_zone + 7126) )
            v6 = "Invalid Copy";
        }
        else
        {
LABEL_117:
          v6 = "OCSP Response Invalid" + 14;
        }
        break;
      case 5:
        v6 = "CRL Expired" + 4;
        break;
      case 6:
        v6 = "Grace Period";
        break;
      default:
        break;
    }
  }
  v7 = (__int64)"License Status: %s\n";
  v8 = (char *)a2;
  sub_2731DC0(a2, "License Status: %s\n", v6);
  ..............................
```

sub_2A9D900 --> sub_2A9CF70 ---> sub_2A9EDB0 疑似许可证验证：



### 首先读取/data/etc/vm.lic文件，当前内容为：

```
-----BEGIN FGT VM LICENSE-----
IAAAAAKRuIxjmNthgg8KSPoO5zn9eq9/pEUGn0GhBzVw1zYLUAAAAGudDDBYBHbv
IJeZkuZx6x3TppXDopE4T/q6GnhcIwM5+BLuCM6OuybViGlQptNJqDTZeL+kx209
edacYuju03gJ4pkxwh6RCNZQoLJKeeqG
-----END FGT VM LICENSE-----
```

### 然后对-----BEGIN FGT VM LICENSE----- 到 -----END FGT VM LICENSE-----的部分进行base64解密

```python
import base64
import struct

base64_encoded_data = """IAAAAAKRuIxjmNthgg8KSPoO5zn9eq9/pEUGn0GhBzVw1zYLUAAAAGudDDBYBHbv
IJeZkuZx6x3TppXDopE4T/q6GnhcIwM5+BLuCM6OuybViGlQptNJqDTZeL+kx209
edacYuju03gJ4pkxwh6RCNZQoLJKeeqG
"""

base64_decoded_data = base64.b64decode(base64_encoded_data)

rsa_decrypt_len  = struct.unpack('<I', base64_decoded_data[:4])[0]

print(rsa_decrypt_len)
```

output：

```
32
```

### 调用函数sub_2A9EAF0获取公钥信息

```c
__int64 sub_2A9EAF0()
{
  __int64 v0; // rax
  char i; // dl
  char v2; // dl
  void *v4; // [rsp+0h] [rbp-20h] BYREF
  char v5[17]; // [rsp+Fh] [rbp-11h] BYREF

  *(_QWORD *)&v5[9] = __readfsqword(0x28u);
  strcpy(v5, "/urandom");
  if ( !dword_F8AD4E4 )
  {
    v0 = 1LL;
    for ( i = '/'; ; i = v5[v2 & 7] )
    {
      byte_48735DF[v0] ^= i;
      v2 = v0++;
      if ( v0 == 95 )
        break;
    }
    dword_F8AD4E4 = 1;
  }
  v4 = &unk_48735E0;
  return d2i_PUBKEY(0LL, &v4, 94LL);
}
```

IDA Python 脚本：

```python
import hashlib
import os
import idc
import idaapi
import idautils
from Crypto.Cipher import ChaCha20
from Crypto.PublicKey import RSA
from Crypto.Util.asn1 import DerSequence


def read_rsa_public_key(public_key_der): 
    # 从 DER 编码数据中加载 RSA 公钥       
    public_key = RSA.import_key(public_key_der)
    print("Public Key:")
    print(public_key.export_key().decode())

encrypt_data = idaapi.get_bytes(0x48735E0,94)
decrypt_data = b'';
key = bytes("/urandom", 'utf-8')

for i in range(94):
    decrypt_data += bytes([encrypt_data[i] ^ key[i&7]])
print(len(decrypt_data))
read_rsa_public_key(decrypt_data)
```

Output:

```
94
Public Key:
-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPEk9M+bkeKVkhvuSbvOLFqhraNgpcLM
BkqvHLtZTiiN4wfMDcho2gbETdazJ9ewg6PTWf+d3H8YDccJtUSAIMkCAwEAAQ==
-----END PUBLIC KEY-----
```

### 用公钥对base64解密的数据，解密

其中base64解密的数据的前4个字节为要解密数据的长度

```python
#!/usr/bin/python3
import hashlib
import os
import base64
import rsa
import sys
import binascii
import hashlib
import struct
from rsa import transform, core
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad, unpad

base64_encoded_data = """IAAAAAKRuIxjmNthgg8KSPoO5zn9eq9/pEUGn0GhBzVw1zYLUAAAAGudDDBYBHbv
IJeZkuZx6x3TppXDopE4T/q6GnhcIwM5+BLuCM6OuybViGlQptNJqDTZeL+kx209
edacYuju03gJ4pkxwh6RCNZQoLJKeeqG
"""

pem_public_key ="""-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPEk9M+bkeKVkhvuSbvOLFqhraNgpcLM
BkqvHLtZTiiN4wfMDcho2gbETdazJ9ewg6PTWf+d3H8YDccJtUSAIMkCAwEAAQ==
-----END PUBLIC KEY-----"""

def rsa_decrypt(encrypt_text):
    key = rsa.PublicKey.load_pkcs1_openssl_pem(pem_public_key)

    d = key.e
    n = key.n
    encrypt_text = binascii.a2b_hex(encrypt_text)
    num = transform.bytes2int(encrypt_text)
    decrypto = core.decrypt_int(num, d, n)
    out = transform.int2bytes(decrypto)
    return out

base64_decoded_data = base64.b64decode(base64_encoded_data)
rsa_decrypt_len  = struct.unpack('<I', base64_decoded_data[:4])[0]
print("rsa_decrypt_len",rsa_decrypt_len)

data = rsa_decrypt(base64_decoded_data[4:4+rsa_decrypt_len].hex())
```

# 一些有用的函数原型

### RSA_public_decrypt

RSA_public_decrypt 是 OpenSSL 库中的一个函数，用于使用 RSA 公钥解密数据

函数原型:

```c
int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding);
```

参数说明:

- int flen: 输入数据的长度（字节数）。
- *const unsigned char from: 指向要解密的数据的指针。
- *unsigned char to: 指向存储解密后数据的缓冲区的指针。
- *RSA rsa: 指向 RSA 密钥结构体的指针，使用的公钥。
- int padding: 填充模式，通常是以下之一：
- - RSA_PKCS1_PADDING: 使用 PKCS#1 v1.5 填充。（1）
-	-	RSA_NO_PADDING: 无填充。（-1）
- -	RSA_PKCS1_OAEP_PADDING: 使用 PKCS#1 v2.0 OAEP 填充（推荐）。（4）