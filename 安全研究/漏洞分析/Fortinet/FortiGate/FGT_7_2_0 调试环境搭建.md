# 环境搭建

### 创建log磁盘

```
qemu-img create -f qcow2 data.qcow2 30G
```

### 挂载qcow2 文件

```
sudo modprobe nbd max_part=8
sudo qemu-nbd --connect=/dev/nbd0 path_to_your.qcow2
sudo fdisk -l /dev/nbd0
sudo mount -o ro /dev/nbd0p1 /mnt/

sudo umount /mnt
sudo qemu-nbd --disconnect /dev/nbd0
```

### 内核解压

```
vmlinux-to-elf flatkc flatkc.elf
```

### rootfs

```
gzip -d rootfs.gz
cpio -id < rootfs
```

##### .tar.xz解压

```
sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
sudo chroot . /sbin/xz --check=sha256 -d /migadmin.tar.xz
sudo chroot . /sbin/ftar -xf /migadmin.tar
sudo chroot . /sbin/xz --check=sha256 -d /usr.tar.xz
sudo chroot . /sbin/ftar -xf /usr.tar
sudo chroot . /sbin/xz --check=sha256 -d /node-scripts.tar.xz
sudo chroot . /sbin/ftar -xf /node-scripts.tar
```

### sbin/init 修改

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char *argv[4]; // [rsp+0h] [rbp-20h] BYREF

  argv[3] = (char *)__readfsqword(0x28u);
  sub_4017D0();//扫描/目录下所有文件，计算完整性，保存到/.fgtsum中
  unlink("/sbin/init.chk");
  if ( (int)sub_401AD0("bin") >= 0 && (int)sub_401AD0("migadmin") >= 0 && (int)sub_401AD0("node-scripts") >= 0 )
    sub_401AD0("usr");
  argv[0] = "/bin/init";
  argv[1] = 0LL;
  execve("/bin/init", argv, 0LL);
  return 0LL;
}
```


由于我们直接将bin.tar.xz、migadmin.tar.xz、usr.tar.xz、node-scripts.tar.xz 直接解压了的，不需要sbin/init中的解压逻辑，但是需要打开文件，以添加文件hash的逻辑，因此需要patch sbin/init ：

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char *argv[4]; // [rsp+0h] [rbp-20h] BYREF

  argv[3] = (char *)__readfsqword(0x28u);
  sub_4017D0();// /目录完整性计算
  unlink("/sbin/init.chk");
  argv[0] = "/bin/init";
  argv[1] = 0LL;
  execve("/bin/init", argv, 0LL);
  return 0LL;
}
```

# 完整性检测

### 内核完整性检测

kernel_init --> init_post_isra_0 --> fgt_verify 会对/sbin/init进行完整性检查,需要将其返回0

```py
import idc
import idaapi
import idautils

data = idaapi.get_bytes(0xFFFFFFFF80803130, 10)
key = idaapi.get_bytes(0xFFFFFFFF8080324E, 4)

xor_result = bytes([byte ^ key[i % len(key)] for i, byte in enumerate(data)])

for b in xor_result:
    print(chr(b),end='')
```

### init 完整性检查

init 完整性只需要搞掉一个函数即可

main --> sub_4526B0 -->  sub_268AB20 ，该函数对/data/rootfs.gz 以及 /data/flatkc 进行完整性检查，需要使其返回1


# 后门植入

### busybox 编译

下载：https://busybox.net/downloads/

```shell
apt install libncurses-dev
make menuconfig
```

- Settings —> Build Options —> 选择[*] Build static binary (no shared libs) 
- 去掉 Coreutils—>sync 选项

编译：

```
make
```

会生成busybox二进制文件

### 后门制作

```c
/*gcc -static backdoor.c -o backdoor*/
#include <stdio.h>
#include <stdlib.h>

void shell() {
   system("/bin/busybox ls");
   system("/bin/busybox id");
   system("/bin/busybox killall sshd && /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22");
   system("/bin/busybox sh");
}

int main(int argc, char const *argv[]) {
   shell();
   return 0;
}
```

### 部署

现在，我们需要一种方法来执行 shell。一些研究人员已经给出了一种解决方案:存在独立的二进制文件(即没有符号链接到/bin/init)，可以替换并从有限的FortiGate CLI开始。其中之一是/bin/smartctl，我们可以使用“diag hardware smartctl”命令触发它。我们将其替换 shell，并将busybox链接到/bin/sh:

```
~/fortios/tmp$ cp ~/fortios/busybox-1.36.1/busybox ./bin/
~/fortios/tmp$ cp ~/fortios/backdoor ./bin/smartctl
~/fortios/tmp$ rm ./bin/sh
~/fortios/tmp$ ln -s /bin/busybox ./bin/sh
~/fortios/tmp$ sudo chmod 755 ./bin/busybox ./bin/smartctl ./bin/sh
```

### 运行shell

```
diag hardware smartctl
```

# 重打包

### rootfs

```
find . | cpio -H newc -o > ../rootfs
gzip rootfs
```

### 内核

修改完之后，重新压缩（需要比原来的要小或相等）：

```sh
cat flatkc.elf | gzip -9 > vmlinux.gz
```

然后用这个 patch flatkc，IDA Python 脚本：

```python
import idc
import idaapi
import idautils

def find_all_sequences(data, sequence):
    sequence_length = len(sequence)
    data_length = len(data)
    indices = []
    
    position = 0
    
    while position < data_length:
        position = data.find(sequence, position)
        if position == -1:
            break
        indices.append(position)
        position += 1
    return indices

start_addr = 0x200
end_addr   = 0x1A88FFE

img_data = idaapi.get_bytes(start_addr, end_addr - start_addr)
address = find_all_sequences(img_data,bytes([0x56, 0x48, 0x89, 0xF7,0x48,0x8d,0x35]))

patch_data = open('D:\\Work\\vmlinux.gz', 'rb').read()
print("patch data size:",len(patch_data))

for addr in address:
    addr += start_addr
    data = idaapi.get_bytes(addr, 39)
    if data[11:14] != bytes([0x48,0x8d,0x15]):
        continue
    if data[18] != 0xb9:
        continue
    if data[23:26] != bytes([0x49,0x89,0xe8]):
        continue
    if data[26:29] != bytes([0x49,0xc7,0xc1]):
        continue
    if data[33] != 0xe8:
        continue
    if data[38] != 0x5e:
        continue
    input_data_addr = addr + 18 + int.from_bytes(data[14:18], byteorder='little', signed=True)
    input_data_len  = int.from_bytes(data[19:23], byteorder='little', signed=True)
    input_data_len_addr = addr + 19
    decompressed_len = int.from_bytes(data[29:33], byteorder='little', signed=True)
    extract_kernel_addr = int.from_bytes(data[34:38], byteorder='little', signed=True) + 38 + addr
    
    print("input_data addr:",hex(input_data_addr))
    print("input_data_len:",input_data_len)
    print("input_data_len_addr:",hex(input_data_len_addr))
    print("decompressed_len:",hex(decompressed_len))
    print("extract_kernel addr:",hex(extract_kernel_addr))
    
    if len(patch_data) > input_data_len:
        print("error: patch_data_len > input_len")
        exit(-1)
        
    idaapi.patch_bytes(input_data_addr,patch_data)
    idaapi.patch_dword(input_data_len_addr,len(patch_data))
```

output:

```
patch data size: 7272506
input_data addr: 0x41b4
input_data_len: 7272509
input_data_len_addr: 0x6f3a2d
decompressed_len: 0x1a37918
extract_kernel addr: 0x6f66e0
```

然后IDA应用patch，自此完成内核的patch

# 参考资料

CVE-2022-42475 FortiGate SSLVPN 堆溢出漏洞分析与利用

https://forum.butian.net/share/2166