# 环境搭建

### 创建log磁盘

```
qemu-img create -f qcow2 data.qcow2 30G
```

### 挂载qcow2 文件

```
sudo modprobe nbd max_part=8
sudo qemu-nbd --connect=/dev/nbd0 fortios.qcow2
sudo fdisk -l /dev/nbd0
sudo mount /dev/nbd0p1 /mnt/

sudo umount /mnt
sudo qemu-nbd --disconnect /dev/nbd0
```

### 内核解压

```
vmlinux-to-elf flatkc flatkc.elf
```

### rootfs

```
gzip -d rootfs.gz
cpio -id < rootfs
```

##### .tar.xz解压

```
sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
sudo chroot . /sbin/xz --check=sha256 -d /migadmin.tar.xz
sudo chroot . /sbin/ftar -xf /migadmin.tar
sudo chroot . /sbin/xz --check=sha256 -d /usr.tar.xz
sudo chroot . /sbin/ftar -xf /usr.tar
sudo chroot . /sbin/xz --check=sha256 -d /node-scripts.tar.xz
sudo chroot . /sbin/ftar -xf /node-scripts.tar
```

### sbin/init 修改

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char *argv[4]; // [rsp+0h] [rbp-20h] BYREF

  argv[3] = (char *)__readfsqword(0x28u);
  sub_4017D0();//扫描/目录下所有文件，计算完整性，保存到/.fgtsum中
  unlink("/sbin/init.chk");
  if ( (int)sub_401AD0("bin") >= 0 && (int)sub_401AD0("migadmin") >= 0 && (int)sub_401AD0("node-scripts") >= 0 )
    sub_401AD0("usr");
  argv[0] = "/bin/init";
  argv[1] = 0LL;
  execve("/bin/init", argv, 0LL);
  return 0LL;
}
```


由于我们直接将bin.tar.xz、migadmin.tar.xz、usr.tar.xz、node-scripts.tar.xz 直接解压了的，不需要sbin/init中的解压逻辑，但是需要打开文件，以添加文件hash的逻辑，因此需要patch sbin/init ：

```c
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char *argv[4]; // [rsp+0h] [rbp-20h] BYREF

  argv[3] = (char *)__readfsqword(0x28u);
  sub_4017D0();// /目录完整性计算
  unlink("/sbin/init.chk");
  argv[0] = "/bin/init";
  argv[1] = 0LL;
  execve("/bin/init", argv, 0LL);
  return 0LL;
}
```

# 完整性检测

### 内核完整性检测

kernel_init --> init_post_isra_0 --> fgt_verify 会对/sbin/init进行完整性检查,需要将其返回0

```py
import idc
import idaapi
import idautils

data = idaapi.get_bytes(0xFFFFFFFF80803130, 10)
key = idaapi.get_bytes(0xFFFFFFFF8080324E, 4)

xor_result = bytes([byte ^ key[i % len(key)] for i, byte in enumerate(data)])

for b in xor_result:
    print(chr(b),end='')
```

### init 完整性检查

main --> sub_452660 -->  sub_44BE70 , 该函数对sbin/init程序生成的/.fgtsum进行一致性检查，需要使其始终返回1

main --> sub_4526B0 -->  sub_268AB20 ，该函数对/data/rootfs.gz 以及 /data/flatkc 进行完整性检查，需要使其始终返回1


# 后门植入

### busybox 编译

下载：https://busybox.net/downloads/

```shell
apt install libncurses-dev
make menuconfig
```

- Settings —> Build Options —> 选择[*] Build static binary (no shared libs) 
- 去掉 Coreutils—>sync 选项

编译：

```
make
```

会生成busybox二进制文件

### 后门制作

```c
/*gcc -static backdoor.c -o backdoor*/
#include <stdio.h>
#include <stdlib.h>

void shell() {
   system("/bin/busybox ls");
   system("/bin/busybox id");
   system("/bin/busybox killall sshd && /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22");
   system("/bin/busybox sh");
}

int main(int argc, char const *argv[]) {
   shell();
   return 0;
}
```

### 部署

现在，我们需要一种方法来执行 shell。一些研究人员已经给出了一种解决方案:存在独立的二进制文件(即没有符号链接到/bin/init)，可以替换并从有限的FortiGate CLI开始。其中之一是/bin/smartctl，我们可以使用“diag hardware smartctl”命令触发它。我们将其替换 shell，并将busybox链接到/bin/sh:

```
~/fortios/tmp$ cp ~/fortios/busybox-1.36.1/busybox ./bin/
~/fortios/tmp$ cp ~/fortios/backdoor ./bin/smartctl
~/fortios/tmp$ rm ./bin/sh
~/fortios/tmp$ ln -s /bin/busybox ./bin/sh
~/fortios/tmp$ sudo chmod 755 ./bin/busybox ./bin/smartctl ./bin/sh
```

### 运行shell

```
diag hardware smartctl
```

# 重打包

### rootfs

```
find . | cpio -H newc -o > ../rootfs
gzip -9 rootfs
```

### 内核

x64 调用 内核解压缩的调用指令为：

```asm
	pushq	%rsi			/* Save the real mode argument */
	movq	%rsi, %rdi		/* real mode address */
	leaq	boot_heap(%rip), %rsi	/* malloc area for uncompression */
	leaq	input_data(%rip), %rdx  /* input_data */
	movl	$z_input_len, %ecx	/* input_len */
	movq	%rbp, %r8		/* output target address */
	movq	$z_output_len, %r9	/* decompressed length, end of relocs */
	call	extract_kernel		/* returns kernel location in %rax */
	popq	%rsi
```

大概的汇编指令是(也可以通过字符串Destination address too large，交叉引用到此处)：

```asm
boot.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_start>:
   0:	56                   	push   %rsi
   1:	48 89 f7             	mov    %rsi,%rdi
   4:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # b <_start+0xb>
   b:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 12 <_start+0x12>
  12:	b9 00 00 00 00       	mov    $0x0,%ecx
  17:	49 89 e8             	mov    %rbp,%r8
  1a:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
  21:	e8 01 00 00 00       	call   27 <extract_kernel>
  26:	5e                   	pop    %rsi

0000000000000027 <extract_kernel>:
  27:	c3                   	ret    

Disassembly of section .data:

0000000000000000 <boot_heap>:
	...

Disassembly of section .bss:

```

将

```
-r--r--r-- 1 sysirq sysirq 7.2M Aug  6 14:06 flatkc
```

拖入IDA，通过IDA Python 完成匹配：

```python
import idc
import idaapi
import idautils

def find_all_sequences(data, sequence):
    sequence_length = len(sequence)
    data_length = len(data)
    indices = []
    
    position = 0
    
    while position < data_length:
        position = data.find(sequence, position)
        if position == -1:
            break
        indices.append(position)
        position += 1
    return indices

start_addr = 0x000
end_addr   = 0x413788

img_data = idaapi.get_bytes(start_addr, end_addr - start_addr)
address = find_all_sequences(img_data,bytes([0x56, 0x48, 0x89, 0xF7,0x48,0x8d,0x35]))

for addr in address:
    addr += start_addr
    data = idaapi.get_bytes(addr, 39)
    if data[11:14] != bytes([0x48,0x8d,0x15]):
        continue
    if data[18] != 0xb9:
        continue
    if data[23:26] != bytes([0x49,0x89,0xe8]):
        continue
    if data[26] != 0xe8:
        continue
        
    input_data_addr = addr + 18 + int.from_bytes(data[14:18], byteorder='little', signed=True)
    input_data_len  = int.from_bytes(data[19:23], byteorder='little', signed=True)
    extract_kernel_addr = int.from_bytes(data[27:31], byteorder='little', signed=True) + 31 + addr
    
    print("input_data addr:",hex(input_data_addr))
    print("input_data_len:",hex(input_data_len))
    print("extract_kernel addr:",hex(extract_kernel_addr))
```

output:

```
input_data addr: 0x4858
input_data_len: 0x3f73cd
extract_kernel addr: 0x3fe810
```

提取 input_data 先看看是个什么玩意：

```python
import idc
import idaapi
import idautils

input_data = idaapi.get_bytes(0x4858, 0x3f73cd)
open('D:\Work\input_data.bin', 'wb').write(input_data)

print("done")
```

```shell
sysirq@sysirq-machine:~/Work/Fortinet/kernel$ file input_data.bin 
input_data.bin: gzip compressed data, max compression, from Unix, original size modulo 2^32 10447208
```

解压，查看：

```sh
root@sysirq-machine:/home/sysirq/Work/Fortinet/FortiGate_7_2_0/kernel# ls -hl 
total 26M
-rw-r--r-- 1 sysirq sysirq 4.1M Nov 18 20:03 flatkc_back
-rw-rw-r-- 1 sysirq sysirq  12M Nov 18 20:04 flatkc.elf_back
-rw-r--r-- 1 root   root    10M Nov 19 14:09 input_data
root@sysirq-machine:/home/sysirq/Work/Fortinet/FortiGate_7_2_0/kernel# file input_data 
input_data: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=e3238dc4e39cf3b2afcc865e2d4b0ff602516c60, stripped
root@sysirq-machine:/home/sysirq/Work/Fortinet/FortiGate_7_2_0/kernel# 
```

拖进IDA，发现是没有符号的vmlinuz，我们可以通过使用 vmlinux-to-elf 解压出来的，带符号的内核，找到需要修改的地址，然后在该版本上进行修改。

修改完之后，重新压缩（ == **需要比原来的要小或相等** == ）：

```sh
cat input_data | gzip -9 > vmlinux.gz
```

然后用这个 patch flatkc，IDA Python 脚本：

```python
import idc
import idaapi
import idautils

def find_all_sequences(data, sequence):
    sequence_length = len(sequence)
    data_length = len(data)
    indices = []
    
    position = 0
    
    while position < data_length:
        position = data.find(sequence, position)
        if position == -1:
            break
        indices.append(position)
        position += 1
    return indices

start_addr = 0x000
end_addr   = 0x413788

img_data = idaapi.get_bytes(start_addr, end_addr - start_addr)
address = find_all_sequences(img_data,bytes([0x56, 0x48, 0x89, 0xF7,0x48,0x8d,0x35]))

patch_data = open('D:\\Work\\vmlinux.gz', 'rb').read()
print("patch data size:",len(patch_data))

for addr in address:
    addr += start_addr
    data = idaapi.get_bytes(addr, 39)
    if data[11:14] != bytes([0x48,0x8d,0x15]):
        continue
    if data[18] != 0xb9:
        continue
    if data[23:26] != bytes([0x49,0x89,0xe8]):
        continue
    if data[26] != 0xe8:
        continue
        
    input_data_addr = addr + 18 + int.from_bytes(data[14:18], byteorder='little', signed=True)
    input_data_len  = int.from_bytes(data[19:23], byteorder='little', signed=True)
    input_data_len_addr = addr + 19
    extract_kernel_addr = int.from_bytes(data[27:31], byteorder='little', signed=True) + 31 + addr
    
    print("input_data addr:",hex(input_data_addr))
    print("input_data_len:",hex(input_data_len))
    print("extract_kernel addr:",hex(extract_kernel_addr))
    
    if len(patch_data) > input_data_len:
        print("error: patch_data_len > input_len")
        exit(-1)
    idaapi.patch_bytes(input_data_addr,patch_data)
    idaapi.patch_dword(input_data_len_addr,len(patch_data))
```

output:

```
patch data size: 4158205
input_data addr: 0x4858
input_data_len: 0x3f72fd
extract_kernel addr: 0x3fe810
```

然后IDA应用patch，自此完成内核的patch

# fortios.qcow2 第一个分区大小调整

在修改完rootfs后，打包为rootfs.gz，文件可能过大，无法拷贝过去，此时需要调整分区大小

```
sudo qemu-nbd --connect=/dev/nbd0 fortios.qcow2
sudo fdisk -l /dev/nbd0

sudo e2fsck -f /dev/nbd0p1
sudo resize2fs /dev/nbd0p1 #这将自动调整文件系统大小，以使用整个分区（256MB）。

sudo qemu-nbd --disconnect /dev/nbd0
```

# 网络配置

获取网卡信息：

```
get hardware nic port1
```

CLI 配置网络：

### 配置静态IP地址

```
config system interface
edit port1
set mode static
set ip 192.168.182.188 255.255.255.0
set allowaccess ping http https ssh telnet
end
```

查看interfaces:

```
show system interface port1
```

### 配置默认路由

```
config router static
edit 1
set gateway 192.168.182.1
set device port1
end
```

查看路由配置：

```
show router static
```

### 配置DNS服务器

```
config system dns
set primary 8.8.8.8
set secondary 8.8.4.4
end
```

查看DNS配置

```
show system dns
```

之后，可以通过：192.168.182.188 访问Web管理页面，也可以通过ssh对其进行管理。

# 参考资料

CVE-2022-42475 FortiGate SSLVPN 堆溢出漏洞分析与利用

https://forum.butian.net/share/2166