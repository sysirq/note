# 环境

FGT: 7.2.0

CPU: 1

# 前置知识

HTTP分块传输编码（Chunked Transfer Encoding）通常用于在客户端和服务器之间传输大数据量时，尤其是在服务器不能预先知道数据总大小的情况下，或数据是动态生成时。它属于HTTP/1.1及以上版本的一部分。

### 工作原理

在HTTP响应报文中，当启用分块传输编码时，数据会被分成多个“块”进行传输。每个块由以下几个部分组成：

分块格式：

- 块大小： 每个数据块前都有一个十六进制数字，表示该块的字节数（不包括这个大小字段本身）。
- 块数据：紧接着大小字段的是实际的块数据，按大小字段指定的字节数传输。
- 换行符： 每个块后面都会跟着一个换行符\r\n，分隔开各个块。

最后一个块：

当所有数据块传输完毕后，会有一个大小为0的块，表示传输结束。这个块后面通常会跟着一个空行（\r\n），表示响应结束。

chunk 编码格式如下：

```
[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]
```

eg:

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
in chunks\r\n
0\r\n
\r\n
```

解释：

- 4\r\nWiki\r\n：第一个块的大小是4个字节，数据是Wiki
- 5\r\npedia\r\n：第二个块的大小是5个字节，数据是pedia。
- E\r\nin chunks\r\n：第三个块的大小是14个字节，数据是in chunks。
- 0\r\n\r\n：最后一个块，大小为0，表示传输结束。



# 漏洞原理

- 当解析 chunk 时，若长度字段解码后为 0，则触发读取 chunk trailer。
- 写入 chunk trailer 时，根据长度字段向栈中写入 \r\n。

# poc

查看一下处理chunk的流程在哪里：

```
handle SIGPIPE nostop
b *0x0000000001713A9F 
commands
    printf "read handler name:%s\n",$rcx+208
    continue
end
```

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 1
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 20

HOST = "192.168.182.188"
PORT = 8443  

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

sk = create_ssl_socket()

sk.sendall(("POST / HTTP/1.1\r\n").encode())
sk.sendall(("Host: %s:%d\r\n"%(HOST,PORT)).encode())
sk.sendall(("Connection: keep-alive\r\n").encode())
sk.sendall(("Transfer-Encoding: chunked\r\n").encode())
sk.sendall("\r\n".encode())

sk.sendall("4\r\n".encode())
sk.sendall("Wiki\r\n".encode())
sk.sendall("0\r\n".encode())
sk.sendall("\r\n".encode())
```

```
Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ap_read_request

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:http_write_memory
```

分析发现处理chunk请求的函数为read_client_block（sub_1705390）



最终处理函数为sub_1705390 -->  sub_1605950



```c
__int64 __fastcall sub_1605950(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  bool v9; // zf
  char v10; // al
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 result; // rax
  int v16; // eax
  __int64 v17; // r12
  const unsigned __int16 **v18; // rax
  unsigned __int8 *v19; // r13
  __int64 v20; // rax
  int v21; // eax
  __int64 v22; // rax
  __int64 v23; // rsi
  int v24; // esi
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rdx
  int v30; // eax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rdx
  __int64 v38; // rax
  char v39; // [rsp+7h] [rbp-29h] BYREF
  unsigned __int64 v40; // [rsp+8h] [rbp-28h]

  v5 = (unsigned int)a3;
  v40 = __readfsqword(0x28u);
  v39 = 0;
  switch ( *(_DWORD *)(a1 + 704) )
  {
    case 1:
      a2 = *(_QWORD *)(a1 + 744);
      goto LABEL_31;
    case 2:
      v5 = *(unsigned int *)(a1 + 736);
      a2 = *(_QWORD *)(a1 + 744);
      goto LABEL_12;
    case 3:
      goto LABEL_18;
    case 4:
      v23 = *(unsigned int *)(a1 + 736);
      goto LABEL_21;
    case 5:
      goto LABEL_2;
    case 8:
      goto LABEL_5;
    case 9:
      goto LABEL_34;
    default:
      v30 = *(_DWORD *)(a1 + 264);
      *(_QWORD *)(a1 + 720) = 0LL;
      *(_QWORD *)(a1 + 712) = 0LL;
      *(_QWORD *)(a1 + 728) = 0LL;
      *(_DWORD *)(a1 + 736) = a3;
      *(_QWORD *)(a1 + 744) = a2;
      if ( v30 )
      {
        if ( *(_DWORD *)(a1 + 260) == 3 )
        {
          v5 = (unsigned int)(a3 - 2);
          *(_DWORD *)(a1 + 736) = v5;
        }
        if ( (int)v5 <= 0 )
        {
          sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0xFFFFFFFC);
          result = -1LL;
          *(_DWORD *)(a1 + 704) = 0;
          return result;
        }
        v34 = *(unsigned int *)(a1 + 256);
        if ( (_DWORD)v34 )
        {
          v35 = *(_QWORD *)(a1 + 248);
          if ( v35 >= 0 && v35 > (int)v34 )
          {
            sub_166F020(
              *(_QWORD *)(*(_QWORD *)(a1 + 8) + 368LL),
              8LL,
              (__int64)"Chunked request body is larger than limit of %d",
              v34);
            sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0xFFFFFFFC);
            *(_BYTE *)(a1 + 766) |= 0x18u;
            result = -1LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
        }
        v32 = *(_QWORD *)(a1 + 240);
        if ( v32 )
        {
LABEL_50:
          if ( v32 == -1 )
          {
            v23 = *(unsigned int *)(a1 + 736);
            *(_QWORD *)(a1 + 712) = *(_QWORD *)(a1 + 728);
            while ( (int)v23 > 1 )//实际进行读取 chunk trailer
            {
              *(_DWORD *)(a1 + 704) = 4;
LABEL_21:
              if ( (int)sub_160B840(*(_QWORD *)(a1 + 744), v23, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 1LL) <= 0 )//ap_getline
              {
                if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) - 1 <= 4 )
                  return -1LL;
                break;
              }
              v24 = *(_DWORD *)(a1 + 736);//缓冲区剩余大小，第一次执行该循环时，已经减去3
              v25 = *(_QWORD *)(a1 + 712);//当前应该在缓冲区中写入/r/n的位置，当第一次执行该循环时，为3（0 \r \n 刚好3字节），以后循环每次加2（\r \n 刚好两字节）eg:3 5 7 9 11
              v26 = v24 - 1;
              if ( v25 != v26 )
              {
                v27 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v25 + 1;
                *(_BYTE *)(v27 + v25) = '\r';
                v28 = *(_QWORD *)(a1 + 712);
                v29 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v28 + 1;
                *(_BYTE *)(v29 + v28) = '\n';
                v26 = *(_QWORD *)(a1 + 712);
                v24 = *(_DWORD *)(a1 + 736);
              }
              v23 = (unsigned int)(v24 - v26);
              *(_QWORD *)(a1 + 728) += v26;
              *(_QWORD *)(a1 + 744) += v26;
              *(_DWORD *)(a1 + 736) = v23;
            }
            if ( *(__int64 *)(a1 + 712) >= 0 )
            {
              if ( *(_QWORD *)(a1 + 712) )
              {
                result = *(_QWORD *)(a1 + 728);
              }
              else
              {
                **(_BYTE **)(a1 + 744) = 13;
                *(_BYTE *)(*(_QWORD *)(a1 + 744) + 1LL) = 10;
                v31 = *(_QWORD *)(a1 + 728);
                *(_QWORD *)(a1 + 240) = -2LL;
                result = v31 + 2;
                *(_QWORD *)(a1 + 728) = result;
              }
              *(_QWORD *)(a1 + 248) += result;
              *(_DWORD *)(a1 + 704) = 0;
              return result;
            }
            goto LABEL_77;
          }
          if ( v32 == -2 )
          {
            *(_QWORD *)(a1 + 240) = 0LL;
            result = 0LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
          v33 = *(int *)(a1 + 736);
          if ( v33 > v32 )
            v33 = v32;
          *(_QWORD *)(a1 + 720) = v33;
LABEL_2:
          v6 = *(_QWORD *)(a1 + 8);
          v7 = *(_QWORD *)(a1 + 744);
          *(_DWORD *)(a1 + 704) = 5;
          v8 = (int)((__int64 (__fastcall *)(_QWORD, __int64))sub_160ACE0)(*(_QWORD *)(v6 + 40), v7);
          *(_QWORD *)(a1 + 712) = (int)v8;
          if ( (int)v8 <= 0 )
          {
LABEL_77:
            *(_BYTE *)(a1 + 766) |= 0x18u;
LABEL_78:
            *(_DWORD *)(a1 + 704) = 0;
            return -1LL;
          }
          v9 = *(_QWORD *)(a1 + 240) == (int)v8;
          *(_QWORD *)(a1 + 240) -= (int)v8;
          if ( !v9 )
          {
LABEL_10:
            *(_QWORD *)(a1 + 248) += *(_QWORD *)(a1 + 728) + v8;
            sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0);
            v14 = *(_QWORD *)(a1 + 712);
            *(_DWORD *)(a1 + 704) = 0;
            return *(_QWORD *)(a1 + 728) + v14;
          }
          *(_DWORD *)(a1 + 704) = 8;
LABEL_5:
          if ( (int)sub_160B860(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), &v39) > 0 )
          {
            v10 = v39;
            if ( v39 != '\r' )
              goto LABEL_7;
            *(_DWORD *)(a1 + 704) = 9;
LABEL_34:
            if ( (int)sub_160B860(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), &v39) > 0 )
              goto LABEL_35;
          }
          if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) - 1 > 4 )
          {
LABEL_35:
            v10 = v39;
LABEL_7:
            if ( v10 == '\n' )
            {
              v8 = *(_QWORD *)(a1 + 712);
              if ( *(_DWORD *)(a1 + 260) == 3 )
              {
                v11 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v8 + 1;
                *(_BYTE *)(v11 + v8) = '\r';
                v12 = *(_QWORD *)(a1 + 712);
                v13 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v12 + 1;
                *(_BYTE *)(v13 + v12) = '\n';
                v8 = *(_QWORD *)(a1 + 712);
              }
              goto LABEL_10;
            }
            goto LABEL_77;
          }
          return -1LL;
        }
        *(_DWORD *)(a1 + 704) = 2;
LABEL_12:
        v16 = sub_160B840(a2, v5, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0LL);//ap_getline:返回值为除去\r\n的字符个数
        v17 = v16;
        *(_QWORD *)(a1 + 728) = v16;
        if ( v16 <= 0 )
        {
          if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 1
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 2
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 3
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 4
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 5 )
          {
            *(_BYTE *)(a1 + 766) |= 0x18u;
            result = -1LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
          return -1LL;
        }
        if ( v16 < (__int64)(*(_DWORD *)(a1 + 736) - 1) )
        {
          v18 = __ctype_b_loc();
          v19 = *(unsigned __int8 **)(a1 + 744);
          if ( ((*v18)[*v19] & 0x1000) != 0 )
          {
            v20 = sub_16058A0(*(_QWORD *)(a1 + 744)); // 获取块大小
            *(_QWORD *)(a1 + 720) = v20;
            if ( !v20 )//0 字节的块表示结束，则触发读取 chunk trailer。
            {
              v21 = *(_DWORD *)(a1 + 260);
              if ( v21 == 2 )//v21此时等于3
              {
                *(_DWORD *)(a1 + 704) = 3;
LABEL_18:
                ((void (__fastcall *)(__int64, __int64))sub_1604200)(a1, v5);
                if ( !(unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) )
                {
                  snprintf(*(char **)(a1 + 744), *(int *)(a1 + 736), off_302915B, *(_QWORD *)(a1 + 248));
                  sub_15F2390(*(_QWORD *)(a1 + 280), "Transfer-Encoding");
                  v22 = (__int64)sub_15F1560(*(_QWORD *)a1, *(const char **)(a1 + 744));
                  sub_15F2280(*(_QWORD *)(a1 + 280), "Content-Length", v22);
                  result = 0LL;
                  *(_DWORD *)(a1 + 704) = 0;
                  return result;
                }
                if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 1
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 2
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 3
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 4
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 5 )
                {
                  return -1LL;
                }
                goto LABEL_78;
              }
              *(_QWORD *)(a1 + 240) = -1LL;
              goto LABEL_47;//goto：触发读取 chunk trailer。
            }
            if ( v20 >= 0 )
            {
              *(_QWORD *)(a1 + 240) = v20;
              v21 = *(_DWORD *)(a1 + 260);
LABEL_47:
              if ( v21 == 3 )
              {
                *(_QWORD *)(a1 + 728) = v17 + 1;
                v19[v17] = '\r';
                v36 = *(_QWORD *)(a1 + 728);
                v37 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 728) = v36 + 1;
                *(_BYTE *)(v37 + v36) = '\n';
                v38 = *(_QWORD *)(a1 + 728);
                *(_QWORD *)(a1 + 744) += v38;
                *(_DWORD *)(a1 + 736) -= v38;
              }
              else
              {
                *(_QWORD *)(a1 + 728) = 0LL;
              }
              v32 = *(_QWORD *)(a1 + 240);
              goto LABEL_50;//goto：触发读取 chunk trailer。
            }
            *(_BYTE *)(a1 + 766) |= 0x18u;
          }
        }
        sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 4294967293u);
        result = -1LL;
        *(_DWORD *)(a1 + 704) = 0;
        return result;
      }
      *(_DWORD *)(a1 + 704) = 1;
      a3 = (int)a3;
      if ( *(_QWORD *)(a1 + 240) <= (int)a3 )
        a3 = *(_QWORD *)(a1 + 240);
      *(_QWORD *)(a1 + 720) = a3;
LABEL_31:
      result = (int)((__int64 (__fastcall *)(_QWORD, __int64))sub_160ACE0)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), a2);
      *(_QWORD *)(a1 + 712) = (int)result;
      if ( (int)result > 0 )
      {
        *(_QWORD *)(a1 + 248) += (int)result;
        *(_QWORD *)(a1 + 240) -= (int)result;
        *(_DWORD *)(a1 + 704) = 0;
        return result;
      }
      if ( !(_DWORD)result )
        goto LABEL_44;
      if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 1
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 2
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 3
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 4 )
      {
        return *(_QWORD *)(a1 + 712);
      }
      v9 = (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 5;
      result = *(_QWORD *)(a1 + 712);
      if ( !v9 )
      {
LABEL_44:
        *(_BYTE *)(a1 + 766) |= 0x18u;
        *(_DWORD *)(a1 + 704) = 0;
      }
      return result;
  }
}
```



# 资料

Two Bytes is Plenty: FortiGate RCE with CVE-2024-21762

https://www.assetnote.io/resources/research/two-bytes-is-plenty-fortigate-rce-with-cve-2024-21762

Out-of-bound Write in sslvpnd

https://www.fortiguard.com/psirt/FG-IR-24-015