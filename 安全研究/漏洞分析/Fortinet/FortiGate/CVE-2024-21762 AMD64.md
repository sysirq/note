# 环境

FGT: 7.2.0

CPU: 1

# 前置知识

HTTP分块传输编码（Chunked Transfer Encoding）通常用于在客户端和服务器之间传输大数据量时，尤其是在服务器不能预先知道数据总大小的情况下，或数据是动态生成时。它属于HTTP/1.1及以上版本的一部分。

### 工作原理

在HTTP响应报文中，当启用分块传输编码时，数据会被分成多个“块”进行传输。每个块由以下几个部分组成：

分块格式：

- 块大小： 每个数据块前都有一个十六进制数字，表示该块的字节数（不包括这个大小字段本身）。
- 块数据：紧接着大小字段的是实际的块数据，按大小字段指定的字节数传输。
- 换行符： 每个块后面都会跟着一个换行符\r\n，分隔开各个块。

最后一个块：

当所有数据块传输完毕后，会有一个大小为0的块，表示传输结束。这个块后面通常会跟着一个空行（\r\n），表示响应结束。

chunk 编码格式如下：

```
[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]
```

eg:

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
in chunks\r\n
0\r\n
\r\n
```

解释：

- 4\r\nWiki\r\n：第一个块的大小是4个字节，数据是Wiki
- 5\r\npedia\r\n：第二个块的大小是5个字节，数据是pedia。
- E\r\nin chunks\r\n：第三个块的大小是14个字节，数据是in chunks。
- 0\r\n\r\n：最后一个块，大小为0，表示传输结束。

# poc

查看一下处理chunk的流程在哪里：

```
handle SIGPIPE nostop
b *0x0000000001713A9F 
commands
    printf "read handler name:%s\n",$rcx+208
    continue
end
```

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 1
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 20

HOST = "192.168.182.188"
PORT = 8443  

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

sk = create_ssl_socket()

sk.sendall(("POST / HTTP/1.1\r\n").encode())
sk.sendall(("Host: %s:%d\r\n"%(HOST,PORT)).encode())
sk.sendall(("Connection: keep-alive\r\n").encode())
sk.sendall(("Transfer-Encoding: chunked\r\n").encode())
sk.sendall("\r\n".encode())

sk.sendall("4\r\n".encode())
sk.sendall("Wiki\r\n".encode())
sk.sendall("0\r\n".encode())
sk.sendall("\r\n".encode())
```

```
Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ap_read_request

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:http_write_memory
```

分析发现处理chunk请求的函数为read_client_block

# 资料

Two Bytes is Plenty: FortiGate RCE with CVE-2024-21762

https://www.assetnote.io/resources/research/two-bytes-is-plenty-fortigate-rce-with-cve-2024-21762

Out-of-bound Write in sslvpnd

https://www.fortiguard.com/psirt/FG-IR-24-015