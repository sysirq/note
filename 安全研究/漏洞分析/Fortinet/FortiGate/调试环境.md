# 虚拟机下载

地址：https://support.fortinet.com/Download/VMImages.aspx

Select Platform 我们选择 KVM

解压FGT_VM:

```sh
unzip FGT_VM64_KVM-v7.6.0.F-build3401-FORTINET.out.kvm.zip
```

创建log 磁盘：

```sh
qemu-img create -f qcow2 data.qcow2 30G
```

生成uuid：

```
sysirq@sysirq-machine:~/Work/Fortinet/FortiGate$ cat /proc/sys/kernel/random/uuid
e2d8d9d7-a25d-44be-93b5-97ffb52a51b0
```

虚拟机启动命令：

```bash
#/bin/bash

qemu-system-x86_64              -machine pc-i440fx-2.8 \
                                --accel kvm \
                                -m 2G \
                                -netdev tap,id=nc0,ifname=tap4fun,script=no,downscript=no \
                                -device virtio-net,netdev=nc0,mac=E0:35:0E:EE:A0:C0 \
                                -blockdev driver=file,node-name=hdafile,filename=fortios.qcow2 \
                                -blockdev driver=qcow2,file=hdafile,node-name=hda   \
                                -device virtio-blk,drive=hda  \
                                -blockdev driver=file,node-name=hdbfile,filename=data.qcow2 \
                                -blockdev driver=qcow2,file=hdbfile,node-name=hdb   \
                                -device virtio-blk,drive=hdb  \
                                -uuid e2d8d9d7-a25d-44be-93b5-97ffb52a51b0 \
                                -vnc 10.4.21.2:0

```

**Select Network to configure or add more network interfaces. The Device type must be Virtio.**

默认用户名：admin ， 密码为空

首次登录会要求你设置登录密码（方便期间，我设置为1234）

# 帮组信息获取

输入? , 可以获取命令提示。

输入特定命令后，在输入？，获取特定命令的帮助，eg: execute ?

# 网络配置

获取网卡信息：

```
get hardware nic port1
```

CLI 配置网络：

### 配置静态IP地址

```
config system interface
edit port1
set mode static
set ip 192.168.182.188 255.255.255.0
set allowaccess ping http https ssh
end
```

查看interfaces:

```
show system interface port1
```

### 配置默认路由

```
config router static
edit 1
set gateway 192.168.182.1
set device port1
end
```

查看路由配置：

```
show router static
```

### 配置DNS服务器

```
config system dns
set primary 8.8.8.8
set secondary 8.8.4.4
end
```

查看DNS配置

```
show system dns
```

之后，可以通过：192.168.182.188 访问Web管理页面，也可以通过ssh对其进行管理。

# 虚拟机永久试用许可证

版本：7.6.0

新部署的FortiGate-VM不再具有有效的评估许可证，即使该实例只有1个CPU和2 GB内存。执行命令get sys stat，输出结果如下:

```
Version: FortiGate-VM64-KVM v7.6.0,build3401,240724 (GA.F)
...
Serial-Number: FGVMEVNXFLTGKOBC
License Status: Invalid
VM Resources: 1 CPU/1 allowed, 2007 MB RAM/2048 MB allowed
```

从FortiCare获取虚拟机永久试用license:

```
execute vm-license-options account-id xxxx@fortinet.com
execute vm-license-options account-password xxxxxxx
execute vm-license
This VM is using the evaluation license. This license does not expire.
Limitations of the Evaluation VM license include:
  1.Support for low encryption operation only
  2.Maximum of 1 CPU and 2GiB of memory
  3.Maximum of three interfaces, firewall policies, and routes each
  4.No FortiCare Support
This operation will reboot the system !
Do you want to continue? (y/n)y

Connection to 192.168.182.188 closed.
```

激活后，可以通过https://support.fortinet.com/asset/#/dashboard 进行管理

# 命令行

- 输入**tree**显示整个FortiOS CLI命令树
- tree execute
- 可以使用grep提取特定信息，eg 提取网卡驱动：get hardware nic port1 | grep Driver 



### 排错命令

- diagnose hardware sysinfo vm full : 显示激活状态以及UUID
- get sys stat :   显示整体状态
  



# VM 通过 FortiGate VM上网

网络配置：

```sh
ip link add br4fgt type bridge
ip tuntap add dev tap4fgt_in mode tap
ip tuntap add dev tap4fgt_out mode tap
ip link set tap4fgt_in master br4fgt
ip link set tap4fgt_out master br4fgt
ip link set br4fgt up
ip link set tap4fgt_in up
ip link set tap4fgt_out up
```

VM启动脚本：

```sh
#/bin/bash

nohup qemu-system-x86_64 --accel kvm \
                    -m 8G \
                    -smp 4 \
                    -blockdev driver=file,filename=hd.qcow2,node-name=myfile \
                    -blockdev driver=qcow2,file=myfile,node-name=hd \
                    -device virtio-blk,drive=hd \
                    -netdev tap,id=nc0,ifname=tap4fgt_out,script=no,downscript=no \
                    -device virtio-net,netdev=nc0,mac=40:35:2E:EE:A0:C0 \
                    -device virtio-vga \
                    -device virtio-mouse \
                    -device virtio-keyboard \
                    -usbdevice  tablet \
                    -vnc 10.4.21.2:4 > qemu.log 2>&1 &
```

FortiGate VM 启动命令:

```sh
#/bin/bash

nohup qemu-system-x86_64 		-machine pc-i440fx-2.8 \
				--accel kvm \
				-m 2G \
				-netdev tap,id=nc0,ifname=tap4fun,script=no,downscript=no \
				-device virtio-net,netdev=nc0,mac=E0:35:0E:EE:A0:C0 \
				-netdev tap,id=nc1,ifname=tap4fgt_in,script=no,downscript=no \
				-device virtio-net,netdev=nc1,mac=E0:32:0E:EE:A0:C0 \
				-blockdev driver=file,node-name=hdafile,filename=fortios.qcow2 \
				-blockdev driver=qcow2,file=hdafile,node-name=hda   \
				-device virtio-blk,drive=hda  \
				-blockdev driver=file,node-name=hdbfile,filename=data.qcow2 \
				-blockdev driver=qcow2,file=hdbfile,node-name=hdb   \
				-device virtio-blk,drive=hdb  \
				-uuid e2d8d9d7-a25d-44be-93b5-97ffb52a51b0 \
				-vnc 10.4.21.2:0 > qemu.log 2>&1 &
```



FortiGate 配置，参考资料中的：虚拟 PC 通过 FortiGate VM 上网



# 挂载QCOW2文件

FGT KVM版本：7.6.0

```
sudo modprobe nbd max_part=8
sudo qemu-nbd --connect=/dev/nbd0 path_to_your.qcow2
sudo fdisk -l /dev/nbd0
sudo mount -o ro /dev/nbd0p1 /mnt/

sudo umount /mnt
sudo qemu-nbd --disconnect /dev/nbd0
```

# 内核解压

下载 vmlinux-to-elf ( https://github.com/marin-m/vmlinux-to-elf )，

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ file flatkc
flatkc: Linux kernel x86 boot executable bzImage, version 4.19.13 (root@build) #1 SMP Wed Jul 24 17:24:03 UTC 2024, RO-rootFS, swap_dev 0X7, Normal VGA
```

```
vmlinux-to-elf flatkc flatkc.elf
```

# rootfs解压

查看extlinux.conf

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ cat extlinux.conf
DISPLAY boot.msg
TIMEOUT 10
TOTALTIMEOUT 9000
DEFAULT flatkc ro panic=5 endbase=0xA0000 console=ttyS0, root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz
```

可以看到rootfs.gz作为initrd临时根文件系统。在内核中的对其进行处理的函数为：/init/initramfs.c:populate_rootfs函数

populate_rootfs 函数是 Linux 内核启动过程中的一个关键函数，用于设置和填充初始的根文件系统。它主要负责处理 initramfs 和 initrd，并确保它们被正确地挂载和初始化。

```c
rootfs_initcall(populate_rootfs);

#define rootfs_initcall(fn)		__define_initcall(fn, rootfs)

#define __define_initcall(fn, id) \
	static initcall_t __initcall_##fn##id __used \
	__attribute__((__section__(".initcall" #id ".init"))) = fn;
```

/include/asm-generic/vmlinux.lds.h：

```c
#define INIT_CALLS							\
		VMLINUX_SYMBOL(__initcall_start) = .;			\
		KEEP(*(.initcallearly.init))				\
		INIT_CALLS_LEVEL(0)					\
		INIT_CALLS_LEVEL(1)					\
		INIT_CALLS_LEVEL(2)					\
		INIT_CALLS_LEVEL(3)					\
		INIT_CALLS_LEVEL(4)					\
		INIT_CALLS_LEVEL(5)					\
		INIT_CALLS_LEVEL(rootfs)				\
		INIT_CALLS_LEVEL(6)					\
		INIT_CALLS_LEVEL(7)					\
		VMLINUX_SYMBOL(__initcall_end) = .;
```

populate_rootfs的调用流程为: start_kernel --> rest_init--> kernel_init --> kernel_init_freeable --> do_basic_setup --> do_initcalls  --> populate_rootfs

通过逆向分析，发现调用do_initcalls的地方：

![image-20240801095905438](images/image-20240801095905438.png)

通过IDC脚本：

```c
static main(){
    auto j;
    auto k;
    auto initcall_start = 0xFFFFFFFF81796060;
    auto initcall_end   = 0xFFFFFFFF81796068;
    auto initcall_addr;
    auto offset32;
    auto offset64;
    
    for(j = 0;j!=8;j++){
        for(k=qword(initcall_start+j*8);k<qword(initcall_end+j*8);k=k+4){
            offset32 = dword(k);
            if(offset32 & 0x80000000){
                offset64 = offset32 | 0xFFFFFFFF00000000;
            }else{
                offset64 = offset32 & 0xFFFFFFFF;
            }
            initcall_addr = k + offset64;
            msg("initcall_addr:%lx func_name:%s\n",initcall_addr,get_func_name(initcall_addr));
        }
    }
    
    msg("miaomiaomiao\n");
}
```

以及populate_rootfs函数引用的字符串

```
.rodata:FFFFFFFF813D38D9	00000030	C	6Trying to unpack rootfs image as initramfs...\n
```

我们可以定位populate_rootfs的函数为：

```
initcall_addr:ffffffff8170c2b0 func_name:sub_FFFFFFFF8170C2B0（通过后面的分析，我们发现这玩意会对initrd做解密操作，然后才给populate_rootfs（比populate_rootfs先执行））
initcall_addr:ffffffff8170d56b func_name:sub_FFFFFFFF8170D56B(这个是真正的populate_rootfs)
```

发现，fortigate将此函数的符号去掉了的。。。。。

我们也可以自己编译一个这个版本的内核，通过IDC脚本对比，找到被去掉符号的populate_rootfs函数。

通过对比源代码以及，我们可以恢复一些符号：

![image-20240801101659861](images/image-20240801101659861.png)

initrd  decompress_method 获取：populate_rootfs --> unpack_to_rootfs --> decompress_method((char*)initrd_start,initrd_end - initrd_start,&compress_name)

![image-20240801102414680](images/image-20240801102414680.png)

```c
/lib/decompress.c

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

static const struct compress_format compressed_formats[] __initconst = {
	{ {0x1f, 0x8b}, "gzip", gunzip },
	{ {0x1f, 0x9e}, "gzip", gunzip },
	{ {0x42, 0x5a}, "bzip2", bunzip2 },
	{ {0x5d, 0x00}, "lzma", unlzma },
	{ {0xfd, 0x37}, "xz", unxz },
	{ {0x89, 0x4c}, "lzo", unlzo },
	{ {0x02, 0x21}, "lz4", unlz4 },
	{ {0, 0}, NULL, NULL }
};

decompress_fn __init decompress_method(const unsigned char *inbuf, long len,
				const char **name)
{
	const struct compress_format *cf;

	if (len < 2) {
		if (name)
			*name = NULL;
		return NULL;	/* Need at least this much... */
	}

	pr_debug("Compressed data magic: %#.2x %#.2x\n", inbuf[0], inbuf[1]);

	for (cf = compressed_formats; cf->name; cf++) {
		if (!memcmp(inbuf, cf->magic, 2))
			break;

	}
	if (name)
		*name = cf->name;
	return cf->decompressor;
}
```

通过分析，发现是对比initrd的前两个字节来定位decompress method。

通过IDC脚本，解析该结构：

```c
static main(){
    auto compressed_formats_addr = 0xFFFFFFFF817DC2A0;
    auto magic;
    auto name;
    auto decompressor;
    auto i;
    auto ch;
    while(1){
        magic = compressed_formats_addr;
        name = qword(compressed_formats_addr+8);
        decompressor = qword(compressed_formats_addr+16);
        if(name == 0) break;
        
        msg("magic:0x%.2x 0x%.2x\n",byte(magic),byte(magic+1));
        
        msg("name:");
        i = 0;
        ch = byte(name+i);
        while(ch != 0){
            msg("%c",ch);
            i = i+1;
            ch = byte(name+i);
        }
        msg("\n");
        
        msg("func addr: 0x%lx , func name:%s\n",decompressor,get_func_name(decompressor));

        compressed_formats_addr = compressed_formats_addr + 3*8;
    }
    msg("miaomiaomiao\n");
}
```

output:

```
magic:0x1f 0x8b
name:gzip
func addr: 0xffffffff817528bc , func name:gunzip
magic:0x1f 0x9e
name:gzip
func addr: 0xffffffff817528bc , func name:gunzip
magic:0x42 0x5a
name:bzip2
func addr: 0x0 , func name:
magic:0x5d 0x00
name:lzma
func addr: 0x0 , func name:
magic:0xfd 0x37
name:xz
func addr: 0x0 , func name:
magic:0x89 0x4c
name:lzo
func addr: 0x0 , func name:
magic:0x02 0x21
name:lz4
func addr: 0x0 , func name:
miaomiaomiao
```

查看rootfs.gz的开头两个字节:

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ hexdump -n 2 rootfs.gz
0000000 cb36                                   
0000002
```

发现不对劲，fortigate应该先对rootfs.gz做了解密然后再丢给populate_rootfs函数处理。并不是直接在populate_rootfs函数中完成骚操作。

对initrd_start做交叉引用：发现了sub_FFFFFFFF8170C2B0函数。通过那个提取initcall的idc脚本，我们发现他先于populate_rootfs执行，猜测是这里对initrd进行了一遍处理，我们将该函数命名为fgt_decompress。

```c
__int64 fgt_decompress()
{
  int v0; // ebx
  unsigned int v1; // r12d
  __int64 *v2; // rdi
  __int64 i; // rcx
  __int64 v4; // rcx
  __int64 *v5; // rdi
  __int64 v6; // r14
  __int64 *v7; // rdi
  __int64 v8; // rcx
  char *v9; // rsi
  __int64 v10; // r15
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v14; // rax
  __int64 v15; // r9
  int buffer; // eax
  int v17; // r12d
  int v18; // eax
  _BYTE *v19; // rcx
  _DWORD *v20; // rsi
  __int64 v21; // rcx
  char *v22; // rdi
  __int64 v23; // rdx
  __int64 j; // rax
  __int64 v25; // r14
  unsigned int v26; // ebx
  char *v27; // rdx
  unsigned __int8 v28; // al
  unsigned int v29; // r15d
  __int64 v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v34; // [rsp+8h] [rbp-3B0h]
  __int64 v35; // [rsp+8h] [rbp-3B0h]
  __int64 v36; // [rsp+10h] [rbp-3A8h]
  int v37; // [rsp+10h] [rbp-3A8h]
  __int64 v38; // [rsp+18h] [rbp-3A0h] BYREF
  __int64 raw_data; // [rsp+20h] [rbp-398h]
  __int64 v40; // [rsp+28h] [rbp-390h]
  __int64 v41; // [rsp+30h] [rbp-388h]
  __int64 v42; // [rsp+38h] [rbp-380h]
  __int64 v43[16]; // [rsp+40h] [rbp-378h] BYREF
  __int64 v44; // [rsp+C0h] [rbp-2F8h] BYREF
  __int64 v45; // [rsp+C8h] [rbp-2F0h]
  char v46[104]; // [rsp+E8h] [rbp-2D0h] BYREF
  char v47[488]; // [rsp+150h] [rbp-268h] BYREF
  __int64 v48; // [rsp+338h] [rbp-80h] BYREF
  __int64 v49; // [rsp+340h] [rbp-78h]
  char v50[32]; // [rsp+348h] [rbp-70h] BYREF
  char v51[32]; // [rsp+368h] [rbp-50h] BYREF
  unsigned __int64 v52; // [rsp+388h] [rbp-30h]

  v52 = __readgsqword(0x28u);
  v0 = initrd_end - initrd_start;
  v1 = -1;
  if ( (unsigned __int64)(initrd_end - initrd_start) <= 0x100 )
    goto LABEL_35;
  v2 = v43;
  for ( i = 32LL; i; --i )
  {
    *(_DWORD *)v2 = 0;
    v2 = (__int64 *)((char *)v2 + 4);
  }
  v4 = 10LL;
  v5 = &v38;
  while ( v4 )
  {
    *(_DWORD *)v5 = 0;
    v5 = (__int64 *)((char *)v5 + 4);
    --v4;
  }
  v6 = kmem_cache_alloc(qword_FFFFFFFF814A07A8, 0x6000C0LL);
  if ( !v6 )
    goto LABEL_35;
  sha256_init(v47);
  sha256_update_0(v47, &unk_FFFFFFFF817972C6, 26LL);
  sha256_update_0(v47, &unk_FFFFFFFF817972C0, 6LL);
  sha256_final_0(v47, v50);
  sha256_init(v47);
  sha256_update_0(v47, &unk_FFFFFFFF817972C3, 29LL);
  sha256_update_0(v47, &unk_FFFFFFFF817972C0, 3LL);
  sha256_final_0(v47, v51);
  v7 = &v44;
  v8 = 8LL;
  v9 = v50;
  while ( v8 )
  {
    *(_DWORD *)v7 = *(_DWORD *)v9;
    v9 += 4;
    v7 = (__int64 *)((char *)v7 + 4);
    --v8;
  }
  crypto_chacha20_init(v46, &v44, v51);
  chacha20_docrypt(v46, v6, &unk_FFFFFFFF817971A0, 270LL);
  if ( (unsigned int)rsa_parse_pub_key(v43, v6, 270LL)
    || (raw_data = mpi_read_raw_data(v43[1], v43[9])) == 0
    || (v38 = mpi_read_raw_data(v43[0], v43[8])) == 0
    || (v40 = kmem_cache_alloc(qword_FFFFFFFF814A07C0, 6291648LL)) == 0
    || (v42 = kmem_cache_alloc(qword_FFFFFFFF814A0788, 6291648LL)) == 0 )
  {
    kfree(v6);
    mpi_free(raw_data);
    mpi_free(v38);
    kfree(v40);
    kfree(v42);
    v1 = -1;
LABEL_35:
    machine_halt();
    goto LABEL_36;
  }
  kfree(v6);
  sha256_init(v46);
  sha256_update_0(v46, initrd_start, (unsigned int)(v0 - 256));
  sha256_final_0(v46, v42);
  v10 = initrd_end;
  v11 = initrd_end - 256;
  v41 = initrd_end - 256;
  v36 = v42;
  v12 = mpi_read_raw_data(initrd_end - 256, 256LL);
  v13 = v12;
  v1 = -12;
  if ( v12 )
  {
    if ( (int)mpi_cmp_ui(v12, 0LL) < 0 || (int)mpi_cmp(v13, v38) >= 0 )
    {
      v1 = -22;
    }
    else
    {
      v14 = mpi_alloc(0LL);
      v1 = -12;
      if ( v14 )
      {
        v34 = v14;
        v1 = mpi_powm(v14, v13, raw_data, v38);
        v15 = v34;
        if ( !v1 )
        {
          buffer = mpi_read_buffer(v34, v41, 256LL, v43, 0LL);
          v17 = v43[0];
          LOBYTE(v17) = ~LOBYTE(v43[0]);
          v18 = *(_BYTE *)(v10 - 256) ^ 1 | v17 | buffer;
          v19 = (_BYTE *)(v10 - 255);
          v15 = v34;
          do
            v18 |= (unsigned __int8)~*v19++;
          while ( (_BYTE *)(v10 - 82) != v19 );
          v1 = v18 | *(unsigned __int8 *)(v11 + 174);
          v20 = (_DWORD *)(v11 + 223);
          v21 = 8LL;
          v22 = v51;
          while ( v21 )
          {
            *(_DWORD *)v22 = *v20++;
            v22 += 4;
            --v21;
          }
          v23 = *(_QWORD *)(v11 + 215);
          v48 = *(_QWORD *)(v11 + 207);
          v49 = v23;
          for ( j = 0LL; j != 32; ++j )
            v1 |= (unsigned __int8)(*(_BYTE *)(v36 + j) ^ *(_BYTE *)(v10 + j - 81));
        }
        mpi_free(v15);
      }
    }
    mpi_free(v13);
  }
  mpi_free(raw_data);
  mpi_free(v38);
  kfree(v40);
  kfree(v42);
  if ( v1 )
    goto LABEL_35;
LABEL_36:
  initrd_end -= 256LL;
  v25 = initrd_start;
  v26 = initrd_end - initrd_start;
  v37 = ((_BYTE)initrd_end - (_BYTE)initrd_start) & 0xF;
  crypto_aes_expand_key(v47, v51, 32LL);
  v27 = (char *)&v48;
  v28 = 0;
  do
  {
    v28 ^= *v27 & 0xF ^ ((unsigned __int8)*v27 >> 4);
    ++v27;
  }
  while ( v50 != v27 );
  if ( !v28 )
    v28 = 1;
  v44 = v48;
  v45 = v49;
  v29 = 0;
  v30 = v28;
  do
  {
    v35 = v30;
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v31 = 0LL;
    v30 = v35;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v31) ^= v50[v31];
      ++v31;
    }
    while ( v31 != 16 );
    v45 += v35;
    v29 += 16;
  }
  while ( v26 >= v29 );
  if ( v37 )
  {
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v32 = 0LL;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v32) ^= v50[v32];
      ++v32;
    }
    while ( v37 != (_DWORD)v32 );
  }
  return v1;
}
```

一些内核函数原型：

```c
extern int sha256_init(struct sha256_state *sctx);
extern int sha256_update(struct sha256_state *sctx, const u8 *input,unsigned int length);
extern int sha256_final(struct sha256_state *sctx, u8 *hash);
void crypto_chacha20_init(u32 *state, struct chacha20_ctx *ctx, u8 *iv);
static void chacha20_docrypt(u32 *state, u8 *dst, const u8 *src,unsigned int bytes);
int rsa_parse_pub_key(struct rsa_key *rsa_key, const void *key,unsigned int key_len);
void crypto_aes_encrypt_x86(struct crypto_aes_ctx *ctx, u8 *dst,const u8 *src);
int crypto_aes_expand_key(struct crypto_aes_ctx *ctx, const u8 *in_key,unsigned int key_len);
```

通过分析fgt_decompress函数，我们可以通过 IDA Python脚本 获取公钥信息:

```python
import hashlib
import os
import idc
import idaapi
import idautils
from Crypto.Cipher import ChaCha20
from Crypto.PublicKey import RSA
from Crypto.Util.asn1 import DerSequence

# 读取BER编码的RSA公钥
def read_rsa_public_key(public_key_der):        
    # 解析DER编码的公钥
    public_key = RSA.import_key(public_key_der)
    
    # 打印公钥信息
    print("Public Key:")
    print(public_key.export_key().decode())

#获取key
"""
  sha256_init(v47);
  sha256_update_0(v47, &unk_FFFFFFFF817972C6, 26LL);
  sha256_update_0(v47, &unk_FFFFFFFF817972C0, 6LL);
  sha256_final_0(v47, v50);
"""
data1 = idaapi.get_bytes(0xFFFFFFFF817972C6, 26)
data2 = idaapi.get_bytes(0xFFFFFFFF817972C0, 6)
data = data1+data2
key = hashlib.sha256(data).digest()
print("key:",key.hex())

#获取iv
"""
  sha256_update_0(v47, &unk_FFFFFFFF817972C3, 29LL);
  sha256_update_0(v47, &unk_FFFFFFFF817972C0, 3LL);
  sha256_final_0(v47, v51);
"""
data1 = idaapi.get_bytes(0xFFFFFFFF817972C3, 29)
data2 = idaapi.get_bytes(0xFFFFFFFF817972C0, 3)
data = data1+data2
iv = hashlib.sha256(data).digest()[:16]

print("iv :",iv.hex())

#解密公钥
"""
  crypto_chacha20_init(v46, &v44, v51);
  chacha20_docrypt(v46, v6, &unk_FFFFFFFF817971A0, 270LL);
"""
chacha=ChaCha20.new(key=key, nonce=iv[4:])
counter=int.from_bytes(iv[:4],'little')
chacha.seek(counter*64)

rsa_pub_key_ber = idaapi.get_bytes(0xFFFFFFFF817971A0, 270)
rsa_pub_key_ber = chacha.decrypt(rsa_pub_key_ber)

print(rsa_pub_key_ber.hex())
read_rsa_public_key(rsa_pub_key_ber)
```

Output:

```
key: 9e54c0ef7f7cd1f19fffa880a38c71f28d9c805c753dbcab9dd18dd1dda91077
iv : ef8c8f0c2a81343b9118e50ea6430520
3082010a0282010100b7307a76d36d3105cce385ca1feb8ff7d4e02cfb1eefa09b1ba21dfed14c65376d875a34cde3f3e138019fa116f4fc0f11a0ace51e6ef5882f02fd04bb7909d02af690108d2d9bfdaafd1a1f704d800ff31775e369d03b73dc0d56c557e5ffc559b5c20bc3250db434c0b62ea4bdb069c2ee5be0d4d0d19a58567c0473873e8110a2afad50aac224867482f4a1b06bca1b2fbc335b065879a3456f0638b3e5ac1371582fbf2a4e557f0d3801581cbc4dd052fb6fa142b908728572a2ad365724fe1f4100042c6b33d47c03996376c4658c4b3a59494b62cca4ae3ae988f6bbc3b3dc1e3ec6aae8f5f069b2ba6c194948c82e8c3ab462c84275337f403d7d03730203010001
Public Key:
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtzB6dtNtMQXM44XKH+uP
99TgLPse76CbG6Id/tFMZTdth1o0zePz4TgBn6EW9PwPEaCs5R5u9YgvAv0Eu3kJ
0Cr2kBCNLZv9qv0aH3BNgA/zF3XjadA7c9wNVsVX5f/FWbXCC8MlDbQ0wLYupL2w
acLuW+DU0NGaWFZ8BHOHPoEQoq+tUKrCJIZ0gvShsGvKGy+8M1sGWHmjRW8GOLPl
rBNxWC+/Kk5Vfw04AVgcvE3QUvtvoUK5CHKFcqKtNlck/h9BAAQsazPUfAOZY3bE
ZYxLOllJS2LMpK466Yj2u8Oz3B4+xqro9fBpsrpsGUlIyC6MOrRiyEJ1M39APX0D
cwIDAQAB
-----END PUBLIC KEY-----
```

继续分析fgt_decompress函数，我们可以发现其会对initrd的sha256做校验。

首先计算 initrd_start 到 initrd_end - 256 的 sha256，然后用公钥匙对initrd的最后256字节解密，得到实际的sha256，在对比，判断是否相等。

用公钥对最后initrd最后的256字节解密后，会得到256字节的解密数据，其中：

- [175:172+32] 是 实际的sha256值

- [223:] 是 aes key

- [207:207 + 16] 是用于解密initrd的数据

initrd的解密代码为：

```python
#!/usr/bin/python3
import hashlib
import os
import rsa
import sys
import binascii
import hashlib
import struct
from rsa import transform, core
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad, unpad

pem_public_key ="""-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtzB6dtNtMQXM44XKH+uP
99TgLPse76CbG6Id/tFMZTdth1o0zePz4TgBn6EW9PwPEaCs5R5u9YgvAv0Eu3kJ
0Cr2kBCNLZv9qv0aH3BNgA/zF3XjadA7c9wNVsVX5f/FWbXCC8MlDbQ0wLYupL2w
acLuW+DU0NGaWFZ8BHOHPoEQoq+tUKrCJIZ0gvShsGvKGy+8M1sGWHmjRW8GOLPl
rBNxWC+/Kk5Vfw04AVgcvE3QUvtvoUK5CHKFcqKtNlck/h9BAAQsazPUfAOZY3bE
ZYxLOllJS2LMpK466Yj2u8Oz3B4+xqro9fBpsrpsGUlIyC6MOrRiyEJ1M39APX0D
cwIDAQAB
-----END PUBLIC KEY-----"""

def aes_ecb_encrypt(enc,key):
    cipher = AES.new( key, AES.MODE_ECB)
    encrypted_text = cipher.encrypt(enc)
    return encrypted_text
def rsa_decrypt(encrypt_text):
    key = rsa.PublicKey.load_pkcs1_openssl_pem(pem_public_key)

    d = key.e
    n = key.n
    encrypt_text = binascii.a2b_hex(encrypt_text)
    num = transform.bytes2int(encrypt_text)
    decrypto = core.decrypt_int(num, d, n)
    out = transform.int2bytes(decrypto)
    return out

initrd_name="rootfs.gz"
output_initrd_name="rootfs.gz.out"

file_size = os.path.getsize(initrd_name)
file_content = open(initrd_name,'rb').read(file_size - 256)

print("file total size:",file_size)
print("start offset:",0)
print("end   offset:",file_size - 256)

#sha256 of initrd_start ----- initrd_end - 256
sha256 = hashlib.sha256()
sha256.update(file_content)
checksum = sha256.digest()
print("calc sha256:",checksum.hex())

#real sha256 from RSA pub key decrypt
file = open(initrd_name,'rb')
file.seek(-256,2)
file_content = file.read(256)
rsa_decrypt_out = rsa_decrypt(file_content.hex())
print("real sha256:",rsa_decrypt_out[175:175+32].hex())

#aes key and data
aes_key = rsa_decrypt_out[223:]
aes_data=rsa_decrypt_out[207:207+16]

print("ase key len:",len(aes_key))
print("aes key:",aes_key.hex())
print("ase data len:",len(aes_data))
print("ase data:",aes_data.hex())

#use aes data calc addend
"""
  v28 = 0;
  do
  {
    v28 ^= *v27 & 0xF ^ ((unsigned __int8)*v27 >> 4);
    ++v27;
  }
  while ( v50 != v27 );
  if ( !v28 )
    v28 = 1;
"""
addend = 0
for b in aes_data:
    addend ^= (b&0xF)^(b>>4)
if addend == 0:
    addend = 1

print("addend: ",addend)

# decrypt initrd
"""
  do
  {
    v35 = v30;
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v31 = 0LL;
    v30 = v35;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v31) ^= v50[v31];
      ++v31;
    }
    while ( v31 != 16 );
    v45 += v35;
    v29 += 16;
  }
  while ( v26 >= v29 );
  if ( v37 )
  {
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v32 = 0LL;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v32) ^= v50[v32];
      ++v32;
    }
    while ( v37 != (_DWORD)v32 );
  }
"""
initrd_file_total_size = os.path.getsize(initrd_name)
initrd_file_total_size -= 256
initrd_file_content = open(initrd_name,'rb').read(initrd_file_total_size)
initrd_file_content = bytearray(initrd_file_content)
initrd_file_offset = 0
remain_bytes_count = initrd_file_total_size & 0xF

while initrd_file_offset < (initrd_file_total_size&(~0xF)):
    aes_encrypt_data = aes_ecb_encrypt(aes_data,aes_key)
    for i in range(16):
        initrd_file_content[initrd_file_offset + i] ^= aes_encrypt_data[i]
    initrd_file_offset += 16
    
    qword_bytes = aes_data[8:16]
    qword_value = struct.unpack('<Q', qword_bytes)[0]
    qword_value += addend
    new_qword_bytes = struct.pack('<Q', qword_value)
    aes_data = aes_data[:8] + new_qword_bytes

if remain_bytes_count != 0:
    aes_encrypt_data = aes_ecb_encrypt(aes_data,aes_key)
    for i in range(remain_bytes_count):
        initrd_file_content[initrd_file_offset + i] ^= aes_encrypt_data[i]
        
initrd_file_content = bytes(initrd_file_content)

open(output_initrd_name,'wb').write(initrd_file_content)
```

output:

```
file total size: 76294509
start offset: 0
end   offset: 76294253
calc sha256: e5e7b84f59d6014cdeadfd7b5edd79609a58d8df52347e4a85ed401f6b26012f
real sha256: e5e7b84f59d6014cdeadfd7b5edd79609a58d8df52347e4a85ed401f6b26012f
ase key len: 32
aes key: b36294c5330a159d5e90a12f590549f249be690f3294ba54a0bd9ec896bfc4ca
ase data len: 16
ase data: 310e91cb89ce4e14d7bb9bf0ee547f6f
addend:  8

```

会在工作目录生成解密后的initrd，名称为：rootfs.gz.out

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ file rootfs.gz.out 
rootfs.gz.out: gzip compressed data, last modified: Wed Jul 24 17:50:45 2024, from Unix, original size modulo 2^32 127456996
```

移动rootfs.gz.out到另外一个目录，完成解压：

```
cp ../rootfs.gz.out .
mv rootfs.gz.out rootfs.gz
gzip -d rootfs.gz
cpio -id < rootfs
```

# /sbin/init 分析

会解压 bin.tar.xz  migadmin.tar.xz node-scripts.tar.xz usr.tar.xz 这四个文件，然后再去执行/bin/init

# /bin/init 分析


通过rootfs我们发现，基本上所有的命令都指向了/bin/init 

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data/rootfs/bin$ ls -hl
total 119M
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 acd -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 acs-sdn-change -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 acs-sdn-status -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 acs-sdn-update -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 alarmd -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 alertmail -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 authd -> /bin/init
lrwxrwxrwx 1 sysirq sysirq    9 Jul 24 08:00 autod -> /bin/init
```

```
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data/rootfs/bin$ ls -hla init
-r-xr--r-- 1 sysirq sysirq 78M Jul 24 08:00 init
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data/rootfs/bin$ file init
init: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /fortidev/lib64/ld-linux-x86-64.so.2, BuildID[sha1]=ac5b1a0493c51f0a8cf57b8c54cdcd491375610a, for GNU/Linux 3.2.0, stripped
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data/rootfs/bin$ ldd init
```

# 完整性检查

### init中的完整性检查

##### 分析发现存在完整性检查1：

```c
__int64 __fastcall sub_2FEC80(__int64 a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // r8d
  int v6; // r9d
  __pid_t v7; // r12d
  int v9; // eax

  v2 = fork();
  if ( v2 < 0 )
  {
    print((__int64)"fork() failed\n");
    return 0LL;
  }
  else
  {
    if ( !v2 )
    {
      v9 = sub_2E77E30(1, a2);
      exit(v9);
    }
    v7 = sub_2FD650(v2);
    if ( v7 <= 0 )
      message((unsigned int)"System file integrity init check failed!\n", a2, v3, v4, v5, v6);
    return (unsigned int)v7;
  }
}
```

sub_2FEC80 --> sub_2E77E30-->sub_2E77D70

```
__int64 __fastcall sub_2E77D70(unsigned int a1)
{
  int v1; // r12d

  v1 = sub_2E77CA0();
  if ( v1 >= 0 && (int)sub_2E77BC0("/data/.db", a1) <= 0 )
    return (unsigned int)-1;
  return (unsigned int)v1;
}
```

此函数会读取/data/.db 与 /data/.db.x , 会用/data/.db.x验证/data/.db 的完整性

```json
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ cat .db
{
"version": 1,
"files": [
{
"path": "/flatkc",
"time": "/2024-07-24 17:50:52.528863685 +0000",
"size": 7446624,
"digests": [
{
"algorithm": "SHA512",
"digest": "0904abc4f1fe1e654c3821a1abc2640b183d142ea55406d88960ae9e7465a2cb377c4ee8c062bef4d5fa071f7d543e016439e8ee1f86a28161510067cda3cdfd"
}
]
},
{
"path": "/rootfs.gz",
"time": "/2024-07-24 17:50:53.356884054 +0000",
"size": 76294509,
"digests": [
{
"algorithm": "SHA512",
"digest": "013fc19536bb7ce89909d69d5641bbc7798868fd6e9ab66e692d21af6f052a27f6814a43e7c4d14d365f20755310c34dafc0165978caf5f403dedabd284be51d"
}
]
},
{
"path": "/datafs.tar.gz",
"time": "/2024-07-24 17:50:52.248856797 +0000",
"size": 17643908,
"digests": [
{
"algorithm": "SHA512",
"digest": "63e02ba05a4585a0f2bf64e5b5ba7984c1fc18ebafa3eb93ab1c78db2f6a131c220aa0fd31a956a49836580f16cc1c347e9ff6ac320caa48fc3d13e908ddbfec"
}
]
},
{
"path": "/hash_bin.sha256",
"time": "/2024-07-24 17:50:53.584889663 +0000",
"size": 20886,
"digests": [
{
"algorithm": "SHA512",
"digest": "b4f48f4823812f86bb4d82969362d6faec328d8f265f51f26a74e26689c5b25afa85d2e4ac3312267152cc2bf001bef78e7f5dd4d96b057d4f3784903825352d"
}
]
}
]
}

```

```sh
sysirq@sysirq-machine:~/Work/Fortinet/Tmp/data$ openssl cms -in .db.x -inform DER -noout -cmsout -print
CMS_ContentInfo: 
  contentType: pkcs7-signedData (1.2.840.113549.1.7.2)
  d.signedData: 
    version: 1
    digestAlgorithms:
        algorithm: sha512 (2.16.840.1.101.3.4.2.3)
        parameter: <ABSENT>
    encapContentInfo: 
      eContentType: pkcs7-data (1.2.840.113549.1.7.1)
      eContent: <ABSENT>
    certificates:
      d.certificate: 
        cert_info: 
          version: 2
          serialNumber: 8194
          signature: 
            algorithm: sha256WithRSAEncryption (1.2.840.113549.1.1.11)
            parameter: NULL
          issuer: C=US, ST=California, L=Sunnyvale, O=Fortinet, OU=Certificate Authority, CN=fortinet-ca2/emailAddress=support@fortinet.com
          validity: 
            notBefore: Feb  4 18:51:49 2022 GMT
            notAfter: May 26 00:00:00 2056 GMT
          subject: C=US, ST=California, L=Sunnyvale, O=Fortinet, OU=Certificate Authority, CN=fortinet-subca2002
          key:           X509_PUBKEY: 
            algor: 
              algorithm: rsaEncryption (1.2.840.113549.1.1.1)
............................................................................................................
```

验证/data/.db 时，使用到的证书：

```
rootfs/lib/cert/DigicertCA.ca
rootfs/lib/cert/cacert2.pem 
rootfs/lib/cert/DigicertTSA.ca
```

然后用/data/.db 对指定的文件进行签名检查

##### 分析发现存在完整性检查2：

```c
__pid_t sub_2FEBC0()
{
  int v0; // eax
  __int64 v1; // rax
  int v3; // eax

  v0 = fork();
  if ( v0 < 0 )
  {
    print((__int64)"fork() failed\n");
    return 0;
  }
  else
  {
    if ( !v0 )
    {
      v1 = sub_2D0EC90("Firmware integrity");
      if ( !v1 )
        exit(0);
      v3 = (*(__int64 (__fastcall **)(_QWORD))(v1 + 16))(0LL);
      exit(v3 == 0);
    }
    return sub_2FD650(v0);
  }
}
```

```asm
.data:0000000004D1E7A0                 dq offset aFirmwareIntegr ; "Firmware integrity"
.data:0000000004D1E7A8                 dq 1
.data:0000000004D1E7B0                 dq offset sub_2D097A0
```

```c
BOOL8 __fastcall sub_2D097A0(unsigned int a1)
{
  __int64 v1; // rax
  __int64 v2; // r12
  char *v4; // [rsp+8h] [rbp-138h] BYREF
  char v5[268]; // [rsp+10h] [rbp-130h] BYREF
  __int16 v6; // [rsp+11Ch] [rbp-24h]
  char v7; // [rsp+11Eh] [rbp-22h]
  unsigned __int64 v8; // [rsp+128h] [rbp-18h]

  v8 = __readfsqword(0x28u);
  qmemcpy(v5, &unk_3D14AD0, sizeof(v5));
  v6 = 256;
  v7 = 0;
  v4 = v5;
  v1 = d2i_RSAPublicKey(0LL, &v4, 270LL);
  if ( v1 && (v2 = v1, !(unsigned int)sub_2CC8490("/data/rootfs.gz", "/data/rootfs.gz.chk", a1, v1)) )
    return (unsigned int)sub_2CC8490("/data/flatkc", "/data/flatkc.chk", a1, v2) == 0;
  else
    return 0LL;
}
```

从unk_3D14AD0提取公钥的 IDA Python脚本：

```c
import idc
import idaapi
import idautils
from Crypto.Cipher import ChaCha20
from Crypto.PublicKey import RSA
from Crypto.Util.asn1 import DerSequence

def read_rsa_public_key(public_key_der):        
    # 解析DER编码的公钥
    public_key = RSA.import_key(public_key_der)
    
    # 打印公钥信息
    print("Public Key:")
    print(public_key.export_key().decode())

rsa_publickey = idaapi.get_bytes(0x3D14AD0, 270)
read_rsa_public_key(rsa_publickey)
```

output：

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwJH6VWV5pG6+j7N4FGJv
YiR+sXGQGWqwgAE2Kdc5eSnm1vyQKRFb2PDOLiIoMPQ3KimL6c37m5+JFfIgUTtr
Ivrwn7DVMuaikRUTYuh/G6qZh1R/75xx1uhrRKh4NkWKTYlMWNBqAuWf1nibhyGy
0aUYY5ICTxSwBJNG44jJRhXSciArgISnNuRrZTPA9vrN4mM3OxFLc24gCwT0lsuS
QenoibE9juOE99+sWZbYFvPzg+THKFLA7bSKDPQXuTEgxGg6XOczAV0hjrVDQV43
7D77jvRgFgWlfmk1M+IH73LBHfoEAa6KAHeyquO9fkTngDoOwvXJDmzNZJRk/zHR
EQIDAQAB
-----END PUBLIC KEY-----
```

验证逻辑：

```python
#!/usr/bin/python3
import hashlib
import os
import rsa
import sys
import binascii
import hashlib
import struct
from rsa import transform, core
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad, unpad

pem_public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwJH6VWV5pG6+j7N4FGJv
YiR+sXGQGWqwgAE2Kdc5eSnm1vyQKRFb2PDOLiIoMPQ3KimL6c37m5+JFfIgUTtr
Ivrwn7DVMuaikRUTYuh/G6qZh1R/75xx1uhrRKh4NkWKTYlMWNBqAuWf1nibhyGy
0aUYY5ICTxSwBJNG44jJRhXSciArgISnNuRrZTPA9vrN4mM3OxFLc24gCwT0lsuS
QenoibE9juOE99+sWZbYFvPzg+THKFLA7bSKDPQXuTEgxGg6XOczAV0hjrVDQV43
7D77jvRgFgWlfmk1M+IH73LBHfoEAa6KAHeyquO9fkTngDoOwvXJDmzNZJRk/zHR
EQIDAQAB
-----END PUBLIC KEY-----"""

def rsa_decrypt(encrypt_text):
    key = rsa.PublicKey.load_pkcs1_openssl_pem(pem_public_key)

    d = key.e
    n = key.n
    encrypt_text = binascii.a2b_hex(encrypt_text)
    num = transform.bytes2int(encrypt_text)
    decrypto = core.decrypt_int(num, d, n)
    out = transform.int2bytes(decrypto)
    return out

file_content = open("rootfs.gz",'rb').read()

#sha256 of initrd
sha256 = hashlib.sha256()
sha256.update(file_content)
checksum = sha256.digest()
print("calc sha256:",checksum.hex())


file_content = open("rootfs.gz.chk",'rb').read()
rsa_decrypt_out = rsa_decrypt(file_content.hex())
print("real sha256:",rsa_decrypt_out[223:].hex())
```

Output:

```
calc sha256: 6ea5efddabca282e4b64c40007af2d282dcd7b0aa6df75b353e58f793c8e618b
real sha256: 6ea5efddabca282e4b64c40007af2d282dcd7b0aa6df75b353e58f793c8e618b
```

基本上与内核那个验证流程一致，用公钥解密/data/rootfs.gz.chk，然后sha256 /data/rootfs.gz 文件，最后做对比。

### 内核中的完整性检查

start_kernel --> rest_init--> kernel_init --> kernel_init_freeable --> init_fos_ima 存在完整性检查

```c
__int64 __fastcall init_fos_ima(__int64 a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // r8d
  int v5; // r9d
  unsigned int inited; // r12d
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // r12
  __int64 v10; // rax

  inited = ima_init_crypto();
  if ( inited )
    goto LABEL_10;
  inited = sub_FFFFFFFF8055E925(); // Load the compiled-in list of X.509 certificates.
  if ( inited )
    goto LABEL_10;
  inited = sub_FFFFFFFF81738287();              // create securityfs integrity/fos
  if ( inited )
    goto LABEL_10;
  v7 = (__int64)sub_FFFFFFFF8055D6CE((__int64)off_FFFFFFFF8165F880[0]);
  if ( !v7
    || (a2 = 6324288, (v8 = kmem_cache_alloc(qword_FFFFFFFF814A0768, 6324288LL)) == 0)
    || (*(_QWORD *)(v7 + 608) = v8, (v9 = (__int64)sub_FFFFFFFF8055D6CE((__int64)off_FFFFFFFF8165F888)) == 0)
    || (a2 = 0x608040, (v10 = kmem_cache_alloc(qword_FFFFFFFF814A0768, 0x608040LL)) == 0) )
  {
    inited = -12;
LABEL_10:
    ((void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))printk)(
      (unsigned int)&unk_FFFFFFFF8140C2D8,
      a2,
      v2,
      v3,
      v4,
      v5);
    msleep(10LL);
    machine_halt();
    goto LABEL_11;
  }
  *(_QWORD *)(v9 + 608) = v10;
  inited = sub_FFFFFFFF8055F845(1);             // integrity check
                                                // 
  if ( inited )
    goto LABEL_10;
LABEL_11:
  get_sys_security_level(&unk_FFFFFFFF8165F890);
  return inited;
}
```

```c
__int64 __fastcall sub_FFFFFFFF8055F845(int a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // r8d
  int v4; // r9d
  unsigned int v5; // r12d
  __int64 v7; // rax
  unsigned int v8; // eax
  int v9; // ebx
  char v10[16]; // [rsp+4Ch] [rbp-50h] BYREF
  char v11[32]; // [rsp+5Ch] [rbp-40h] BYREF
  unsigned __int64 v12; // [rsp+7Ch] [rbp-20h]

  v12 = __readgsqword(0x28u);
  if ( a1 )
  {
    while ( 1 )
    {
      v9 = sub_FFFFFFFF8055F058(v11);
      if ( !v9 )
        break;
      msleep_interruptible(50LL);
    }
    if ( do_faccessat(4294967196LL, v11, 0LL) )
    {
      v8 = name_to_dev_t(v11);
      do_mknodat(4294967196LL, v11, 24832LL, (unsigned __int8)v8 | (v8 << 12) & 0xFFF00000 | (v8 >> 20 << 8));
      v9 = 1;
    }
    v5 = ksys_mount(v11, aData_0, aExt3, 6LL, 0LL);
    if ( v5 )
    {
      printk((unsigned int)&unk_FFFFFFFF8140C930, (unsigned int)aData_0, v1, v2, v3, v4);
      goto LABEL_12;
    }
  }
  else
  {
    v9 = 0;
  }
  if ( !(unsigned int)kern_path(aDataLibLibipsS, 1LL, v10) )//libips.so.new.x验证libips.so.new
  {
    path_put(v10);
    v5 = sub_FFFFFFFF8055E7F0(0LL, aDataLibLibipsS, aDataLibLibipsS_0);
    if ( v5 )
      goto LABEL_11;
  }
  if ( (unsigned int)kern_path(aDataLibLibavSo, 1LL, v10)
    || (path_put(v10), (v5 = sub_FFFFFFFF8055E7F0(0LL, aDataLibLibavSo, aDataLibLibavSo_0)) == 0) )
  { //libav.so.new.x 验证libav.so.new
    v5 = sub_FFFFFFFF8055F338();//利用.db.x .db 对完整性检查：
LABEL_11:
    if ( a1 )
      goto LABEL_16;
    goto LABEL_12;
  }
  if ( a1 )
  {
LABEL_16:
    ksys_umount(aData_0, 2LL);
    if ( v9 )
      goto LABEL_17;
    return v5;
  }
LABEL_12:
  if ( v9 )
  {
LABEL_17:
    v7 = getname(v11);
    do_unlinkat(4294967196LL, v7);
  }
  return v5;
}
```

重点是sub_FFFFFFFF8055F845函数，其工作流程为：

- 疑似会使用 libips.so.new.x验证libips.so.new  ,  libav.so.new.x 验证libav.so.new （PKCS#7 签名文件的完整性验证）（证书可以从sub_FFFFFFFF8055E925 函数提取）
- 然后会像用户态的那样，调用函数sub_FFFFFFFF8055F338 用 /data/.db.x 与 /data/.db 对特定部分进行完整性验证。



# 二进制patch

### 内核patch点

- rootfs.gz 的sha256计算：nop掉fgt_decompress函数中的machine_halt()函数调用，并使fgt_decompress返回0

  ![image-20240806204338768](images/image-20240806204338768.png)

  

  ![image-20240806204358392](images/image-20240806204358392.png)

  ```c
  __int64 fgt_decompress()
  {
    int v0; // ebx
    __int64 *v1; // rdi
    __int64 i; // rcx
    __int64 v3; // rcx
    __int64 *v4; // rdi
    __int64 v5; // r14
    __int64 *v6; // rdi
    __int64 v7; // rcx
    char *v8; // rsi
    __int64 v9; // r15
    __int64 v10; // rbx
    __int64 raw_data; // rax
    __int64 v12; // r14
    __int64 v13; // rax
    int v14; // eax
    __int64 v15; // r9
    int buffer; // eax
    int v17; // r12d
    int v18; // eax
    _BYTE *v19; // rcx
    int v20; // r12d
    _DWORD *v21; // rsi
    __int64 v22; // rcx
    char *v23; // rdi
    __int64 v24; // rdx
    __int64 j; // rax
    __int64 v26; // r14
    unsigned int v27; // ebx
    char *v28; // rdx
    unsigned __int8 v29; // al
    unsigned int v30; // r15d
    __int64 v31; // rcx
    __int64 v32; // rax
    __int64 v33; // rax
    __int64 v35; // [rsp+8h] [rbp-3B0h]
    __int64 v36; // [rsp+8h] [rbp-3B0h]
    __int64 v37; // [rsp+10h] [rbp-3A8h]
    int v38; // [rsp+10h] [rbp-3A8h]
    __int64 v39; // [rsp+18h] [rbp-3A0h] BYREF
    __int64 v40; // [rsp+20h] [rbp-398h]
    __int64 v41; // [rsp+28h] [rbp-390h]
    __int64 v42; // [rsp+30h] [rbp-388h]
    __int64 v43; // [rsp+38h] [rbp-380h]
    __int64 v44[16]; // [rsp+40h] [rbp-378h] BYREF
    __int64 v45; // [rsp+C0h] [rbp-2F8h] BYREF
    __int64 v46; // [rsp+C8h] [rbp-2F0h]
    char v47[104]; // [rsp+E8h] [rbp-2D0h] BYREF
    char v48[488]; // [rsp+150h] [rbp-268h] BYREF
    __int64 v49; // [rsp+338h] [rbp-80h] BYREF
    __int64 v50; // [rsp+340h] [rbp-78h]
    char v51[32]; // [rsp+348h] [rbp-70h] BYREF
    char v52[32]; // [rsp+368h] [rbp-50h] BYREF
    unsigned __int64 v53; // [rsp+388h] [rbp-30h]
  
    v53 = __readgsqword(0x28u);
    v0 = initrd_end - initrd_start;
    if ( (unsigned __int64)(initrd_end - initrd_start) > 0x100 )
    {
      v1 = v44;
      for ( i = 32LL; i; --i )
      {
        *(_DWORD *)v1 = 0;
        v1 = (__int64 *)((char *)v1 + 4);
      }
      v3 = 10LL;
      v4 = &v39;
      while ( v3 )
      {
        *(_DWORD *)v4 = 0;
        v4 = (__int64 *)((char *)v4 + 4);
        --v3;
      }
      v5 = kmem_cache_alloc(qword_FFFFFFFF814A07A8, 6291648LL);
      if ( v5 )
      {
        sha256_init(v48);
        sha256_update_0(v48, &unk_FFFFFFFF817972C6, 26LL);
        sha256_update_0(v48, &unk_FFFFFFFF817972C0, 6LL);
        sha256_final_0(v48, v51);
        sha256_init(v48);
        sha256_update_0(v48, &unk_FFFFFFFF817972C3, 29LL);
        sha256_update_0(v48, &unk_FFFFFFFF817972C0, 3LL);
        sha256_final_0(v48, v52);
        v6 = &v45;
        v7 = 8LL;
        v8 = v51;
        while ( v7 )
        {
          *(_DWORD *)v6 = *(_DWORD *)v8;
          v8 += 4;
          v6 = (__int64 *)((char *)v6 + 4);
          --v7;
        }
        crypto_chacha20_init(v47, &v45, v52);
        chacha20_docrypt(v47, v5, &unk_FFFFFFFF817971A0, 270LL);
        if ( !(unsigned int)rsa_parse_pub_key(v44, v5, 270LL)
          && (v40 = mpi_read_raw_data(v44[1], v44[9])) != 0
          && (v39 = mpi_read_raw_data(v44[0], v44[8])) != 0
          && (v41 = kmem_cache_alloc(qword_FFFFFFFF814A07C0, 6291648LL)) != 0
          && (v43 = kmem_cache_alloc(qword_FFFFFFFF814A0788, 6291648LL)) != 0 )
        {
          kfree(v5);
          sha256_init(v47);
          sha256_update_0(v47, initrd_start, (unsigned int)(v0 - 256));
          sha256_final_0(v47, v43);
          v9 = initrd_end;
          v10 = initrd_end - 256;
          v42 = initrd_end - 256;
          v37 = v43;
          raw_data = mpi_read_raw_data(initrd_end - 256, 256LL);
          v12 = raw_data;
          if ( raw_data )
          {
            if ( (int)mpi_cmp_ui(raw_data, 0LL) >= 0 && (int)mpi_cmp(v12, v39) < 0 )
            {
              v13 = mpi_alloc(0LL);
              if ( v13 )
              {
                v35 = v13;
                v14 = mpi_powm(v13, v12, v40, v39);
                v15 = v35;
                if ( !v14 )
                {
                  buffer = mpi_read_buffer(v35, v42, 256LL, v44, 0LL);
                  v17 = v44[0];
                  LOBYTE(v17) = ~LOBYTE(v44[0]);
                  v18 = *(_BYTE *)(v9 - 256) ^ 1 | v17 | buffer;
                  v19 = (_BYTE *)(v9 - 255);
                  v15 = v35;
                  do
                    v18 |= (unsigned __int8)~*v19++;
                  while ( (_BYTE *)(v9 - 82) != v19 );
                  v20 = v18 | *(unsigned __int8 *)(v10 + 174);
                  v21 = (_DWORD *)(v10 + 223);
                  v22 = 8LL;
                  v23 = v52;
                  while ( v22 )
                  {
                    *(_DWORD *)v23 = *v21++;
                    v23 += 4;
                    --v22;
                  }
                  v24 = *(_QWORD *)(v10 + 215);
                  v49 = *(_QWORD *)(v10 + 207);
                  v50 = v24;
                  for ( j = 0LL; j != 32; ++j )
                    v20 |= (unsigned __int8)(*(_BYTE *)(v37 + j) ^ *(_BYTE *)(v9 + j - 81));
                }
                mpi_free(v15);
              }
            }
            mpi_free(v12);
          }
          mpi_free(v40);
          mpi_free(v39);
          kfree(v41);
          kfree(v43);
        }
        else
        {
          kfree(v5);
          mpi_free(v40);
          mpi_free(v39);
          kfree(v41);
          kfree(v43);
        }
      }
    }
    initrd_end -= 256LL;
    v26 = initrd_start;
    v27 = initrd_end - initrd_start;
    v38 = ((_BYTE)initrd_end - (_BYTE)initrd_start) & 0xF;
    sub_FFFFFFFF80590565(v48, v52, 32LL);
    v28 = (char *)&v49;
    v29 = 0;
    do
    {
      v29 ^= *v28 & 0xF ^ ((unsigned __int8)*v28 >> 4);
      ++v28;
    }
    while ( v51 != v28 );
    if ( !v29 )
      v29 = 1;
    v45 = v49;
    v46 = v50;
    v30 = 0;
    v31 = v29;
    do
    {
      v36 = v31;
      sub_FFFFFFFF80254C73(v48, v51, &v45);
      v32 = 0LL;
      v31 = v36;
      do
      {
        *(_BYTE *)(v26 + v30 + (unsigned int)v32) ^= v51[v32];
        ++v32;
      }
      while ( v32 != 16 );
      v46 += v36;
      v30 += 16;
    }
    while ( v27 >= v30 );
    if ( v38 )
    {
      sub_FFFFFFFF80254C73(v48, v51, &v45);
      v33 = 0LL;
      do
      {
        *(_BYTE *)(v26 + v30 + (unsigned int)v33) ^= v51[v33];
        ++v33;
      }
      while ( v38 != (_DWORD)v33 );
    }
    return 0LL;
  }
  ```

  

  - 利用.db.x .db 对完整性检查：nop 掉 sub_FFFFFFFF8055F845 对 sub_FFFFFFFF8055F338（因为没有对sub_FFFFFFFF8055F338的交叉引用，所以可以采用这种方法）函数的调用，然后在nop掉的地方将eax 设置为0 (xor eax,eax)


  ![image-20240806204607668](images/image-20240806204607668.png)


```c
__int64 __fastcall sub_FFFFFFFF8055F845(int a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // r8d
  int v4; // r9d
  unsigned int v5; // r12d
  __int64 v7; // rax
  unsigned int v8; // eax
  int v9; // ebx
  char v10[16]; // [rsp+4Ch] [rbp-50h] BYREF
  char v11[16]; // [rsp+5Ch] [rbp-40h] BYREF
  unsigned __int64 v12; // [rsp+7Ch] [rbp-20h]

  v12 = __readgsqword(0x28u);
  if ( a1 )
  {
    while ( 1 )
    {
      v9 = sub_FFFFFFFF8055F058(v11);
      if ( !v9 )
        break;
      msleep_interruptible(50LL);
    }
    if ( do_faccessat(4294967196LL, v11, 0LL) )
    {
      v8 = name_to_dev_t(v11);
      do_mknodat(4294967196LL, v11, 24832LL, (unsigned __int8)v8 | (v8 << 12) & 0xFFF00000 | (v8 >> 20 << 8));
      v9 = 1;
    }
    v5 = ksys_mount(v11, aData_0, aExt3, 6LL, 0LL);
    if ( v5 )
    {
      printk((unsigned int)&unk_FFFFFFFF8140C930, (unsigned int)aData_0, v1, v2, v3, v4);
      goto LABEL_12;
    }
  }
  else
  {
    v9 = 0;
  }
  if ( !(unsigned int)kern_path(aDataLibLibipsS, 1LL, v10) )
  {
    path_put(v10);
    v5 = sub_FFFFFFFF8055E7F0(0LL, aDataLibLibipsS, aDataLibLibipsS_0);
    if ( v5 )
      goto LABEL_11;
  }
  if ( (unsigned int)kern_path(aDataLibLibavSo, 1LL, v10)
    || (path_put(v10), (v5 = sub_FFFFFFFF8055E7F0(0LL, aDataLibLibavSo, aDataLibLibavSo_0)) == 0) )
  {
    v5 = 0;
LABEL_11:
    if ( a1 )
      goto LABEL_16;
    goto LABEL_12;
  }
  if ( a1 )
  {
LABEL_16:
    ksys_umount(aData_0, 2LL);
    if ( v9 )
      goto LABEL_17;
    return v5;
  }
LABEL_12:
  if ( v9 )
  {
LABEL_17:
    v7 = getname(v11);
    do_unlinkat(4294967196LL, v7);
  }
  return v5;
}
```

### init patch点

- 利用.db.x .db 对完整性检查

```c
__int64 __fastcall sub_2E77BC0(__int64 a1, unsigned int a2)
{
  __int64 v2; // r14
  __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // r12
  int v6; // eax
  __int64 v7; // r13
  __int64 i; // r15
  __int64 idx; // rax

  v2 = json_object_from_file();
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    v4 = json_object_object_get(v2, "version");
    json_object_get_int(v4);
    v5 = json_object_object_get(v2, "files");
    v6 = json_object_array_length(v5);
    if ( v6 <= 0 )
    {
LABEL_9:
      json_object_put_no_assert(v2, &j__generate_crashlog_backtrace_58);
      return 1LL;
    }
    else
    {
      v7 = (unsigned int)(v6 - 1);
      for ( i = 0LL; ; ++i )
      {
        idx = json_object_array_get_idx(v5, i);
        if ( (int)sub_2E779E0(idx, a2) <= 0 )
          break;
        if ( i == v7 )
          goto LABEL_9;
      }
      json_object_put_no_assert(v2, &j__generate_crashlog_backtrace_58);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}
```

要使该函数始终返回1，修改如下：

![image-20240806205640399](images/image-20240806205640399.png)

![image-20240806205619002](images/image-20240806205619002.png)

![image-20240806202811348](images/image-20240806202811348.png)

```c
__int64 __fastcall sub_2E77BC0(__int64 a1, int a2)
{
  __int64 v2; // r14
  __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // r12
  int v6; // eax
  __int64 v7; // r13
  __int64 i; // r15
  __int64 idx; // rax

  v2 = json_object_from_file(a1);
  result = 1LL;
  if ( v2 )
  {
    v4 = json_object_object_get(v2, "version");
    json_object_get_int(v4);
    v5 = json_object_object_get(v2, "files");
    v6 = json_object_array_length(v5);
    if ( v6 <= 0 )
    {
LABEL_9:
      json_object_put_no_assert(v2, (__int64)&j__generate_crashlog_backtrace_58);
      return 1LL;
    }
    else
    {
      v7 = (unsigned int)(v6 - 1);
      for ( i = 0LL; ; ++i )
      {
        idx = json_object_array_get_idx(v5, i);
        if ( (int)sub_2E779E0(idx, a2) <= 0 )
          break;
        if ( i == v7 )
          goto LABEL_9;
      }
      json_object_put_no_assert(v2, (__int64)&j__generate_crashlog_backtrace_58);
      return 1LL;
    }
  }
  return result;
}
```


```c
__int64 sub_2E77CA0()
{
  void *v0; // rax
  void *v1; // r12
  void *v2; // rax
  int v3; // r8d
  int v4; // r9d
  void *v5; // r13
  int v7; // [rsp+0h] [rbp-20h] BYREF
  int v8; // [rsp+4h] [rbp-1Ch] BYREF
  unsigned __int64 v9; // [rsp+8h] [rbp-18h]

  v9 = __readfsqword(0x28u);
  v0 = sub_2E77720("/data/.db", &v7);
  if ( !v0 )
    return 0xFFFFFFFFLL;
  v1 = v0;
  if ( v7 <= 0 )
  {
    free(v0);
    return 0xFFFFFFFFLL;
  }
  v2 = sub_2E77720("/data/.db.x", &v8);
  v5 = v2;
  if ( v2 )
  {
    if ( v8 <= 0 )
    {
      free(v1);
      free(v5);
      return 0LL;
    }
    else
    {
      return sub_257A3B0((__int64)v1, v7, (__int64)v2, v8, v3, v4);
    }
  }
  else
  {
    free(v1);
    return 0LL;
  }
}
```

要使该函数始终返回1,但要注意sub_2E77720调用的是malloc，需要注意释放问题，我们直接让该函数在调用sub_2E77720读取/data/.db数据后，释放掉数据，然后返回1

![image-20240806202640080](images/image-20240806202640080.png)

```c
__int64 sub_2E77CA0()
{
  void *v0; // rax
  int v2; // [rsp+0h] [rbp-20h] BYREF
  __int64 v3[3]; // [rsp+8h] [rbp-18h]

  v3[0] = __readfsqword(0x28u);
  v0 = sub_2E77720("/data/.db", &v2);
  if ( v0 )
    free(v0);
  return 1LL;
}
```

- 利用公钥对rootfs.gz 以及datafs.tar.gz的sha256检查

需要修改函数

```c
_BOOL8 __fastcall sub_2D097A0(unsigned int a1)
{
  __int64 v1; // rax
  __int64 v2; // r12
  char *v4; // [rsp+8h] [rbp-138h] BYREF
  char v5[268]; // [rsp+10h] [rbp-130h] BYREF
  __int16 v6; // [rsp+11Ch] [rbp-24h]
  char v7; // [rsp+11Eh] [rbp-22h]
  unsigned __int64 v8; // [rsp+128h] [rbp-18h]

  v8 = __readfsqword(0x28u);
  qmemcpy(v5, &unk_3D14AD0, sizeof(v5));
  v6 = 256;
  v7 = 0;
  v4 = v5;
  v1 = d2i_RSAPublicKey(0LL, &v4, 270LL);
  if ( v1 && (v2 = v1, !(unsigned int)sub_2CC8490("/data/rootfs.gz", "/data/rootfs.gz.chk", a1, v1)) )
    return (unsigned int)sub_2CC8490("/data/flatkc", "/data/flatkc.chk", a1, v2) == 0;
  else
    return 0LL;
}
```

使其始终返回1,如：

![image-20240806202428071](images/image-20240806202428071.png)

```c
__int64 __fastcall sub_2D097A0(unsigned int a1)
{
  char *v2; // [rsp+8h] [rbp-138h] BYREF
  char v3[268]; // [rsp+10h] [rbp-130h] BYREF
  __int16 v4; // [rsp+11Ch] [rbp-24h]
  char v5; // [rsp+11Eh] [rbp-22h]
  unsigned __int64 v6; // [rsp+128h] [rbp-18h]

  v6 = __readfsqword(0x28u);
  qmemcpy(v3, &unk_3D14AD0, sizeof(v3));
  v4 = 256;
  v5 = 0;
  v2 = v3;
  d2i_RSAPublicKey(0LL, &v2, 270LL);
  return 1LL;
}
```

上面几个点都在完整性检查中提到过

# 内核压缩

x64 调用 内核解压缩的调用指令为：

```asm
	pushq	%rsi			/* Save the real mode argument */
	movq	%rsi, %rdi		/* real mode address */
	leaq	boot_heap(%rip), %rsi	/* malloc area for uncompression */
	leaq	input_data(%rip), %rdx  /* input_data */
	movl	$z_input_len, %ecx	/* input_len */
	movq	%rbp, %r8		/* output target address */
	movq	$z_output_len, %r9	/* decompressed length, end of relocs */
	call	extract_kernel		/* returns kernel location in %rax */
	popq	%rsi
```

大概的汇编指令是：

```asm
boot.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_start>:
   0:	56                   	push   %rsi
   1:	48 89 f7             	mov    %rsi,%rdi
   4:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # b <_start+0xb>
   b:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 12 <_start+0x12>
  12:	b9 00 00 00 00       	mov    $0x0,%ecx
  17:	49 89 e8             	mov    %rbp,%r8
  1a:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
  21:	e8 01 00 00 00       	call   27 <extract_kernel>
  26:	5e                   	pop    %rsi

0000000000000027 <extract_kernel>:
  27:	c3                   	ret    

Disassembly of section .data:

0000000000000000 <boot_heap>:
	...

Disassembly of section .bss:

```

将

```
-r--r--r-- 1 sysirq sysirq 7.2M Aug  6 14:06 flatkc
```

拖入IDA，通过IDA Python 完成匹配：

```python
import idc
import idaapi
import idautils

def find_all_sequences(data, sequence):
    sequence_length = len(sequence)
    data_length = len(data)
    indices = []
    
    position = 0
    
    while position < data_length:
        position = data.find(sequence, position)
        if position == -1:
            break
        indices.append(position)
        position += 1
    return indices

start_addr = 0x200
end_addr   = 0x1A88FFE

img_data = idaapi.get_bytes(start_addr, end_addr - start_addr)
address = find_all_sequences(img_data,bytes([0x56, 0x48, 0x89, 0xF7,0x48,0x8d,0x35]))

for addr in address:
    addr += start_addr
    data = idaapi.get_bytes(addr, 39)
    if data[11:14] != bytes([0x48,0x8d,0x15]):
        continue
    if data[18] != 0xb9:
        continue
    if data[23:26] != bytes([0x49,0x89,0xe8]):
        continue
    if data[26:29] != bytes([0x49,0xc7,0xc1]):
        continue
    if data[33] != 0xe8:
        continue
    if data[38] != 0x5e:
        continue
    input_data_addr = addr + 18 + int.from_bytes(data[14:18], byteorder='little', signed=True)
    input_data_len  = int.from_bytes(data[19:23], byteorder='little', signed=True)
    decompressed_len = int.from_bytes(data[29:33], byteorder='little', signed=True)
    extract_kernel_addr = int.from_bytes(data[34:38], byteorder='little', signed=True) + 38 + addr
    
    print("input_data addr:",hex(input_data_addr))
    print("input_data_len:",hex(input_data_len))
    print("decompressed_len:",hex(decompressed_len))
    print("extract_kernel addr:",hex(extract_kernel_addr))
```

output:

```
input_data addr: 0x41b4
input_data_len: 0x6ef83d
decompressed_len: 0x1a37918
extract_kernel addr: 0x6f66e0
```

提取 input_data 先看看是个什么玩意：

```python
import idc
import idaapi
import idautils

input_data = idaapi.get_bytes(0x41b4, 0x6ef83d)
open('D:\Work\input_data.bin', 'wb').write(input_data)

print("done")
```

```shell
sysirq@sysirq-machine:~/Work/Fortinet/kernel$ file input_data.bin 
input_data.bin: gzip compressed data, max compression, from Unix, original size modulo 2^32 27490584
```

解压，查看：

```sh
sysirq@sysirq-machine:~/Work/Fortinet/kernel/tmp$ ls -hl
total 27M
-rw-rw-r-- 1 sysirq sysirq 27M Aug  7 14:42 input_data
sysirq@sysirq-machine:~/Work/Fortinet/kernel/tmp$ file input_data 
input_data: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=00d63c8d34cb5ddb0ee0cf37d72894e649219313, stripped
sysirq@sysirq-machine:~/Work/Fortinet/kernel/tmp$ 

```

拖进IDA，发现是没有符号的vmlinuz，我们可以通过使用 vmlinux-to-elf 解压出来的，带符号的内核，找到需要修改的地址，然后在该版本上进行修改（上面已经有修改的教程了）。

修改完之后，重新压缩（需要比原来的要小或相等）：

```sh
cat input_data_patched | gzip -9 > vmlinux.gz
```

然后用这个 patch flatkc，IDA Python 脚本：

```python
import idc
import idaapi
import idautils

def find_all_sequences(data, sequence):
    sequence_length = len(sequence)
    data_length = len(data)
    indices = []
    
    position = 0
    
    while position < data_length:
        position = data.find(sequence, position)
        if position == -1:
            break
        indices.append(position)
        position += 1
    return indices

start_addr = 0x200
end_addr   = 0x1A88FFE

img_data = idaapi.get_bytes(start_addr, end_addr - start_addr)
address = find_all_sequences(img_data,bytes([0x56, 0x48, 0x89, 0xF7,0x48,0x8d,0x35]))

patch_data = open('D:\\Work\\vmlinux.gz', 'rb').read()
print("patch data size:",len(patch_data))

for addr in address:
    addr += start_addr
    data = idaapi.get_bytes(addr, 39)
    if data[11:14] != bytes([0x48,0x8d,0x15]):
        continue
    if data[18] != 0xb9:
        continue
    if data[23:26] != bytes([0x49,0x89,0xe8]):
        continue
    if data[26:29] != bytes([0x49,0xc7,0xc1]):
        continue
    if data[33] != 0xe8:
        continue
    if data[38] != 0x5e:
        continue
    input_data_addr = addr + 18 + int.from_bytes(data[14:18], byteorder='little', signed=True)
    input_data_len  = int.from_bytes(data[19:23], byteorder='little', signed=True)
    input_data_len_addr = addr + 19
    decompressed_len = int.from_bytes(data[29:33], byteorder='little', signed=True)
    extract_kernel_addr = int.from_bytes(data[34:38], byteorder='little', signed=True) + 38 + addr
    
    print("input_data addr:",hex(input_data_addr))
    print("input_data_len:",input_data_len)
    print("input_data_len_addr:",hex(input_data_len_addr))
    print("decompressed_len:",hex(decompressed_len))
    print("extract_kernel addr:",hex(extract_kernel_addr))
    
    if len(patch_data) > input_data_len:
        print("error: patch_data_len > input_len")
        exit(-1)
        
    idaapi.patch_bytes(input_data_addr,patch_data)
    idaapi.patch_dword(input_data_len_addr,len(patch_data))
```

output:

```
patch data size: 7272506
input_data addr: 0x41b4
input_data_len: 7272509
input_data_len_addr: 0x6f3a2d
decompressed_len: 0x1a37918
extract_kernel addr: 0x6f66e0
```

然后IDA应用patch，自此完成内核的patch

# init 打包

**注意权限问题(root)**

用patched 的 init。替换原来的init

```shell
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# tar -xvf bin.tar.xz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# ls
bin  bin.tar.xz  init.patched
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum  init.patched 
b4fd797010856fa9c53c6186696687cba5a206617406dd391c9b8be3085c7fba  init.patched
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum bin/init
cfdd06a8f296ba36df5c06173ee054d7f2afabb4f0f7a0f06e429fa6fe4ec7d1  bin/init
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# cp init.patched bin/init
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum bin/init
b4fd797010856fa9c53c6186696687cba5a206617406dd391c9b8be3085c7fba  bin/init
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# rm bin.tar.xz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# tar -cJf bin.tar.xz bin/
```

替换rootfs中的bin.tar.xz：

```sh
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum bin.tar.xz 
37de0ca874825fb4bf41723422639365aa27a5182e2b856b568e9daa84beaf3e  bin.tar.xz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum ../tmp/bin.tar.xz 
840110f6167104e7eb0c96132081b5961f81ca20be7ec4bc016a2fe46f373608  ../tmp/bin.tar.xz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# cp bin.tar.xz ../tmp/bin.tar.xz 
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/bin# sha256sum ../tmp/bin.tar.xz 
37de0ca874825fb4bf41723422639365aa27a5182e2b856b568e9daa84beaf3e  ../tmp/bin.tar.xz
```

创建rootfs:

```
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/tmp# ls
bin.tar.xz  data   dev  fortidev  lib    migadmin.tar.xz      proc  sys  usr         var
boot        data2  etc  init      lib64  node-scripts.tar.xz  sbin  tmp  usr.tar.xz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/tmp# find . | cpio -H newc -o | gzip > ../initrd.cpio.gz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs/tmp# 
```

这会在父目录创建initrd.cpio.gz

用脚本对这个initrd.cpio.gz加密，脚本如下：

```python
#!/usr/bin/python3
import hashlib
import os
import rsa
import sys
import binascii
import hashlib
import struct
from rsa import transform, core
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad, unpad

pem_public_key ="""-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtzB6dtNtMQXM44XKH+uP
99TgLPse76CbG6Id/tFMZTdth1o0zePz4TgBn6EW9PwPEaCs5R5u9YgvAv0Eu3kJ
0Cr2kBCNLZv9qv0aH3BNgA/zF3XjadA7c9wNVsVX5f/FWbXCC8MlDbQ0wLYupL2w
acLuW+DU0NGaWFZ8BHOHPoEQoq+tUKrCJIZ0gvShsGvKGy+8M1sGWHmjRW8GOLPl
rBNxWC+/Kk5Vfw04AVgcvE3QUvtvoUK5CHKFcqKtNlck/h9BAAQsazPUfAOZY3bE
ZYxLOllJS2LMpK466Yj2u8Oz3B4+xqro9fBpsrpsGUlIyC6MOrRiyEJ1M39APX0D
cwIDAQAB
-----END PUBLIC KEY-----"""

def aes_ecb_encrypt(enc,key):
    cipher = AES.new( key, AES.MODE_ECB)
    encrypted_text = cipher.encrypt(enc)
    return encrypted_text
def rsa_decrypt(encrypt_text):
    key = rsa.PublicKey.load_pkcs1_openssl_pem(pem_public_key)

    d = key.e
    n = key.n
    encrypt_text = binascii.a2b_hex(encrypt_text)
    num = transform.bytes2int(encrypt_text)
    decrypto = core.decrypt_int(num, d, n)
    out = transform.int2bytes(decrypto)
    return out

initrd_name="rootfs.gz" # 初始的initrd
initrd_to_encrypt_name="initrd.cpio.gz" # 需要进行加密的initrd
output_initrd_name="rootfs.encrypt.gz.out" # 加密后的initrd

file_size = os.path.getsize(initrd_name)
file_content = open(initrd_name,'rb').read(file_size - 256)

print("file total size:",file_size)
print("start offset:",0)
print("end   offset:",file_size - 256)

#sha256 of initrd_start ----- initrd_end - 256
sha256 = hashlib.sha256()
sha256.update(file_content)
checksum = sha256.digest()
print("calc sha256:",checksum.hex())

#real sha256 from RSA pub key decrypt
file = open(initrd_name,'rb')
file.seek(-256,2)
file_content = file.read(256)
rsa_decrypt_out = rsa_decrypt(file_content.hex())
print("real sha256:",rsa_decrypt_out[175:175+32].hex())

#aes key and data
aes_key = rsa_decrypt_out[223:]
aes_data=rsa_decrypt_out[207:207+16]

print("ase key len:",len(aes_key))
print("aes key:",aes_key.hex())
print("ase data len:",len(aes_data))
print("ase data:",aes_data.hex())

#use aes data calc addend
"""
  v28 = 0;
  do
  {
    v28 ^= *v27 & 0xF ^ ((unsigned __int8)*v27 >> 4);
    ++v27;
  }
  while ( v50 != v27 );
  if ( !v28 )
    v28 = 1;
"""
addend = 0
for b in aes_data:
    addend ^= (b&0xF)^(b>>4)
if addend == 0:
    addend = 1

print("addend: ",addend)

# encrypt initrd
"""
  do
  {
    v35 = v30;
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v31 = 0LL;
    v30 = v35;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v31) ^= v50[v31];
      ++v31;
    }
    while ( v31 != 16 );
    v45 += v35;
    v29 += 16;
  }
  while ( v26 >= v29 );
  if ( v37 )
  {
    crypto_aes_encrypt_x86(v47, v50, &v44);
    v32 = 0LL;
    do
    {
      *(_BYTE *)(v25 + v29 + (unsigned int)v32) ^= v50[v32];
      ++v32;
    }
    while ( v37 != (_DWORD)v32 );
  }
"""
initrd_file_total_size = os.path.getsize(initrd_to_encrypt_name)
initrd_file_content = open(initrd_to_encrypt_name,'rb').read(initrd_file_total_size)
initrd_file_content = bytearray(initrd_file_content)
initrd_file_offset = 0
remain_bytes_count = initrd_file_total_size & 0xF

while initrd_file_offset < (initrd_file_total_size&(~0xF)):
    aes_encrypt_data = aes_ecb_encrypt(aes_data,aes_key)
    for i in range(16):
        initrd_file_content[initrd_file_offset + i] ^= aes_encrypt_data[i]
    initrd_file_offset += 16
    
    qword_bytes = aes_data[8:16]
    qword_value = struct.unpack('<Q', qword_bytes)[0]
    qword_value += addend
    new_qword_bytes = struct.pack('<Q', qword_value)
    aes_data = aes_data[:8] + new_qword_bytes

if remain_bytes_count != 0:
    aes_encrypt_data = aes_ecb_encrypt(aes_data,aes_key)
    for i in range(remain_bytes_count):
        initrd_file_content[initrd_file_offset + i] ^= aes_encrypt_data[i]

# 追加原始initrd的256字节
file = open(initrd_name,'rb')
file.seek(-256,2)
file_content = file.read(256)
initrd_file_content = bytes(initrd_file_content) + file_content

open(output_initrd_name,'wb').write(initrd_file_content)
```

我们可以用那个initrd解密脚本来解密，验证是否正确。结果应该是：sha256值应该是不一样的,但是能正常解密出rootfs

解密运行的output:

```sh
sysirq@sysirq-machine:~/Work/Fortinet/rootfs$ ./extract_rootfs.py
file total size: 76018358
start offset: 0
end   offset: 76018102
calc sha256: a6edd1e26270c745e4bda2aeb6531b7cb848bba1260a92dbf082ef54059d9e90
real sha256: e5e7b84f59d6014cdeadfd7b5edd79609a58d8df52347e4a85ed401f6b26012f
ase key len: 32
aes key: b36294c5330a159d5e90a12f590549f249be690f3294ba54a0bd9ec896bfc4ca
ase data len: 16
ase data: 310e91cb89ce4e14d7bb9bf0ee547f6f
addend:  8
sysirq@sysirq-machine:~/Work/Fortinet/rootfs$ file rootfs.gz.out 
rootfs.gz.out: gzip compressed data, max compression, from Unix, original size modulo 2^32 12732979
```

# 替换 

**注意权限问题**

以下命令全是root执行

```
modprobe nbd max_part=8
qemu-nbd --connect=/dev/nbd0 fortios.qcow2 
fdisk -l /dev/nbd0
mount /dev/nbd0p1 /mnt/
```

内核替换：

```sh
root@sysirq-machine:/home/sysirq/Work/Fortinet/kernel# sha256sum /mnt/flatkc
fade571b90681aa514aea0f7b4e0e64805d3ecc712d6df851d008224aa029a99  /mnt/flatkc
root@sysirq-machine:/home/sysirq/Work/Fortinet/kernel# sha256sum flatkc_patched 
38ab295d00668393cdc48984b97dd0e10eb3592badd21cb890c488c0fb2257f0  flatkc_patched
root@sysirq-machine:/home/sysirq/Work/Fortinet/kernel# cp flatkc_patched /mnt/flatkc
root@sysirq-machine:/home/sysirq/Work/Fortinet/kernel# sha256sum /mnt/flatkc
38ab295d00668393cdc48984b97dd0e10eb3592badd21cb890c488c0fb2257f0  /mnt/flatkc
```

rootfs替换：

```sh
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs# sha256sum /mnt/rootfs.gz
6ea5efddabca282e4b64c40007af2d282dcd7b0aa6df75b353e58f793c8e618b  /mnt/rootfs.gz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs# sha256sum rootfs.decrypt.gz.out
eb7e0ed22b75bcaa73fdc3767e4dfb4af9cc449f3cf7ca5c7a1987662817eed1  rootfs.decrypt.gz.out
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs# cp rootfs.decrypt.gz.out /mnt/rootfs.gz
root@sysirq-machine:/home/sysirq/Work/Fortinet/rootfs# sha256sum /mnt/rootfs.gz
eb7e0ed22b75bcaa73fdc3767e4dfb4af9cc449f3cf7ca5c7a1987662817eed1  /mnt/rootfs.gz
```

```
umount /mnt
qemu-nbd --disconnect /dev/nbd0
```



发现内核无限重启了呢，在kernel_restart下断点：

```log
#0  0xffffffff803125eb in kernel_restart ()
#1  0xffffffff8055dd89 in ima_file_check ()
#2  0xffffc90002ebbe0a in ?? ()
#3  0x00000000006000c0 in ?? ()
#4  0xffffffff80414d0c in mem_cgroup_throttle_swaprate ()
#5  0xffffc90002ebbbf0 in ?? ()
#6  0xffff888078382920 in ?? ()
#7  0xffffc90002ebbbd8 in ?? ()
#8  0xffffffff8040623a in page_add_new_anon_rmap ()
#9  0xffffffff8055e22e in ima_bprm_check ()
#10 0xffffffff8055982a in security_bprm_check ()
#11 0xffffffff80453b8f in __do_execve_file ()
#12 0xffffffff80453f94 in do_execve ()
#13 0xffffffff803066be in call_usermodehelper_exec_async ()
#14 0xffffffff80e001c5 in ret_from_fork ()
#15 0x0000000000000000 in ?? ()
```

研究一下ima



# 资料

Configuring Network Settings using the CLI

https://help.fortinet.com/fdb/5-0-0/html/source/tasks/t_network_configuration_cli.html

Administration Guide

https://docs.fortinet.com/document/fortigate/7.4.4/administration-guide/498634/using-the-cli

Permanent trial mode for FortiGate-VM

https://docs.fortinet.com/document/fortigate/7.4.4/administration-guide/441460

KVM Administration Guide

https://docs.fortinet.com/document/fortigate-private-cloud/7.4.0/kvm-administration-guide/706376/about-fortigate-vm-on-kvm

Error downloading license: Invalid serial number

https://community.fortinet.com/t5/Support-Forum/Error-downloading-license-Invalid-serial-number/m-p/251838

Technical Note: VM License activation

https://community.fortinet.com/t5/FortiGate/Technical-Note-VM-License-activation/ta-p/190534

VM license

https://docs.fortinet.com/document/fortigate/7.4.4/administration-guide/416169

虚拟 PC 通过 FortiGate VM 上网

https://blog.csdn.net/meigang2012/article/details/105269399

FORTIGATE FIRMWARE ANALYSIS

https://www.optistream.io/blogs/tech/fortigate-firmware-analysis

Further Adventures in Fortinet Decryption

https://bishopfox.com/blog/further-adventures-in-fortinet-decryption

chacha20 算法流程

https://blog.csdn.net/choumin/article/details/132804784

Decrypting a Chacha20-Poly1305 string without using tag\mac

https://stackoverflow.com/questions/77353466/decrypting-a-chacha20-poly1305-string-without-using-tag-mac

搭建 FortiGate 调试环境 (二)

https://wzt.ac.cn/2024/04/02/fortigate_debug_env2/

Modifying Embedded Filesystems in ARM Linux zImages

https://jamchamb.net/2022/01/02/modify-vmlinuz-arm.html