# 漏洞原理

```c
int parse_enc_data(char *in)
{
    int in_len = strlen(in);
    int given_len;
    int xored_given_len;

    if(in_len & 1)
    {
        return 1;
    }

    compute_key_zero(salt, in, 8, md5); // [1] Computes key from salt, seed

    out = alloc_block(*pool, (in_len >> 1) + 1); // [2] Allocate a buffer
    unhex(out, in); // [2] Hexa-decode in to out

    if (out[0]) // first byte of seed must be 0x00
    {
        ap_log_rerror((__int64)a1, 8LL, (__int64)"invalid encoding method %d\n", needs_null);
        return 1;
    }

    // [3] Decrypt given length
    xored_given_len = *((_WORD *)out + 2);
    given_len = (unsigned __int8)(xored_given_len ^ md5[0]);
    BYTE1(given_len) = md5[1] ^ HIBYTE(xored_given_len);

    if ( in_len - 5 <= given_len ) // [4] Verify bounds
    {
        ap_log_rerror(a1, 8LL, "invalid enc data length: %d\n", given_len);
        return 1LL;
    }

    // [5] Decrypt: xor every input from byte 6 (4 bytes for seed, 2 bytes for length)
    p = &out[6];
    if (given_len)
    {
        int i = 0LL;
        while (i < given_len)
        {
            p[i] ^= md5[(i + 3) % 16];
            if ((i + 3) % 16 == 0) // Current state is exhausted: compute new
            {
                MD5_Init(md5_ctx);
                MD5_Update(md5_ctx, md5, 16LL);
                MD5_Final(md5, md5_ctx);
            }
            ++i;
        }
    }
    out[6 + given_len] = 0; // [6] Append null byte

    add_kvp_to_hashmap(a1->params, out); // [7] Process plaintext

    // Allocated buffers get freed at the end of the HTTP exchange
    return 0;
}
```

```
8个字节    in_len: 16    out_buf_size:9     (in_len - 5):11     given_len max:10        溢出1字节
32个字节   in_len: 64    out_buf_size:33    (in_len - 5):59     given_len max:58				 溢出25字节
64个字节   in_len: 128   out_buf_size:65    (in_len - 5):123    given_len max:122  		 溢出57字节
```

```python
#!/bin/python3

in_len = 32

while in_len <= 1024:
    out_buf_len = (in_len>>1)+1
    in_len_5 = in_len - 5
    give_len_max = in_len_5 -1
    print(f"in_len:{in_len} out_buf_len:{out_buf_len} in_len - 5:{in_len_5}  give_len max:{give_len_max} overflow:{give_len_max - out_buf_len}")
    in_len += 2
```

# 资料

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

https://blog.lexfo.fr/xortigate-cve-2023-27997.html

xortigate-cve-2023-27997

https://github.com/lexfo/xortigate-cve-2023-27997?tab=readme-ov-file

Alert: 330,000 FortiGate Firewalls Still Unpatched to CVE-2023-27997 RCE Flaw

https://thehackernews.com/2023/07/alert-330000-fortigate-firewalls-still.html

Fortinet Fortigate RCE (CVE-2023-27997) #18163

https://github.com/rapid7/metasploit-framework/issues/18163