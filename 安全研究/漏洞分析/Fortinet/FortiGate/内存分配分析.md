# FGT 7_2_0



### 内存分配器

分析发现，FGT基本全使用jemalloc进行内存分配



通过代码分析发现：

```
CRYPTO_set_mem_functions(sub_1716960, sub_1716990, sub_1716980) 
```

指定SSL结构体的分配器为jemalloc

```
#0  0x00007f07161e1a90 in je_malloc () from /usr/lib/x86_64-linux-gnu/libjemalloc.so.2
#1  0x0000000001716969 in ?? ()
#2  0x00007f07157d08ca in CRYPTO_zalloc () from /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
#3  0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#4  0x00000000017111c2 in ?? ()
```

### jemalloc

jemalloc 源码分析：https://youjiali1995.github.io/allocator/jemalloc/

As it sounded pretty hard to get anything working, we took a look at the underlying allocator, to see if there were any way to leverage the bug.

The underlying heap, jemalloc, was unknown to us at the time. We were in a hurry (understand: I ragequit when trying to make shadow work) and not looking to acquire a deep understanding of it. Here's what we learned about it:

- Heap metadata is stored independently; you can safely overflow from one chunk (region) to another
- You can easily get contiguous allocations (after filling holes)
- There is some kind of LIFO mechanism on allocations of the same size: freeing a chunk of size N and allocating the same size yields the same pointer.

The last point actually makes the exploitation very much easier: we can allocate the buffer we overflow from, out, at the same address, repeatedly.

版本定位：

```
/ # busybox strings /lib/libjemalloc.so.2  | grep 5
5.2.1-0-gea6b3e973b477b8061e0076bb257dbd7f3faa756
```



### SSL 结构体



通过openssl 中的函数 SSL_new 可以定位 SSL 结构体分配的大小以及位置，该函数的实现位于/lib/libssl.so.1.1中

```c
__int64 __fastcall SSL_new(__int64 a1)
{
........................................
  v3 = CRYPTO_zalloc(6280LL, "ssl/ssl_lib.c", 691LL);
........................................
}
```

大小6280（0x1888）

```
(gdb) bt
#0  0x00007f07161e1a90 in je_malloc () from /usr/lib/x86_64-linux-gnu/libjemalloc.so.2
#1  0x0000000001716969 in ?? ()
#2  0x00007f07157d08ca in CRYPTO_zalloc () from /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
#3  0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#4  0x00000000017111c2 in ?? ()
#5  0x000000000171384c in ?? ()
#6  0x000000000171481c in ?? ()
#7  0x00000000017150e4 in ?? ()
#8  0x0000000001715d47 in ?? ()
#9  0x0000000001716f42 in ?? ()
#10 0x0000000001717236 in ?? ()
#11 0x0000000001717e5d in ?? ()
#12 0x000000000044c88f in ?? ()
#13 0x00000000004554ca in ?? ()
#14 0x000000000045212c in ?? ()
#15 0x0000000000454738 in ?? ()
#16 0x0000000000455061 in ?? ()
#17 0x00007f0715b89deb in __libc_start_main () from /usr/lib/x86_64-linux-gnu/libc.so.6
#18 0x0000000000447daa in ?? ()
(gdb) print $rdi
$1 = 6280
```



常规利用方式为：修改SSL结构体的handshake_func函数指针字段，触发：

```c
int SSL_do_handshake(SSL *s)
{
    int ret = 1;

    if (s->handshake_func == NULL) {
        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);
        return -1;
    }

    ossl_statem_check_finish_init(s, -1);

    s->method->ssl_renegotiate_check(s, 0);

    if (SSL_in_init(s) || SSL_in_before(s)) {
        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {
            struct ssl_async_args args;

            args.s = s;

            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);
        } else {
            ret = s->handshake_func(s);
        }
    }
    return ret;
}
```

函数，从而达到任意代码执行
