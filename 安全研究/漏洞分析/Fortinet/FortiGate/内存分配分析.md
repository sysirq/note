# FGT 7_2_0



### 内存分配器

分析发现，FGT基本全使用jemalloc进行内存分配



通过代码分析发现：

```
CRYPTO_set_mem_functions(sub_1716960, sub_1716990, sub_1716980) 
```

指定SSL结构体的分配器为jemalloc

```
#0  0x00007f07161e1a90 in je_malloc () from /usr/lib/x86_64-linux-gnu/libjemalloc.so.2
#1  0x0000000001716969 in ?? ()
#2  0x00007f07157d08ca in CRYPTO_zalloc () from /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
#3  0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#4  0x00000000017111c2 in ?? ()
```



### SSL 结构体



通过openssl 中的函数 SSL_new 可以定位 SSL 结构体分配的大小以及位置，该函数的实现位于/lib/libssl.so.1.1中

```c
__int64 __fastcall SSL_new(__int64 a1)
{
........................................
  v3 = CRYPTO_zalloc(6280LL, "ssl/ssl_lib.c", 691LL);
........................................
}
```

大小6280（0x1888）



常规利用方式为：修改SSL结构体的handshake_func函数指针字段，触发：

```c
int SSL_do_handshake(SSL *s)
{
    int ret = 1;

    if (s->handshake_func == NULL) {
        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);
        return -1;
    }

    ossl_statem_check_finish_init(s, -1);

    s->method->ssl_renegotiate_check(s, 0);

    if (SSL_in_init(s) || SSL_in_before(s)) {
        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {
            struct ssl_async_args args;

            args.s = s;

            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);
        } else {
            ret = s->handshake_func(s);
        }
    }
    return ret;
}
```

函数，从而达到任意代码执行
