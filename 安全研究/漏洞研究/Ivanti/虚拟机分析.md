# 版本

ps-ics-vmware-isa-v-22.7r2.3-b3431-package

```
export DSREL_MAJOR=22
export DSREL_MINOR=7
export DSREL_MAINT=2
export DSREL_DATAVER=5802
export DSREL_PRODUCT=ssl-vpn
export DSREL_DEPS=ive
export DSREL_BUILDNUM=3431
export DSREL_COMMENT="R2.3"
```

# 文件分析

```
Command (m for help): p
Disk /dev/sdb: 80 GiB, 85899345920 bytes, 167772160 sectors
Disk model: VMware Virtual S
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1           16065    224909    208845  102M 83 Linux
/dev/sdb2          224910    433754    208845  102M 83 Linux
/dev/sdb3          449820    658664    208845  102M 83 Linux
/dev/sdb4          674730 167766794 167092065 79.7G 85 Linux extended
/dev/sdb5          674731  14779799  14105069  6.7G 83 Linux
/dev/sdb6        14779801  30089744  15309944  7.3G 83 Linux
/dev/sdb7        30089746  65802239  35712494   17G 83 Linux
/dev/sdb8        65802241  81112184  15309944  7.3G 83 Linux
/dev/sdb9        81112186 116824679  35712494   17G 83 Linux
/dev/sdb10      116824681 132134624  15309944  7.3G 82 Linux swap / Solaris
/dev/sdb11      132134626 167766794  35632169   17G 83 Linux
```



### sdb1

```
sysirq@sysirqMachine:~/ics$ ls sdb1/
boot.b  compact-file  coreboot.img  disksize  grub  kernel  log_coreboot  lost+found  VERSION
```

### sdb2

```
sysirq@sysirqMachine:~/ics$ ls sdb2
boot.b  coreboot.img  kernel  log_coreboot  lost+found  VERSION
```

### sdb3

```
sysirq@sysirqMachine:~/ics$ ls sdb3/
lost+found
```

### sdb4

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb4 /mnt/
mount: /mnt: mount(2) system call failed: Cannot allocate memory.
       dmesg(1) may have more information after failed mount system call.
```

### sdb5

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb5 /mnt/
mount: /mnt: unknown filesystem type 'LVM2_member'.
       dmesg(1) may have more information after failed mount system call
```

### sdb6

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb6 /mnt/
mount: /mnt: unknown filesystem type 'LVM2_member'.
       dmesg(1) may have more information after failed mount system cal
```

### sdb7

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb7 /mnt/
mount: /mnt: unknown filesystem type 'LVM2_member'.
       dmesg(1) may have more information after failed mount system call.
```

### sdb8

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb8 /mnt/
mount: /mnt: wrong fs type, bad option, bad superblock on /dev/sdb8, missing codepage or helper program, or other error.
       dmesg(1) may have more information after failed mount system call.
```

### sdb9

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb9 /mnt/
mount: /mnt: wrong fs type, bad option, bad superblock on /dev/sdb9, missing codepage or helper program, or other error.
       dmesg(1) may have more information after failed mount system call.
```

### sdb10

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb10 /mnt/
mount: /mnt: unknown filesystem type 'swap'.
       dmesg(1) may have more information after failed mount system call.	
```

### sdb11

```
root@sysirqMachine:/home/sysirq# mount /dev/sdb11 /mnt/
mount: /mnt: wrong fs type, bad option, bad superblock on /dev/sdb11, missing codepage or helper program, or other error.
       dmesg(1) may have more information after failed mount system call.
```

### initrd 确定

```
sysirq@sysirqMachine:~/Work/ics_v22.7r2.3/sdb1/grub$ cat grub.cfg 
set default=0
set timeout=5
insmod ext2
password 07ow3w3d743
serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1
menuentry "Current" {
set root=(hd0,2)
    linux /kernel system=A rootdelay=5 console=ttyS0,115200n8 console=tty0 vm_hv_type=VMware   
    initrd /coreboot.img
}
menuentry "Factory Reset" {
set root=(hd0,1)
    linux /kernel system=Z noconfirm rootdelay=5 console=ttyS0,115200n8 console=tty0 vm_hv_type=VMware   
    initrd /coreboot.img
}
sysirq@sysirqMachine:~/Work/ics_v22.7r2.3/sdb1/grub$ file ../coreboot.img 
../coreboot.img: data
```

通过grub配置文件，可以确定initrd 为 coreboot.img ，但是发现加密了的.。

populate_rootfs 函数是 Linux 内核启动过程中的一个关键函数，用于设置和填充初始的根文件系统。它主要负责处理 initramfs 和 initrd，并确保它们被正确地挂载和初始化。

populate_rootfs的调用流程为: start_kernel --> rest_init--> kernel_init --> kernel_init_freeable --> do_basic_setup --> do_initcalls  --> populate_rootfs

通过分析populate_rootfs函数，貌似是用的aes加解密initrd

```c
struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key,
	                  unsigned int keylen);
	void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
	void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};

static struct crypto_alg aes_alg = {
	.cra_name		= "aes",
	.cra_driver_name	= "aes-asm",
	.cra_priority		= 200,
	.cra_flags		= CRYPTO_ALG_TYPE_CIPHER,
	.cra_blocksize		= AES_BLOCK_SIZE,
	.cra_ctxsize		= sizeof(struct crypto_aes_ctx),
	.cra_module		= THIS_MODULE,
	.cra_u	= {
		.cipher	= {
			.cia_min_keysize	= AES_MIN_KEY_SIZE,
			.cia_max_keysize	= AES_MAX_KEY_SIZE,
			.cia_setkey		= crypto_aes_set_key,
			.cia_encrypt		= aes_encrypt,
			.cia_decrypt		= aes_decrypt
		}
	}
};

static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
```

```c
__int64 __fastcall populate_rootfs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  int v7; // esi
  __int64 v8; // rax
  int v9; // edx
  int v10; // ecx
  int v11; // r8d
  int v12; // r9d
  __int64 v13; // r13
  unsigned __int64 v14; // r12
  int v15; // edx
  int v16; // ecx
  int v17; // r8d
  int v18; // r9d
  unsigned __int64 v19; // r14
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  int v23; // eax
  _DWORD *v24; // rbx
  _DWORD *v25; // r15
  __int64 v26; // rbx
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  int v30; // edx
  int v31; // ecx
  int v32; // r8d
  int v33; // r9d
  int v34; // eax
  unsigned int v35; // ebx
  __int64 v36; // rax
  int v37; // ecx
  int v38; // r8d
  int v39; // r9d
  __int128 v41; // [rsp-90h] [rbp-90h]
  int v42; // [rsp-74h] [rbp-74h]
  _DWORD v43[4]; // [rsp-70h] [rbp-70h] BYREF
  __int128 v44; // [rsp-60h] [rbp-60h] BYREF
  _DWORD v45[6]; // [rsp-50h] [rbp-50h] BYREF
  char *v46; // [rsp-38h] [rbp-38h]
  void *v47; // [rsp-8h] [rbp-8h]
  void *retaddr; // [rsp+0h] [rbp+0h]

  v47 = retaddr;
  v46 = &a7;
  v7 = (int)_irf_end;
  v8 = unpack_to_rootfs(&_security_initcall_end, (__int64)_irf_end, a3, a4, a5);
  if ( v8 )
    panic(-2113148585, v8, v9, v10, v11, v12);
  if ( initrd_start )
  {
    printk((unsigned int)&unk_FFFFFFFF82055898, v7, v9, v10, v11, v12);
    v13 = initrd_start;
    v14 = (unsigned int)(initrd_end - initrd_start);
    v19 = crypto_alloc_base(&aVaes[1], 0LL, 0LL);
    if ( v19 <= 0xFFFFFFFFFFFFF000LL )
    {
      v43[1] = HIDWORD(DSRAMFS_AES_KEY) ^ 0xAEEF41FE;
      v43[0] = DSRAMFS_AES_KEY ^ 0x99ED2BF2;
      v43[2] = qword_FFFFFFFF81E00168 ^ 0x141058C7;
      v43[3] = HIDWORD(qword_FFFFFFFF81E00168) ^ 0xD2ED180E;
      (*(void (__fastcall **)(unsigned __int64, _DWORD *, __int64))(v19 + 8))(v19, v43, 16LL);//crypto_aes_set_key
      v23 = 0;
      while ( v14 > 0x1FF )
      {
        v14 -= 512LL;
        LODWORD(v44) = v23;
        *(_QWORD *)((char *)&v44 + 4) = 0LL;
        v24 = (_DWORD *)(v13 + (unsigned int)(v23 << 9));// 512字节为一个块进行
        v42 = v23 + 1;
        HIDWORD(v44) = 0;
        v25 = v24 + 128;
        (*(void (__fastcall **)(unsigned __int64, _DWORD *, __int128 *))(v19 + 24))(v19, v45, &v44);//static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
        do
        {
          *v24 ^= v45[0];
          v24[1] ^= v45[1];
          v24[2] ^= v45[2];
          v24[3] ^= v45[3];
          v41 = *(_OWORD *)v24;
          (*(void (__fastcall **)(unsigned __int64, _DWORD *, _DWORD *))(v19 + 24))(v19, v24, v24);//static void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
          *v24 ^= v44;
          v24[1] ^= DWORD1(v44);
          v24[2] ^= DWORD2(v44);
          v24[3] ^= HIDWORD(v44);
          v24 += 4;
          v44 = v41;
        }
        while ( v25 != v24 );
        v23 = v42;
      }
    }
    else
    {
      printk((unsigned int)&unk_FFFFFFFF820558D0, 0, v15, v16, v17, v18);
    }
    v26 = unpack_to_rootfs((_BYTE *)initrd_start, initrd_end - initrd_start, v20, v21, v22);
    if ( !v26 )
    {
LABEL_16:
      free_initrd();
      goto LABEL_17;
    }
    clean_rootfs();
    unpack_to_rootfs(&_security_initcall_end, (__int64)_irf_end, v27, v28, v29);
    printk((unsigned int)&unk_FFFFFFFF820558F8, v26, v30, v31, v32, v33);
    v34 = do_sys_open('\xFF\xFF\xFF\x9C', aInitrdImage, 32833LL, 448LL);
    v35 = v34;
    if ( v34 >= 0 )
    {
      v36 = xwrite((unsigned int)v34, initrd_start, initrd_end - initrd_start);
      if ( initrd_end - initrd_start != v36 )
        printk((unsigned int)&unk_FFFFFFFF82055938, v36, initrd_end - initrd_start, v37, v38, v39);
      _close_fd(*(_QWORD *)(__readgsqword((unsigned int)&pid) + 1656), v35);
      goto LABEL_16;
    }
  }
LABEL_17:
  flush_delayed_fput();
  load_default_modules();
  return 0LL;
}
```

# 资料

