#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/bpf.h>
#include "comm.h"

static dev_t devno;
static struct cdev cdev;

struct my_struct {
	int idata;
	long ldata;
	char cdata;
};

const struct my_struct my_struct;

static int simple_cdev_open(struct inode *inode,struct file *filp)
{
	printk("simple_open,my_struct addr:%lX\n",(unsigned long)&array_map_ops);
	return 0;
}

static long simple_cdev_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
{
	userspace_func_add func;
	switch(cmd){
	case FUNC_ADDR:
		func = (userspace_func_add)arg;
		printk("3+5 = %d\n",func(3,5));
		break;
	default:
		return -EINVAL;
	}
	return 0;
}

static const struct file_operations simple_fops = {
	.owner = THIS_MODULE,
	.open = simple_cdev_open,
	.unlocked_ioctl = simple_cdev_ioctl,
};

static int __init simple_cdev_init(void)
{
	int ret;


	ret = alloc_chrdev_region(&devno,0,1,"simple_cdev");
	if(ret != 0){
		printk("alloc_chrdev_region error\n");
		return ret;
	}

	cdev_init(&cdev,&simple_fops);
	ret = cdev_add(&cdev,devno,1);
	if(ret != 0 ){
		printk("cdev_add error\n");
		unregister_chrdev_region(devno,1);
		return ret;
	}
	printk("simple_cdev MAJOR:%d MINOR:%d\n",MAJOR(devno),MINOR(devno));
	printk("simple cdev module init\n");
	return 0;
}

static void __exit simple_cdev_exit(void)
{
	cdev_del(&cdev);
	unregister_chrdev_region(devno,1);
	printk("simple cdev module exit\n");
}

module_init(simple_cdev_init);
module_exit(simple_cdev_exit);
MODULE_LICENSE("GPL");
