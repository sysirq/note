# 漏洞原理

在Linux内核 4.10 到5.1.17，__ptrace_link函数实现中

```c
//从Linux 4.15.0提取
void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
		   const struct cred *ptracer_cred)
{
	BUG_ON(!list_empty(&child->ptrace_entry));
	list_add(&child->ptrace_entry, &new_parent->ptraced);
	child->parent = new_parent;
	child->ptracer_cred = get_cred(ptracer_cred);
}
```

会将被调式进程的 ptracer_cred指向发起调式的cred。该变量会在ptracer_capable函数中进行权限检查使用。

如果低权限进程A创建进程B，进程B创建进程C。进程B执行具有suid权限的程序，然后进程C执行 ptrace 的PTRACE_TRACEME,使得C的ptracer_cred 为特殊权限的cred，在调用exec执行suid的程序。然后使进程B降低为普通权限。此时可以使进程A PTRACE_ATTACH到进程B，进程A利用ptrace控制进程B，进程B利用已经建立好的ptrace关系控制进程C，从而绕过ptracer_capable函数达到特权指令执行的目的(因为虽然B变为普通权限进程，但是C保存的ptracer_capable表示B为具有高权限的进程，所以普通进程B能控制具有特殊权限的进程C)。

根据分析我们知道进程B执行的程序，需要经历过从特权到普通权限的阶段。在处于特权阶段时，是为了让其子进程C执行PTRACE_TRACEME，获取特殊权限的ptracer_cred，处于普通权限的过程是为了让其普通权限的父进程A能ptrace它，从而进行代码注入。

进程C获取特权的ptracer_cred之后，需要执行具有suid权限的程序，等待被进程B控制。

# 测试环境

发行版:ubuntu 18.04.1

内核版本:4.15.0(手动编译的)

架构:amd64

# 危害分析

该exp只能在桌面环境上使用。如果是通过ssh连接到具有桌面环境的系统上，是不能使用的。

# 资料

1.Exp

https://raw.githubusercontent.com/bcoles/kernel-exploits/master/CVE-2019-13272/poc.c

2.漏洞描述

https://bugs.chromium.org/p/project-zero/issues/detail?id=1903