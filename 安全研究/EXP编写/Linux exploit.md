### checksec 
    CANARY    : 对栈添加cookie,函数返回时，对cookie进行检测

    FORTIFY   : 对于一些容易受到攻击的函数如(strcpy,memcpy)添加上对参数长度的检测

    NX        : 数据、堆栈段不可执行

    PIE       : 位置独立的可执行区域

    RELRO     : 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。

### NX 位绕过
1. ret to libc 
    返回地址直接覆盖为libc中的函数
2. Frame Faking
    利用leave指令，构造函数调用链
3. ROP


### ASLR 绕过
1. PTL

    通过直接调用PTL stub code 

2. 暴力破解libc基地址


3. GOT覆盖与 GOT解引用 (ROP)

    程序第一次调用了libc中的函数后，GOT中会存在该函数的地址。然后通过该函数与想要调用的函数的偏移恒定，加上偏移为想调用的函数获取得到想要调用的函数地址。
    
4. ROP:面向返回编程 (xxxxx指令;ret)，由于ASLR不会随机程序中指令的地址(没有开PIC)。


### 堆溢出
1. unlink:
    
    通过覆盖下一个chunk header的头部数据:

        prev_size 为偶数（表示前一个chunk为free）
    
        size=-4(向前合并需要取下下块的chunk header，所以当size为-4时，下下个块就为下一个)
    
        fd = free函数的GOT表地址adddress - 12
    
        bk为shellcode 地址
        
    unlink操作:
    ```c
    #define unlink(P,BK,FD){
        FD = p->fd;
        BK = p->bk;
        FD->bk = BK;
        BK->fd = FD;
    }
    ```
    
    对抗技术：
    
        1.Double Free检测：若前一个块为free块（准备释放的块），则报错
        
        2.Next Size非法检测:检测下一块的大小是否在8到当前arena的整个系统内存大小之间
        
        3.双链表冲突检测:在unlink时，检查需要unlink的chunk的前一个chunk的bk与后一个chunk的fd是否指向当前chunk,如果不是则报错
        
    
        参考质料:https://www.cnblogs.com/alisecurity/p/5563819.html


2. House of force
    
    利用条件:

        1. 可以通过堆溢出修改top chunk中的size 字段
        2. 可以控制malloc的大小
        3. 可以向另一个malloc得到的chunk写数据
        

3. House of spirit
    
    利用条件:
        
        1.能够通过栈溢出，修改一个指向堆内存的指针(修改为指向栈且将前一个字设置为块的大小(fastbin))
        2.该指针会被释放。
        3.程序申请释放掉的内存(fastbin)（已经是栈内存了)，且能对其进行赋值等操作对其进行赋值操作

3. Off by one
    
    利用条件：
        
        1.通过向一个chunk写数据，能够将下一个chunk中的size字段设置为0，
        2.释放该chunk之前的chunk

3. UAF
    
        1. 修改函数指针
        2. 与 off by one 利用方式一样的

#### 堆漏洞总结
    都是想方设法更改chunk中的size字段



### 参考质料
1. http://www.csyssec.org/syssec/
2. https://jaq.alibaba.com/community/art/show?articleid=315
3. https://www.gitbook.com/book/dhavalkapil/heap-exploitation/details
4. https://ctf-wiki.github.io/ctf-wiki/pwn/heap/use_after_free.html