# Java虚拟机内存区域

分为方法区、虚拟机栈、程序计数器、本地方法栈、堆

### 程序计数器

- JVM将这个计数器看作当前线程执行某条字节码的行数，会根据计数器的值来选取需要执行的操作语句。这个属于线程私有，不可共享，如果共享会导致计数器混乱，无法准确的执行当前线程需要执行的语句
- 该区域不会出现任何OutOfMemoryError的情况

### 虚拟机栈

- 虚拟机栈就是指经常说到的栈内存。Java中每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

### 本地方法栈

本地方法栈用来执行本地方法，抛出的异常的情况和虚拟机栈一样。而虚拟机栈用来执行Java方法。

### 堆

是JVM中内存最大、线程共享的一块区域。唯一的目的是存储对象实例。这里也是垃圾收集器主要收集的区域。由于现代垃圾收集器采用的是分代收集算法，所以Java堆也分为新生代和老年代。

### 方法区

JVM中内存共享的一片区域，用来存储类信息、常量、静态变量、class文件。垃圾收集器也会对这部分区域进行回收，比如常量池的清理和类型的卸载。

# 类的生命周期

- 加载 loading
- 验证 verification
- 准备 preparation
- 解析 resolution
- 初始化 initialization
- 使用 using
- 卸载 unloading

# 判断对象是否存活

### 可达性分析算法（根搜索算法）

- 在主流的商用程序语言中（Java和C#），都是可达性判断对象是否存活的
- 根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，把从一个节点GC ROOT开始，如果一个节点与GC ROOT之间没有引用链存在，则该节点视为垃圾回收的对象
- 在Java语言中，可作为GC Roots对象的包括如下几种：
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI的引用的对象

# 对象引用

### 强引用

只要引用存在，垃圾回收器永远不能回收

```java
Object obj = new Object();
```

obj对象对后面new Object有一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉

### 软引用

非必须引用，内存溢出之前进行垃圾回收，可以通过以下代码实现：

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);

obj = null;

sf.get();
```

软引用主要用于实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提示速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

### 弱引用

对第二次垃圾回收时回收，可以通过如下代码实现

```java
Object obj = new Object();
WeakReference<Object> wf = WeakReference<Object>(obj);

obj = null;

wf.get();//有时返回null

wf.isEnQueued()

```

弱引用主要用于监视对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器

### 虚引用（幽灵/幻影引用）

在垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现"

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object<(obj);

obj = null;

pf.get();//永远返回 null

pf.isEnQueued();
```

虚引用主要用来检测对象是否已经从内存中删除

# 垃圾回收

### 分代垃圾回收的提出

在Java代码中，Java语言没有显示的提供分配内存和删除内存的方法。一些开发人员将引用对象设置为null或者调用System.gc()来释放内存

在java中，由于开发人员没有在代码中显示删除内存，所以垃圾收集器会去发现不需要的对象，然后删除它们，释放内存。

分代垃圾收集器主要基于以下两个假设而创建的

- 1.绝大多数对象在短时间变得不可达
- 2.只有少量老年对象引用年轻对象

### 年轻代和老年代

年轻代：新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域中消失时，我们说发生了一次“minor GC”.

老年代：没有变得不可达，存活下来的年轻代对象被复制到这里。这块内存区域一般大于年轻代。因为它更大的规模，GC发生的次数比在年轻代少。对象从老年代消失时，我们说“major GC”发生了。

### 年轻代组成部分

年轻代总共有3块空间，1块Eden，2块为Survivor。各个空间的执行顺序如下：

- 绝大多数新创建的对象分配在Eden区
- 在Eden区发生一次GC后，存活的对象移到Survivor区
- 一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。
- 经过重复多次这样的步骤后依旧存活的对象将被移到老年代

### Generational Collection（分代收集）算法

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集器时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时，都有大量的对象需要被回收，那么就可以根据不同的特点采用最适合的收集算法

目前大部分垃圾收集器对新生代采用Copying算法。因为新生代每次垃圾回收时都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不按照1：1的比例来划分新生代的空间的，一般来说将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compat算法

注意，在堆区之外还有一个就是永久代，它用来存储class类、常量、方法秒速。对永久代的回收主要回收两部分内容：废弃常量和无用的类