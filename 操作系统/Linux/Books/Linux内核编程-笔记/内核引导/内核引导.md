# BIOS
与硬件相关的系统初始化代码，然后加载BootLoader

# 引导加载程序（BootLoader）
搜索活动引导分区，并复制活动引导分区的代码到内存，然后递交CPU控制权

# GRUB

基于x86的引导加载程序，且是一个两阶段的引导加载程序

第一阶段：

1.初始化

2.检测正在加载的驱动器

3.加载第一阶段的第一个扇区（GRUB）

4.跳转到第二阶段

第二阶段：

1.加载第二阶段的剩余代码

2.跳转到已加载的代码

GRUB 采用 多重引导规范，多重引导规范规定，当引导加载程序激活操作系统时，系统必须运行于特定的32位实模式状态，并为操作系统提供填满基本机器数据的数据结构，讲控制权交给操作系统后，指向该结构体的指针将被存入寄存器EBX中。

# 与体系结构相关的内存初始化

过程分许：
1. 获取物理内存信息

2. 加载内核镜像

3. 临时 GDI 与 IDT 创建与加载 

4.进入保护模式 

5.创建临时页目录与页表

与体系结构密切相关的天性决定了内存管理是首先进行初始化的子系统之一。

地址转换过程：逻辑地址（段选择器与EIP的组合）--》线性地址（EIP）--》物理地址

# 原始RAM盘
initrd

# 开始：start_kernel()
跳转到start_kernel时，会执行进程0，也就是通常所说的根用户线程，进程0孕育出了进程1，然后进程0变成了空闲进程。

#### 调用 page_address_init()
内存子系统初始化时最先调用的函数。初始化页地址散列表:page_address_htable

#### 输出linux_banner
输出定义在 init/version.c中的linux_banner，该字符串为用户提供内核版本。用户编译内核的gcc版本，以及发布版本等参考信息

#### 调用 setup_arch
接受一个传入内核的命令数据的指针，初始化许多特定于体系结构的子系统，例如内存、IO、处理器和控制台

#### 调用setup_per_cpu_areas
用于多处理环境，为每个cpu分配内存并初始化

#### 调用smp_prepare_boot_cpu

#### 调用sched_init

#### 调用 build_all_zonelist
创建内存区

#### 调用page_alloc_init

#### 调用trap_init
初始化硬件应用表

#### 调用init_IRQ
初始化硬件中断控制器和中断向量表