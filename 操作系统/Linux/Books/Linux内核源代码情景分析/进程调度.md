在Intel i386 CPU中，提供了TSS与TR用于任务切换，但是Linux出于效率的考虑自己实现了任务切换。但Linux内核还是使用了TSS，用于完成系统堆栈空间的自动切换（从用户空间进入系统空间时的堆栈切换）。


# 进程调度与切换

三种不同应用的需求：交互式，批处理，实时

调度政策：内核为系统中的每个进程计算出一个反映其运行“资格”的权值，然后挑选权值最高的进程投入运行。在运行过程中，当前进程的资格随时间而递减，从而在一次调度的时候原来资格较低的进程可能更有资格运行了。到所有进程的资格都变成了0时，就重新计算一次所有进程的资格。资格的计算主要是以优先级为基础的，所以说是以优先级为基础的调度。

TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE的区别是：前一个能被信号唤醒，后一个不能。

对于普通进程的权值计算（goodness函数），取决于nice值与剩下的时间配额。

如果当前就绪队列中的所有进程的权值都为0，则要重新计算所有进程的时间配额。注意是所有进程的时间配额，这样对于不在就绪队列中的进程，提升了其时间配额，进一步提升了其综合权值。

# 强制性调度

- 在时钟中断的服务程序中，发现当前进程运行的时间过长。
- 当唤醒一个睡眠中的进程时，发现被唤醒的进程比当前进程更有资格运行。
- 一个进程通过系统调用改变调度政策或礼让。这种情况实际上应该被视为主动的、自愿的调度，因此这样的系统调用会引起立即调度。