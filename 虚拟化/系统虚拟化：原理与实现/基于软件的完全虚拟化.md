# CPU虚拟化

### 解释执行

取一条指令，模拟出这条指令执行的效果，在继续取下一条指令，周而复始。

虽然这种方法保证了所有指令执行都受到VMM的监视控制，然而它对每条指令不区别对待，其最大的缺点就是性能太差。由于这里所说的虚拟化前提是模拟与物理机相同体系结构的虚拟机，那么至少有很多非敏感指令就不需要模拟而可以直接在物理CPU上运行。这便诞生了以下两种改进技术。

### 扫描与修补

流程如下：

- VMM会在虚拟机开始执行每段代码之前对其进行扫描，解析每一条指令，查找到特权指令和敏感指令。
- 补丁代码会在VMM中动态生成，通常每一个需要修补的指令会对应一块补丁代码。
- 敏感指令被替换成一个外跳转，从虚拟机跳转到VMM的空间中，在VMM中执行动态生成的补丁代码。
- 当补丁代码执行完成后，执行流再跳转回虚拟机的下一条代码继续执行。

### 二进制代码翻译

为了更好地提高性能，更为复杂的代码缓冲区技术也被用到了模拟技术。二进制代码翻译技术在VMM中开辟一块代码缓存，将代码翻译放好在其中。这样，客户机操作系统代码并不会直接被物理CPU执行，所有要被执行的代码都会在代码缓存中。


# 内存虚拟化 

影子页表

# IO虚拟化

捕获与模拟

hypercall